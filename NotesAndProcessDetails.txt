This document is intend to be a snapshot of what I am doing and learning each time I make progress towards Teboarw development with its primary focus being on the Dotnet API back bone of the application.

Currently I am progreessing through some tutorial videos and msft documentation in hopes to get a better ground of the ms dev environment and the best way to get an api in place that also handles authentication

Jan 18 2024:
    Began Udemy coursework going from scaatch and creating an angular/ c# web application 

    Build an app with ASPNET Core and Angular from scratch Notes:

        Dotnet CLI Commands:
            dotnet --info
                will show which sdks and runtimes are available to use and dev against and run dlls against
                    Example output: 
                        Runtime Environment:
                        OS Name:     Mac OS X
                        OS Version:  14.2
                        OS Platform: Darwin
                        RID:         osx-arm64
                        Base Path:   /usr/local/share/dotnet/sdk/8.0.100/

                        .NET workloads installed:
                        Workload version: 8.0.100-manifests.6c33ef20
                        There are no installed workloads to display.

                        Host:
                        Version:      8.0.0
                        Architecture: arm64
                        Commit:       5535e31a71

                        .NET SDKs installed:
                        6.0.414 [/usr/local/share/dotnet/sdk]
                        6.0.416 [/usr/local/share/dotnet/sdk]
                        6.0.417 [/usr/local/share/dotnet/sdk]
                        7.0.308 [/usr/local/share/dotnet/sdk]
                        7.0.310 [/usr/local/share/dotnet/sdk]
                        7.0.311 [/usr/local/share/dotnet/sdk]
                        8.0.100 [/usr/local/share/dotnet/sdk]

                        .NET runtimes installed:
                        Microsoft.AspNetCore.App 6.0.22 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 6.0.24 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.11 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.13 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.NETCore.App 6.0.22 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 6.0.24 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.11 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.13 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]

            dotnet -h 

            
                output all the available commands 
                outpu:
                    Execute a .NET SDK command.
                    sdk-options:
                    -d|--diagnostics  Enable diagnostic output.
                    -h|--help         Show command line help.
                    --info            Display .NET information.
                    --list-runtimes   Display the installed runtimes.
                    --list-sdks       Display the installed SDKs.
                    --version         Display .NET SDK version in use.

                    SDK commands:
                    add               Add a package or reference to a .NET project.
                    build             Build a .NET project.
                    build-server      Interact with servers started by a build.
                    clean             Clean build outputs of a .NET project.
                    format            Apply style preferences to a project or solution.
                    help              Show command line help.
                    list              List project references of a .NET project.
                    msbuild           Run Microsoft Build Engine (MSBuild) commands.
                    new               Create a new .NET project or file.
                    nuget             Provides additional NuGet commands.
                    pack              Create a NuGet package.
                    publish           Publish a .NET project for deployment.
                    remove            Remove a package or reference from a .NET project.
                    restore           Restore dependencies specified in a .NET project.
                    run               Build and run a .NET project output.
                    sdk               Manage .NET SDK installation.
                    sln               Modify Visual Studio solution files.
                    store             Store the specified assemblies in the runtime package store.
                    test              Run unit tests using the test runner specified in a .NET project.
                    tool              Install or manage tools that extend the .NET experience.
                    vstest            Run Microsoft Test Engine (VSTest) commands.
                    workload          Manage optional workloads.

                    Additional commands from bundled tools:
                    dev-certs         Create and manage development certificates.
                    fsi               Start F# Interactive / execute F# scripts.
                    user-jwts         Manage JSON Web Tokens in development.
                    user-secrets      Manage development user secrets.
                    watch             Start a file watcher that runs a command when files change.

            dotnet new -h 
                lists what you can do with the new command 
                output:
                    Usage:
                    dotnet new [<template-short-name> [<template-args>...]] [options]
                    dotnet new [command] [options]

                    Arguments:
                    <template-short-name>  A short name of the template to create.
                    <template-args>        Template specific options to use.

                    Options:
                    -o, --output <output>    Location to place the generated output.
                    -n, --name <name>        The name for the output being created. If no name is specified, the name of the output directory is used.
                    --dry-run                Displays a summary of what would happen if the given command line were run if it would result in a template creation.
                    --force                  Forces content to be generated even if it would change existing files.
                    --no-update-check        Disables checking for the template package updates when instantiating a template.
                    --project <project>      The project that should be used for context evaluation.
                    -v, --verbosity <LEVEL>  Sets the verbosity level. Allowed values are q[uiet], m[inimal], n[ormal], and diag[nostic]. [default: normal]
                    -d, --diagnostics        Enables diagnostic output.
                    -?, -h, --help           Show command line help.

                    Commands:
                    create <template-short-name> <template-args>  Instantiates a template with given short name. An alias of 'dotnet new <template name>'.
                    install <package>                             Installs a template package.
                    uninstall <package>                           Uninstalls a template package.
                    update                                        Checks the currently installed template packages for update, and install the updates.
                    search <template-name>                        Searches for the templates on NuGet.org.
                    list <template-name>                          Lists templates containing the specified template name. If no name is specified, lists all templates.
                    details <package-identifier>                  Provides the details for specified template package.
                                                                        The command checks if the package is installed locally, if it was not found, it searches the configured NuGet feeds.

            dotnet new list
                lists all the templates available to create projects 
                output:
                    Template Name                                 Short Name                  Language    Tags                            
                    --------------------------------------------  --------------------------  ----------  --------------------------------
                    API Controller                                apicontroller               [C#]        Web/ASP.NET                     
                    ASP.NET Core Empty                            web                         [C#],F#     Web/Empty                       
                    ASP.NET Core gRPC Service                     grpc                        [C#]        Web/gRPC/API/Service            
                    ASP.NET Core Web API                          webapi                      [C#],F#     Web/WebAPI/Web API/API/Service  
                    ASP.NET Core Web API (native AOT)             webapiaot                   [C#]        Web/Web API/API/Service         
                    ASP.NET Core Web App (Model-View-Controller)  mvc                         [C#],F#     Web/MVC                         
                    ASP.NET Core Web App (Razor Pages)            webapp,razor                [C#]        Web/MVC/Razor Pages             
                    ASP.NET Core with Angular                     angular                     [C#]        Web/MVC/SPA                     
                    ASP.NET Core with React.js                    react                       [C#]        Web/MVC/SPA                     
                    Blazor Server App                             blazorserver                [C#]        Web/Blazor                      
                    Blazor Server App Empty                       blazorserver-empty          [C#]        Web/Blazor/Empty                
                    Blazor Web App                                blazor                      [C#]        Web/Blazor/WebAssembly          
                    Blazor WebAssembly App Empty                  blazorwasm-empty            [C#]        Web/Blazor/WebAssembly/PWA/Empty
                    Blazor WebAssembly Standalone App             blazorwasm                  [C#]        Web/Blazor/WebAssembly/PWA      
                    Class Library                                 classlib                    [C#],F#,VB  Common/Library                  
                    Console App                                   console                     [C#],F#,VB  Common/Console                  
                    dotnet gitignore file                         gitignore,.gitignore                    Config                          
                    Dotnet local tool manifest file               tool-manifest                           Config                          
                    EditorConfig file                             editorconfig,.editorconfig              Config                          
                    global.json file                              globaljson,global.json                  Config                          
                    MSBuild Directory.Build.props file            buildprops                              MSBuild/props                   
                    MSBuild Directory.Build.targets file          buildtargets                            MSBuild/props                   
                    MSTest Playwright Test Project                mstest-playwright           [C#]        Test/MSTest/Playwright          
                    MSTest Test Project                           mstest                      [C#],F#,VB  Test/MSTest                     
                    MVC Controller                                mvccontroller               [C#]        Web/ASP.NET                     
                    MVC ViewImports                               viewimports                 [C#]        Web/ASP.NET                     
                    MVC ViewStart                                 viewstart                   [C#]        Web/ASP.NET                     
                    NuGet Config                                  nugetconfig,nuget.config                Config                          
                    NUnit 3 Test Item                             nunit-test                  [C#],F#,VB  Test/NUnit                      
                    NUnit 3 Test Project                          nunit                       [C#],F#,VB  Test/NUnit                      
                    NUnit Playwright Test Project                 nunit-playwright            [C#]        Test/NUnit/Playwright           
                    Protocol Buffer File                          proto                                   Web/gRPC                        
                    Razor Class Library                           razorclasslib               [C#]        Web/Razor/Library               
                    Razor Component                               razorcomponent              [C#]        Web/ASP.NET                     
                    Razor Page                                    page                        [C#]        Web/ASP.NET                     
                    Razor View                                    view                        [C#]        Web/ASP.NET                     
                    Solution File                                 sln,solution                            Solution                        
                    Web Config                                    webconfig                               Config                          
                    Worker Service                                worker                      [C#],F#     Common/Worker/Web               
                    xUnit Test Project                            xunit                       [C#],F#,VB  Test/xUnit   

            dotnet new sln
                created a new sln file with the director name if none specified

            dotnet new webapi -n TeborawAPI
                creates a new api project in the solution directory and pull in the default templated files courtesy of msfy 

            dotnet sln -h 
                list all commands available to use on the soution 

            dotnet sln add TeborawAPI 
                Adds the Templated Project to the solutions file 

            code .
                if no command found open vs code cmd shift + p and type shell in the search box and select the option to instal the code shell utility 
                will open the containing folder in vscode 

            code color highlight were not working:
                THe code them dark was at fault 
                cmd shift + p and changed them to dark + isntead voila 

            dotnet run:
                from the api proj directory if you run this command it will compile and run the template projcect
                output:
                    Building...
                    info: Microsoft.Hosting.Lifetime[14]
                        Now listening on: http://localhost:5224
                    info: Microsoft.Hosting.Lifetime[0]
                        Application started. Press Ctrl+C to shut down.
                    info: Microsoft.Hosting.Lifetime[0]
                        Hosting environment: Development
                    info: Microsoft.Hosting.Lifetime[0]
                        Content root path: /Users/rompasaurus/TeborawWebApp/TeborawAPI

            http://localhost:5224/swagger
                takes you to the swagger endpoint which should show all available api enpoints in dev mode of course

            port and url mappings:
                Held within the launchsettigns.json
                
                adjusted http launch settings to allow https and http specifying port 5000
                  "profiles": {
                    "http": {
                    "commandName": "Project",
                    "dotnetRunMessages": true,
                    "launchBrowser": true,
                    "launchUrl": "swagger",
                    "applicationUrl": "http://localhost:5000;https://localhost:5001",
                    "environmentVariables": {
                        "ASPNETCORE_ENVIRONMENT": "Development"
                    }
                },


            dotnet watch:
                runs your .net application with hot reloading checking for file updates and auto pushing if available
                will log those events as well 

Jan 19 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        https certificates:
            Are issue typically by default with the dotnet sdk if not trusted by browser run 
            dotnet dev-certs https --trust 
            clean than trust if not work 
            dotnet dev-certs https --clean 
            dotnet dev-certs https --trust 

        get debugs to be more verbose 
        appsettings.development.json > set Loglevel > default to onformational

        installed the entity framework and postgres entity drivers 
            had to install the nuget package manager and library 

        Double check the namespace when you make a new class or file ensure the namespace follows:
            projectname.folder 

        cmd + p > quickest way to open a file in vscode 

        created dbContext with the AppUser to start and DI'd via the program.cs

        builder.Services.AddDbContext<DataContext>(opts =>
        {
            opts.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"));
        });
        create DefaultConnection in appsettings.json 
              "ConnectionStrings": {
                    //Postgres docker db  
                    "DefaultConnection": "Server=localhost; Port=5432; Database=Teboraw; Username=Teboraw; Password =Bigmac12!;TrustServerCertificate=true"
                }
        Going to need to obfuscate these creds eventually 

        Create first migration -> dotnet ef cli tools need to be installed first 
            command:
                dotnet tool install --global dotnet-ef

                dotnet ef -h
                    help options for ef and commands available 

                dotnet ef migrations add InitialCreate -o Data/Migrations
                    creates the first migration pack and scripts 

                dotnet tool -list
                    shows all dn tools available including ef cli 

                dotnet ef database update 
                    applies all migrations existing and unapplied
                    applies the table and you should be able to view newly create column and db via connecor (datagrip)

                Creeated a users controller:
                    namespace TeborawAPI.Controllers;
                        [ApiController]
                        [Route("api/[controller]")] // /api/users
                        public class UsersController : ControllerBase
                        {
                            private readonly DataContext context;

                            public UsersController(DataContext context)
                            {
                                this.context = context;
                            }
                        }
            
        Routing error The routes dont get mapped without this ffs:
            added this to the startup.cs and all is well 
            app.MapControllerRoute(
                name: "default",
                pattern: "{controller}/{action=Index}/{id?}");

        Asynchronous api operations:
            public async Task 
            ex:     public async Task<ActionResult<AppUser>> GetUser(int id)
            allows the api server to pass this query to a delegate and handle other requests while sql retrieves
            make sure to await the return call to allow the function to be delegated 
                examle var users = await _context.Users.ToListAsync();

Jan 20 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        Starting with angulare install the node cli along with angular cli gonna go with angular 17 instead of 16 

        npm install -g @angular/cli

        ng version:
            will show you the install angualr version number along with node version as well
        
        Create angular application 
        ng new client 
            css styling select and 
            enable Server-Side Rendering (SSR) to allow for better web anayitics and google search availability
            this didnt have all the features i needed including routing and app module template had to use 
            ng new client --no-standalone --routing --ssr=true

        running angular template app 
            cd into template folder 
            command: 
                ng serve

            index.html is the starting page for the angular > which then cascades and loads the <app-root></app-root> which a component named app.compoennt.html/ts

        ctr + p allow quick open of a file 

        wire up angular to hit controller endpoint
            import the httpclienmodule in app.module 
              imports: [
                    BrowserModule,
                    AppRoutingModule,
                    HttpClientModule
                ],
        Slap that httpmodule into a component 
            via DI in the conststructor 
                constructor(private http: HttpClient){}
            extend componet class from OnInit to add a lifecycle step
            implement oninit method and try out a quick http get pull 
                this.http.get('https://localhost:5001/api/users').subscribe({
                    next: response => this.users = response,
                    error: error => console.log("Failed to pull user data error: ", error),
                    complete: () => console.log('User Request Completed! ')
                })
            make sure api is running > dotnet watch 
            gonna invariably get a cors cross site rejection error need to setup dotnet to allow specified origins to pull from api

        Addressing cors errors 
            is done on the api side add a header to the response that allow angular to trust data 
            program.cs 
                add the cors service 
                Code:
                    builder.Services.AddCors();
                
                create the middleware to inject the cors headers prior to sending back a response 
                add code just before the mapCOntroller call
                Code:
                    app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200"));

                request completes succ you can check the data passed back via 
                debug > network tab > click users form name list > preview tab to view data 
                [
                    {
                        "id": 2,
                        "userName": "Bob"
                    },
                    {
                        "id": 3,
                        "userName": "Tom"
                    },
                    {
                        "id": 4,
                        "userName": "Jane"
                    }
                ]

                quick angular tip just type the html tag name without the <> and you can add a class by adding .class name and then tab to auto create the html element 
                ie:
                    ul.ulClass name > turns into <ul class="ulClassNmae"></ul>

                add users to page and iterate over all users 
                    <li class="bold" *ngFor="let user of users">
                        {{user.id}} - {{user.userName}}
                    </li>
                    *ngFor is the key thing to not allows you iterate of a list of objects
                    FYI > .net api calls return json data with camelcasing by default 
                        userName insteaed of username 
                
        Add Bootstrap Styling 
            that has angular implementations
            ngx-bootstrap
            https://valor-software.com/ngx-bootstrap/#/
            cli command: 
                    ng add ngx-bootstrap
                received erro auto way went manual way instead 
                    npm install ngx-bootstrap --save
                imported the module manually
                added bootstrap.css 
                angular.json:
                    "styles": [
                        "src/styles.css",
                        "./node_modules/font-awesome/css/font-awesome.css",
                        "./node_modules/bootstrap/dist/css/bootstrap.min.css"
                        ],
                update app.module with:
                imported module via app.module 
                    mport { TooltipModule } from 'ngx-bootstrap/tooltip';
                    imports: [ TooltipModule.forRoot(), BrowserAnimationsModule]

                package.json should have entry for 
                    "ngx-bootstrap": "^12.0.0",
            install fontawesome 
                npm install fontawesome


        Error Port 4200 is already in use.:
            sudo kill -9 $(sudo lsof -t -i:4200) 
            to kill rogue angular app


Jan 21 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        Add ssl and certs to angular application:

    install mkcert:
        https://github.com/FiloSottile/mkcert
        brew install mkcert
        brew install nss # if you use Firefox   

    make ssl directory in the client folder
        mkdir ssl

    install the cert authority from the ssl directory 
        mkcert -install 

    Create the certificate for localhost for now domain later 
        mkcert localhost

        creates both a publich and private key for specified domain (localhost)

    Wire in cert to angular.json
        inside of "server":
        "serve": {
            "options": {
                "ssl": true,
                "sslCert": "./ssl/localhost.pem"
                "sslKey": "./ssl/localhost-key.pem"
            },
        restart angular app and site should auto redirect to https with a trusted cert 
        be aware this is a self signed certificate 

    fix cors to allow  
        ssl error:
            Access to XMLHttpRequest at 'https://localhost:5001/api/users' from origin 'https://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
       
        with the cert you will need to update the api to allow ssl connections 

        change: 
        app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200"));
        to ->
        app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("https://localhost:4200"));

    AUTHENTICATION BABY!!
        Learning Objectives 
            how to store pw's in db hint as a hash with a salt string to randomize the hash a bit 
            using inheritance 
            validation 
            json web tokens 
            c# services 

        add byte arrays props to the user class 
                public Byte PasswordHash { get; set; }
                public Byte PasswordSalt { get; set; }

        Create a migration to update the table entry
            Create migrations via command:
                dotnet ef migrations add UserPasswordAdded
            Update database 
                dotnet ef database update

        Create BaseAPiCOntroller to simplify and not repeat the route and api declarations 
            create the class then inherit from it ex:
                public class UsersController : BaseAPIController

        create an accounts controller to allow for user registration with a passwor dand setup hashing:
            public class AccountsController: BaseAPIController
            using var hmac = new HMACSHA3_512();
            ##Using keyword allows for the hmac object to be disposed of after use
            any classes that implement the idisposable method need a dispose() call to be initated
            using limits the scope of the variable to the function intantiate within and auto displose upon execution

        postman usage:
            you can set a url variable globally to use ion all you endpoint tests via:
                select main project in the collention and go to the variabl tab on the main page add a :
                    url variabl with intial value https://localhost:5001

                can inject into a endpoint test via formulating url as :
                    {{url}}/api/account/register

            parameters need to be passed via query string 
                Example
                Register(string username, string password)
                need to be request via 
                /api/register?username=examplname&password=expassword

        register error
            selected wrong sha crypto  full function for ref:
                [HttpPost("register")] // api/account/register
                public async Task<ActionResult<AppUser>> Register(string username, string password)
                {
                    using var hmac = new HMACSHA512();
                    var user = new AppUser()
                    {
                        UserName = username,
                        PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password)),
                        PasswordSalt = hmac.Key
                    };
                    _context.Users.Add(user);
                    await _context.SaveChangesAsync();
                    return user;
                }

        Adding dto's and validations 
            create dir dtos and add reigsterdto 
            public class RegisterDTO
            {
                public string Username { get; set; }
                public string Password { get; set; }
            }
            json sends in lower case for properties, dtop with upper case begins still bind as lowercase in json 
        
        Validate username and pw is not empty
            validation ad the db level
                add the [Required] decorator to the entitity data model 
                    [Required]
                    public string UserName {get; set;}
                you have to create a new migration to establish this change 
            
            At the dto level server side:
                add same required decorator to the sdt example:
                    public class RegisterDTO
                    {
                        [Required]
                        public string Username { get; set; }
                        [Required]
                        public string Password { get; set; }
                    }
                get a nice error whe passing in a blank user or pw 

                    "title": "One or more validation errors occurred.",
                    "status": 400,
                    "errors": {
                        "Password": [
                            "The Password field is required."
                        ],
                        "Username": [
                            "The Username field is required."
                        ]
                    },
                [ApiController]
                decorator enables this validation to occur on the Controllers
                without this decorator it wont do these checks and [fromBody] would need to be added to the controllers endpoint for it to map properly to a specified dto object
                this decorator automatically checks the model state that is establish when the endpoint is reached and dtop ios mapped 

        Setup login endpoint:  
            see code, validation for user and pass in place and hash compute and varification established here
                [HttpPost("login")]
                public async Task<ActionResult<AppUser>> Login(LoginDTO loginDTO)
                {
                    var user = await _context.Users.FirstOrDefaultAsync(u => u.UserName.ToLower() == loginDTO.Username.ToLower());
                    
                    if (user == null) return Unauthorized("Invalid Username");
                    //validate password by reversing the hash algo 
                    using var hmac = new HMACSHA512(user.PasswordSalt);
                    //pull the compute hash of user imput pw  
                    var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(loginDTO.Password));

                    for (int i = 0; i < computedHash.Length; i++)
                    {
                        if (computedHash[i] != user.PasswordHash[i]) return Unauthorized("Invalid password");
                    }
                    
                    return user;

                }

        JWT > JSON Web Tokens 
            Structure 3 parts
                Header contains algo and tokent type: 
                    {
                        "alg": "HS512",
                        "typ": "JWT"
                    }
                Payload Data
                    {
                        "nameid" : "lola"
                        "role" : "Member"
                        //time stamps for expiry dates of key and session nbf i the the time at wich token cannot be used before 
                        "nbf": 134653462,
                        "exp": 136345645,
                        "iat": 246357357,
                    }
                Verify Signature 
                    HMACSHA512(
                        base64UrlEncode(header) + "." +
                        base64UrlEncode(paylod),
                        your-256-secret
                    ) secret base64 encoded 

            Stages of auth 
                1 user logs in passing in username and password
                2 server receives login data and validates that password 
                3 server returns a token in respons if user is authenticate 
                4 client/user receives the jwt in response and stores locally passing the token back with each http subsequent http requests
                the request are sent with an additional authentication header portion
                5 the server then upon request uses the jwt header and validates with that key instead of the user needing to submit pw         information each time  

            JWT Beneftis:
                no session to manage jwts are self contained tokens 
                portable:  a single token can be used with multiplpe backends 
                no cookies required, mobile firendly as phone dont use cookies 
                performance once token established no need for more db calls to validate user auth 

            Token Service Creation:
                create the token interface 
                    public interface ITokenService
                    {
                        string CreateToken(AppUser user);
                    }
                Create the service that built using the interface 
                    public class TokenService: ITokenService
                    {
                        public string CreateToken(AppUser user)
                        {
                            throw new NotImplementedException();
                        }
                    }
                Imject the service to the program.cs 
                    builder.services.
                        AddTransient:
                            A very short lived service whose lifecycle is just for the duration of its call and use then it is dsipose 
                        AddScope: the standard 
                            A longer living service that lasts the duration of the https request meaning a specific controller call 
                        AddSingleton:
                            A service is instantiated once upon itself at the start of the api program launch and is never disposed ofbut only one instance exists typically better to dsipose after use to free memory especially with services are not need on a constant basis.
                            caching services typicall fall under this use case for quick data retrieval

                    Code: 
                    builder.Services.AddScoped<ITokenService, TokenService>();

                Build out service using config key:
                    creating a service as an interface will help later with testing 

                    Install System.IdentityModel.Tokens.Jwt by Microsoft
                        alolows you to establish a secret key for signing jwts tokens 

                    public class TokenService: ITokenService
                    {
                        private readonly SymmetricSecurityKey _key;
                        
                        public TokenService(IConfiguration config)
                        {
                            _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["TokenKey"]));
                        }
                        public string CreateToken(AppUser user)
                        {
                            // Add the users claimset, need to atleast have a username or id identifier further claims will be added later once funcitionailty requiring it is established
                            var claims = new List<Claim>()
                            {
                                new Claim(JwtRegisteredClaimNames.NameId, user.UserName),
                            };
                            //Establish the highest sha 512 ecryption key generation for token signature 
                            var credentials = new SigningCredentials(_key, SecurityAlgorithms.HmacSha512Signature);
                            //Set expiry and issuance dates along with claims
                            var tokenDescriptor = new SecurityTokenDescriptor()
                            {
                                Subject = new ClaimsIdentity(claims),
                                Expires = DateTime.Now.AddDays(7),
                                SigningCredentials = credentials
                            };

                            var tokenHandler = new JwtSecurityTokenHandler();
                            var token = tokenHandler.CreateToken(tokenDescriptor);
                            //using System.IdentityModel.Tokens.Jwt; takes provided token details and establishes a properly formatted jwt token 
                            return tokenHandler.WriteToken(token);
                        }
                    }

            Establish a dto for user and associated jwt
                public class UserDTO
                {
                    public string Username { get; set; }
                    public string Token { get; set; }

                }

            inject the Itoken service to the controller 
                private readonly ITokenService _tokenService;

                public AccountController(DataContext context, ITokenService tokenService)
                {
                    _context = context;
                    _tokenService = tokenService;
                }
            replace everywhen in the accountcontroller a user is return and return instead a userDTO with a generated token 
                return new UserDTO()
                {
                    Username = user.UserName,
                    Token = _tokenService.CreateToken(user)
                };
            Create you token key secret but just for development for now in appsettings.json.developmen
                {
                    "Logging": {
                        "LogLevel": {
                        "Default": "Information",
                        "Microsoft.AspNetCore": "Information"
                        }
                    },
                    "TokenKey": "dontevenbothertryingtoguessthiscuzyoucantitssosecretandifyoutellanyoneillkillyou"
                }
            rebuild code and  login endpoint upon successful login should return username and the token 
            example response :
                {
                    "username": "dildo",
                    "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJkaWxkbyIsIm5iZiI6MTcwNTg2MzY3N
                }iwiZXhwIjoxNzA2NDY4NDc2LCJpYXQiOjE3MDU4NjM2NzZ9.YJJKK9j0QOzuXW421ejToDOOKsqzH2Qr2I49odh0vTOUUeHBRBLWRl2wNkJ9THElLRjbmQs_hMnbkWZCWKl5mQ"

            
        How to peak inside a token block:
            jwt.ms > go to this site 
            heres example output
                paste the token here 
                {
                    "alg": "HS512",
                    "typ": "JWT"
                }.{
                    "nameid": "dildo",
                    "nbf": 1705863676,
                    "exp": 1706468476,
                    "iat": 1705863676
                }.[Signature]

        Authorize the routes:
            add the decorator to the routes in the controller 
            [Authorize] either on the route or on the controller as a whole

            need to then plug in the middleware that routes the authorize right to execute the routes
            
        Setup Authorize middleware for jwt bearer tokens 
            install nuget package Microsoft.AspNetCore.Authentication.JwtBearer by Microsoft 8.00
            Program.cs
            //The location of these need to be after cors establishment but prior to route and controller mapping 
            // Are you who you say you are 
            app.UseAuthentication();
            // What are you allowed to do
            app.UseAuthorization();
            also 
                app.UseHttpsRedirection();
                app.UseStaticFiles();
                app.UseRouting();
                needs to be setup prior to auth establishment in progrma.cs

        Test the route:
            Get the token from the login route 
            then use that toke value to add to get request to the users list route in postman 

            add key: Authorization
                value: Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJkaWxkbyIsIm5iZiI6MTcwNTg2NjMyNSwiZXhwIjoxNzA2NDcxMTI1LCJpYXQiOjE3MDU4NjYzMjV9.JQV2KIRmL7DL1JL9565ankWKKBMfHU31dWiAyp8tbo6_861tPDAAdr6SftrEN-a9dtsUqcRxbEUdy1-rNxKeGw"
            
            bear <spce> token
            the space is critical 

            or just go to the authorization tab at the top in postmat on the route and paste in the token optain from the login response /api/login with succ login 

        Adding extension methods and cleanup program.cs 

            public static class IdentityServiceExtensions
            {
                public static IServiceCollection AddIdentityServices(this IServiceCollection services, IConfiguration config)
                {
                    // Middleware to tie into the [Authorize] Routes called to validate jwt issuance nonexpiry and user
                    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                        .AddJwtBearer(opts =>
                        {
                            opts.TokenValidationParameters = new TokenValidationParameters
                            {
                                ValidateIssuerSigningKey = true,
                                IssuerSigningKey = new SymmetricSecurityKey(Encoding
                                    .UTF8.GetBytes(config["TokenKey"])),
                                ValidateIssuer = false,
                                ValidateAudience = false
                            };
                        });
                    return services;
                }
            }

            use this in the program.cs with the new extensions 
            builder.Services.AddApplicationsServices(builder.Configuration);
            builder.Services.AddIdentityServices(builder.Configuration);

January 24 2024:
    Back at it after a 3 day hiatus ready to get the next section down

    Build an app with ASPNET Core and Angular from scratch Notes:
    
    Section 2 Client login and register:
    Angular CLient work

    Commands:
        Create an angular component:
            ng generate component nav 
            shorthand command:
            ng g c nave
                This will create a set of 4 files the html, css, ts and spec.ts test file 
                and will place in the current directory creating a folder name nav

        Angular dry run to see what generates:
            ng g c --skip-test --dry-run
                this will not produce and files just a preview of wat will be produced the no tests leavs out the spec file as well 

    Eror:
        angular doesnt work with node 21 
        source ~/.nvm/nvm.sh
        to enable nvm 
        nvm install 20 
        installs node 20 
        nvm use 20 
        switches to 20 node version 

        removed node_modules and package lock just to be reset to proper versioning

    Fixing bootstrap:
        npm install bootstrap
        npm install font-awesome 
            
            add this to style.css 
            @import '../node_modules/bootstrap/dist/css/bootstrap.min.css';
            @import '../node_modules/font-awesome/css/font-awesome.min.css';
    
    Moving the maoin page contet under nav bar:
        wrap the app component content in
        div class="container" style="margin-top: 50px;"> 

    Wire up the login form at the navbar:
        Import angular forms in app.module
        instgall angular forms 
        npm install @angular/forms --save 

        convert the form to and angular form

        create generic model form now in the nav component 
            model : any = {}
        establish login function 
            login(){}
        
        Set the bootstrap nave bar login as a form :
        <form #loginForm ="ngForm" class="d-flex">

        wire the submit buttin to the login fucntion and make ng submit
        add in (ngSubmit)="login()"  to the form 
        <form #loginForm ="ngForm" class="d-flex" (ngSubmit)="login()" autocomplete="off">

        Add the ngmoduel to the inputs to 2 way data bind 
        <input 
            name = "username"
            [(ngModel)]="model.username"
            class="form-control me-2" 
            type="search" 
            placeholder="username" 
            aria-label="Login Username">
        <input 
            name = "password"
            [(ngModel)]="model.password"
            class="form-control me-2" 
            type="search" 
            placeholder="password" 
            aria-label="Password">
        <button class="btn btn-outline-success" type="submit">Login</button>


    Creating Angular services to handle http requests:
        create folder app/_services

        ang cli generate service 
        ng g service or ng s 
        command:
            ng g s _services/account
            output: 
                CREATE src/app/_services/account.service.spec.ts (362 bytes)
                CREATE src/app/_services/account.service.ts (136 bytes)
        
        Benefits of services :
            they are retained for the lifetime of tha application 
            unlike component which are created and destro per session after use 
            good for storign state 
            services are singletons 

        init  account service.ts:
                @Injectable({
                providedIn: 'root'
            })
                export class AccountService {
                baseUrl = "https://localhot:L5001/api/"

                constructor(private http: HttpClient) { }

                login(model: any){
                    return this.http.post(this.baseUrl + 'account/login', model)
                }
            }

        Slap that service into the nave bar yo:
            constructor(private accoutService: AccountService){}

              login(){
                    this.accoutService.login(this.model).subscribe({
                    next: response => {
                        console.log(response);
                        this.loggedIn = true;
                    },
                    error: error => {
                        console.log(error)
                    }
                })
    Update ui upon login success:
        <ul class="navbar-nav me-auto mb-2 mb-lg-0" *ngIf="loggedIn">
        will show or hide nested members based upon logged in boolean value

        ngif add it and tie to loggedIn
        <form #loginForm ="ngForm" class="d-flex" (ngSubmit)="login()" autocomplete="off" *ngIf="!loggedIn">

        !!ngif comlete removes the element from the dom not just hide it
        [hidden]="loggedIn" would simply hide it 


    Getting the dropdowns to work:
        angular bootstrap 
            npm install ngx-bootstrap 

            ng add ngx-bootstrap  --component dropdowns

            the auto doesnt work in t ang 17 need to do it manualy 
            waht a pain its not that big a pain 

        Add the dropdwon directive to the form modules 
            <div class="dropdown" *ngIf="loggedIn" dropdwon>
                <a class="dropdown-toggle text-light" dropdownToggle>Welcome {{model.username}} </a>
                <div class="dropdown-menu" *dropdownMenu>
                    <a class="dropdown-item"> Edit Profile</a>
                    <a class="dropdown-item" (click)="logout()"> Logout </a>
                </div>
            </div>

    Error Dropdown does not want to show still after manual install

January 25 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
    
    Time to fix bootstrap js 
        was missing the right imports in the app.module 
            BrowserAnimationsModule,
            BsDropdownModule.forRoot(),
        getting a null error now which .. is progress
            nav.component.ts:20 ERROR NullInjectorError: R3InjectorError(_AppModule)[_BsDropdownDirective -> _BsDropdownDirective]:
            it would hel if i spelled dropdown correctly
        
        Dropdown html workin: 
        <div class="dropdown" *ngIf="loggedIn" class="dropdown" dropdown>
        <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{model.username}} </a>
        <div class="dropdown-menu" *dropdownMenu>
            <a class="dropdown-item"> Edit Profile</a>
            <a class="dropdown-item" (click)="logout()"> Logout </a>
        </div>
        </div>

        Onwards!
        its dropdown not dropdrown 

    Understanding Observables:
        Promises vs Observable 
            Promise: 
                Provides a single future value 
                not lazy will load everytime 
                can not cancel 
            Observables:
                Emits multiple values overtime can stream changes essentially
                lazy 
                able to cancel 
                can use with map filter reduce and other operators

        rxjs:
            reactive extensions for javascript 
            allows you to pipe the data from an observable and translate/transform it into a workable data format

        http subscription ->
            will return and error message if the http response is > 200-300 response range 
        
        you can make the http request a promise instead not recommended 

        Async pipe:
            example:
                <li *ngFor= 'let member of service.getMembers() | async'> {member.username}}</>
            this will auto subscribe and unsubscribe from the observable. 

    Storing user token data browser side:
        AccountService:
            if(user) localStorage.setItem('user', JSON.stringify(user));
        Creating a dtop model for user in the front end:
            create user.ts interface 
                export interface User {
                    username: string;
                    token: string;
                }
            you can now use the user object and have it mapped as the rssponse in the user service 
            you need to prime http to expect this type of respnse by declaring it as a wrapper 
                return this.http.post<User>(this.baseUrl + 'account/login', model).pipe(

    Create a user information storage observable
        to broadcast if a user is logged in. 
        Crete Observable in account service.ts:
        $ symbol in currentUser$ denotes a subscriber
            private currentUserSource = new BehaviorSubject<User | null>(null);
            currentUser$ = this.currentUserSource.asObservable();
            constructor(private http: HttpClient) { }

                note the <User | null> 
                    this allow you to set an object as 2 possible type (or more) allowing it to be decalred as a null initially without ts yelling

        Set the uyser observable at login :
            this.currentUserSource.next(user);

            setCurrentUser(user: User){
                this.currentUserSource.next(user);
            }

        inject the account service to the app.component to allow for the user and it logged in status to be globally accessable

        ! turns off typescript safety , but beware 
            ex: 
                const user: User = JSON.parse(localStorage.getItem('user')!)
            the more safe better way is:
                const userString = localStorage.getItem('user');
                if(!userString) return;
                const user: User = JSON.parse(userString);
                this.accountService.setCurrentUser(user);

        subscribe to the current user to keep up to date on whether the user is logged in or not:
            nav.component:
                getCurrentUser(){
                    this.accountService.currentUser$.subscribe({
                    next: user => this.loggedIn = !!user,
                    error: error => console.log(error)
                    })
                }
                ngOnInit(): void {
                    this.getCurrentUser();
                }
                
                !!user returns true if the user exists 

            now the user will persist accross browser refreshing and local storage in chrome shows the user and the token

        Unsubscribe to the account service:
            Subscribtions need to be canceled to avoid memory leaks 
                unless its an http request > those actually complete closing the sub 
            own observables need manages 

            convert loggedin boolean to currentUser$ observable 
            nav.component:
                currentUser$ : Observable<User | null> = of(null)
                    of(null) allow ang to init a variable that is an observable with a type of null to start with bypass the type checks 

            remove getCurrentUser with 
                ngOnInit(): void {
                    this.currentUser$ = this.accountService.currentUser$;
                }
            swap the islogged in flag on the html template with the observable instead
                *ngIf="loggedIn" -> *ngIf="currentUser$ | async"

                <div class="dropdown" *ngIf="currentUser$ | async" class="dropdown" dropdown>
                <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(currentUser$ | async)?.username}} </a>
            
            this is pointless you can just use the account service directly 

                in nav component change the accountService to public to allo for it to be access from the template
                constructor(private accountService: AccountService){}
                  to 
                constructor(public accountService: AccountService){}

                can be accessed like this now instead 
                    <div class="dropdown" *ngIf="accountService.currentUser$ | async" class="dropdown" dropdown>
                    <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(accountService.currentUser$ | async)?.username}} </a>

        Create home compoenent:
            ng g c home 
            CREATE src/app/home/home.component.css (0 bytes)
            CREATE src/app/home/home.component.html (19 bytes)
            CREATE src/app/home/home.component.spec.ts (587 bytes)
            CREATE src/app/home/home.component.ts (191 bytes)
            UPDATE src/app/app.module.ts (1019 bytes)

            create buttons to register and a toggle to show these buttons if the not logged in 

            homeComponent:
                registerMode = false;
                registerToggle(){
                    this.registerMode = !this.registerMode;
                }
            Apply the ngif toggle to buttons 
                <div class="container mt-5">
                <div *ngIf="!registerMode" style="text-align: center;">
                    <h1> Welcome yo Teboraw! The one place you need to track your thoughts</h1>
                    <p class="lead">Sign up and start journalling</p>
                    <div class="text-center">
                        <button (click)="registerToggle()" class="btn btn-primary btn-lg me-2"> Register</button>
                        <button class="btn btn-primary btn-info btn-lg">Learn More</button>
                    </div>
                </div>
                <div *ngIf="registerMode" class="container">
                    <div class="row justify-content-center">
                        <div class="col-4">
                            <p>Register FOrm GOes here</p>
                        </div>
                    </div>
                </div>
            </div>

            make sure to add the component to the main appcomponet.html page
            
        new error to hunt down:
            Solve ReferenceError: localStorage is not defined 
            the login box doesnt come back when user logs out 
            after my jog tomorrow this is the first thing I set to 

        