This document is intend to be a snapshot of what I am doing and learning each time I make progress towards Teboarw development with its primary focus being on the Dotnet API back bone of the application.

Currently I am progreessing through some tutorial videos and msft documentation in hopes to get a better ground of the ms dev environment and the best way to get an api in place that also handles authentication

Jan 18 2024:
    Began Udemy coursework going from scaatch and creating an angular/ c# web application 

    Build an app with ASPNET Core and Angular from scratch Notes:

        Dotnet CLI Commands:
            dotnet --info
                will show which sdks and runtimes are available to use and dev against and run dlls against
                    Example output: 
                        Runtime Environment:
                        OS Name:     Mac OS X
                        OS Version:  14.2
                        OS Platform: Darwin
                        RID:         osx-arm64
                        Base Path:   /usr/local/share/dotnet/sdk/8.0.100/

                        .NET workloads installed:
                        Workload version: 8.0.100-manifests.6c33ef20
                        There are no installed workloads to display.

                        Host:
                        Version:      8.0.0
                        Architecture: arm64
                        Commit:       5535e31a71

                        .NET SDKs installed:
                        6.0.414 [/usr/local/share/dotnet/sdk]
                        6.0.416 [/usr/local/share/dotnet/sdk]
                        6.0.417 [/usr/local/share/dotnet/sdk]
                        7.0.308 [/usr/local/share/dotnet/sdk]
                        7.0.310 [/usr/local/share/dotnet/sdk]
                        7.0.311 [/usr/local/share/dotnet/sdk]
                        8.0.100 [/usr/local/share/dotnet/sdk]

                        .NET runtimes installed:
                        Microsoft.AspNetCore.App 6.0.22 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 6.0.24 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.11 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.13 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.NETCore.App 6.0.22 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 6.0.24 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.11 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.13 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]

            dotnet -h 

            
                output all the available commands 
                outpu:
                    Execute a .NET SDK command.
                    sdk-options:
                    -d|--diagnostics  Enable diagnostic output.
                    -h|--help         Show command line help.
                    --info            Display .NET information.
                    --list-runtimes   Display the installed runtimes.
                    --list-sdks       Display the installed SDKs.
                    --version         Display .NET SDK version in use.

                    SDK commands:
                    add               Add a package or reference to a .NET project.
                    build             Build a .NET project.
                    build-server      Interact with servers started by a build.
                    clean             Clean build outputs of a .NET project.
                    format            Apply style preferences to a project or solution.
                    help              Show command line help.
                    list              List project references of a .NET project.
                    msbuild           Run Microsoft Build Engine (MSBuild) commands.
                    new               Create a new .NET project or file.
                    nuget             Provides additional NuGet commands.
                    pack              Create a NuGet package.
                    publish           Publish a .NET project for deployment.
                    remove            Remove a package or reference from a .NET project.
                    restore           Restore dependencies specified in a .NET project.
                    run               Build and run a .NET project output.
                    sdk               Manage .NET SDK installation.
                    sln               Modify Visual Studio solution files.
                    store             Store the specified assemblies in the runtime package store.
                    test              Run unit tests using the test runner specified in a .NET project.
                    tool              Install or manage tools that extend the .NET experience.
                    vstest            Run Microsoft Test Engine (VSTest) commands.
                    workload          Manage optional workloads.

                    Additional commands from bundled tools:
                    dev-certs         Create and manage development certificates.
                    fsi               Start F# Interactive / execute F# scripts.
                    user-jwts         Manage JSON Web Tokens in development.
                    user-secrets      Manage development user secrets.
                    watch             Start a file watcher that runs a command when files change.

            dotnet new -h 
                lists what you can do with the new command 
                output:
                    Usage:
                    dotnet new [<template-short-name> [<template-args>...]] [options]
                    dotnet new [command] [options]

                    Arguments:
                    <template-short-name>  A short name of the template to create.
                    <template-args>        Template specific options to use.

                    Options:
                    -o, --output <output>    Location to place the generated output.
                    -n, --name <name>        The name for the output being created. If no name is specified, the name of the output directory is used.
                    --dry-run                Displays a summary of what would happen if the given command line were run if it would result in a template creation.
                    --force                  Forces content to be generated even if it would change existing files.
                    --no-update-check        Disables checking for the template package updates when instantiating a template.
                    --project <project>      The project that should be used for context evaluation.
                    -v, --verbosity <LEVEL>  Sets the verbosity level. Allowed values are q[uiet], m[inimal], n[ormal], and diag[nostic]. [default: normal]
                    -d, --diagnostics        Enables diagnostic output.
                    -?, -h, --help           Show command line help.

                    Commands:
                    create <template-short-name> <template-args>  Instantiates a template with given short name. An alias of 'dotnet new <template name>'.
                    install <package>                             Installs a template package.
                    uninstall <package>                           Uninstalls a template package.
                    update                                        Checks the currently installed template packages for update, and install the updates.
                    search <template-name>                        Searches for the templates on NuGet.org.
                    list <template-name>                          Lists templates containing the specified template name. If no name is specified, lists all templates.
                    details <package-identifier>                  Provides the details for specified template package.
                                                                        The command checks if the package is installed locally, if it was not found, it searches the configured NuGet feeds.

            dotnet new list
                lists all the templates available to create projects 
                output:
                    Template Name                                 Short Name                  Language    Tags                            
                    --------------------------------------------  --------------------------  ----------  --------------------------------
                    API Controller                                apicontroller               [C#]        Web/ASP.NET                     
                    ASP.NET Core Empty                            web                         [C#],F#     Web/Empty                       
                    ASP.NET Core gRPC Service                     grpc                        [C#]        Web/gRPC/API/Service            
                    ASP.NET Core Web API                          webapi                      [C#],F#     Web/WebAPI/Web API/API/Service  
                    ASP.NET Core Web API (native AOT)             webapiaot                   [C#]        Web/Web API/API/Service         
                    ASP.NET Core Web App (Model-View-Controller)  mvc                         [C#],F#     Web/MVC                         
                    ASP.NET Core Web App (Razor Pages)            webapp,razor                [C#]        Web/MVC/Razor Pages             
                    ASP.NET Core with Angular                     angular                     [C#]        Web/MVC/SPA                     
                    ASP.NET Core with React.js                    react                       [C#]        Web/MVC/SPA                     
                    Blazor Server App                             blazorserver                [C#]        Web/Blazor                      
                    Blazor Server App Empty                       blazorserver-empty          [C#]        Web/Blazor/Empty                
                    Blazor Web App                                blazor                      [C#]        Web/Blazor/WebAssembly          
                    Blazor WebAssembly App Empty                  blazorwasm-empty            [C#]        Web/Blazor/WebAssembly/PWA/Empty
                    Blazor WebAssembly Standalone App             blazorwasm                  [C#]        Web/Blazor/WebAssembly/PWA      
                    Class Library                                 classlib                    [C#],F#,VB  Common/Library                  
                    Console App                                   console                     [C#],F#,VB  Common/Console                  
                    dotnet gitignore file                         gitignore,.gitignore                    Config                          
                    Dotnet local tool manifest file               tool-manifest                           Config                          
                    EditorConfig file                             editorconfig,.editorconfig              Config                          
                    global.json file                              globaljson,global.json                  Config                          
                    MSBuild Directory.Build.props file            buildprops                              MSBuild/props                   
                    MSBuild Directory.Build.targets file          buildtargets                            MSBuild/props                   
                    MSTest Playwright Test Project                mstest-playwright           [C#]        Test/MSTest/Playwright          
                    MSTest Test Project                           mstest                      [C#],F#,VB  Test/MSTest                     
                    MVC Controller                                mvccontroller               [C#]        Web/ASP.NET                     
                    MVC ViewImports                               viewimports                 [C#]        Web/ASP.NET                     
                    MVC ViewStart                                 viewstart                   [C#]        Web/ASP.NET                     
                    NuGet Config                                  nugetconfig,nuget.config                Config                          
                    NUnit 3 Test Item                             nunit-test                  [C#],F#,VB  Test/NUnit                      
                    NUnit 3 Test Project                          nunit                       [C#],F#,VB  Test/NUnit                      
                    NUnit Playwright Test Project                 nunit-playwright            [C#]        Test/NUnit/Playwright           
                    Protocol Buffer File                          proto                                   Web/gRPC                        
                    Razor Class Library                           razorclasslib               [C#]        Web/Razor/Library               
                    Razor Component                               razorcomponent              [C#]        Web/ASP.NET                     
                    Razor Page                                    page                        [C#]        Web/ASP.NET                     
                    Razor View                                    view                        [C#]        Web/ASP.NET                     
                    Solution File                                 sln,solution                            Solution                        
                    Web Config                                    webconfig                               Config                          
                    Worker Service                                worker                      [C#],F#     Common/Worker/Web               
                    xUnit Test Project                            xunit                       [C#],F#,VB  Test/xUnit   

            dotnet new sln
                created a new sln file with the director name if none specified

            dotnet new webapi -n TeborawAPI
                creates a new api project in the solution directory and pull in the default templated files courtesy of msfy 

            dotnet sln -h 
                list all commands available to use on the soution 

            dotnet sln add TeborawAPI 
                Adds the Templated Project to the solutions file 

            code .
                if no command found open vs code cmd shift + p and type shell in the search box and select the option to instal the code shell utility 
                will open the containing folder in vscode 

            code color highlight were not working:
                THe code them dark was at fault 
                cmd shift + p and changed them to dark + isntead voila 

            dotnet run:
                from the api proj directory if you run this command it will compile and run the template projcect
                output:
                    Building...
                    info: Microsoft.Hosting.Lifetime[14]
                        Now listening on: http://localhost:5224
                    info: Microsoft.Hosting.Lifetime[0]
                        Application started. Press Ctrl+C to shut down.
                    info: Microsoft.Hosting.Lifetime[0]
                        Hosting environment: Development
                    info: Microsoft.Hosting.Lifetime[0]
                        Content root path: /Users/rompasaurus/TeborawWebApp/TeborawAPI

            http://localhost:5224/swagger
                takes you to the swagger endpoint which should show all available api enpoints in dev mode of course

            port and url mappings:
                Held within the launchsettigns.json
                
                adjusted http launch settings to allow https and http specifying port 5000
                  "profiles": {
                    "http": {
                    "commandName": "Project",
                    "dotnetRunMessages": true,
                    "launchBrowser": true,
                    "launchUrl": "swagger",
                    "applicationUrl": "http://localhost:5000;https://localhost:5001",
                    "environmentVariables": {
                        "ASPNETCORE_ENVIRONMENT": "Development"
                    }
                },


            dotnet watch:
                runs your .net application with hot reloading checking for file updates and auto pushing if available
                will log those events as well 

Jan 19 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        https certificates:
            Are issue typically by default with the dotnet sdk if not trusted by browser run 
            dotnet dev-certs https --trust 
            clean than trust if not work 
            dotnet dev-certs https --clean 
            dotnet dev-certs https --trust 

        get debugs to be more verbose 
        appsettings.development.json > set Loglevel > default to onformational

        installed the entity framework and postgres entity drivers 
            had to install the nuget package manager and library 

        Double check the namespace when you make a new class or file ensure the namespace follows:
            projectname.folder 

        cmd + p > quickest way to open a file in vscode 

        created dbContext with the AppUser to start and DI'd via the program.cs

        builder.Services.AddDbContext<DataContext>(opts =>
        {
            opts.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"));
        });
        create DefaultConnection in appsettings.json 
              "ConnectionStrings": {
                    //Postgres docker db  
                    "DefaultConnection": "Server=localhost; Port=5432; Database=Teboraw; Username=Teboraw; Password =Bigmac12!;TrustServerCertificate=true"
                }
        Going to need to obfuscate these creds eventually 

        Create first migration -> dotnet ef cli tools need to be installed first 
            command:
                dotnet tool install --global dotnet-ef

                dotnet ef -h
                    help options for ef and commands available 

                dotnet ef migrations add InitialCreate -o Data/Migrations
                    creates the first migration pack and scripts 

                dotnet tool -list
                    shows all dn tools available including ef cli 

                dotnet ef database update 
                    applies all migrations existing and unapplied
                    applies the table and you should be able to view newly create column and db via connecor (datagrip)

                Creeated a users controller:
                    namespace TeborawAPI.Controllers;
                        [ApiController]
                        [Route("api/[controller]")] // /api/users
                        public class UsersController : ControllerBase
                        {
                            private readonly DataContext context;

                            public UsersController(DataContext context)
                            {
                                this.context = context;
                            }
                        }
            
        Routing error The routes dont get mapped without this ffs:
            added this to the startup.cs and all is well 
            app.MapControllerRoute(
                name: "default",
                pattern: "{controller}/{action=Index}/{id?}");

        Asynchronous api operations:
            public async Task 
            ex:     public async Task<ActionResult<AppUser>> GetUser(int id)
            allows the api server to pass this query to a delegate and handle other requests while sql retrieves
            make sure to await the return call to allow the function to be delegated 
                examle var users = await _context.Users.ToListAsync();

Jan 20 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        Starting with angulare install the node cli along with angular cli gonna go with angular 17 instead of 16 

        npm install -g @angular/cli

        ng version:
            will show you the install angualr version number along with node version as well
        
        Create angular application 
        ng new client 
            css styling select and 
            enable Server-Side Rendering (SSR) to allow for better web anayitics and google search availability
            this didnt have all the features i needed including routing and app module template had to use 
            ng new client --no-standalone --routing --ssr=true

        running angular template app 
            cd into template folder 
            command: 
                ng serve

            index.html is the starting page for the angular > which then cascades and loads the <app-root></app-root> which a component named app.compoennt.html/ts

        ctr + p allow quick open of a file 

        wire up angular to hit controller endpoint
            import the httpclienmodule in app.module 
              imports: [
                    BrowserModule,
                    AppRoutingModule,
                    HttpClientModule
                ],
        Slap that httpmodule into a component 
            via DI in the conststructor 
                constructor(private http: HttpClient){}
            extend componet class from OnInit to add a lifecycle step
            implement oninit method and try out a quick http get pull 
                this.http.get('https://localhost:5001/api/users').subscribe({
                    next: response => this.users = response,
                    error: error => console.log("Failed to pull user data error: ", error),
                    complete: () => console.log('User Request Completed! ')
                })
            make sure api is running > dotnet watch 
            gonna invariably get a cors cross site rejection error need to setup dotnet to allow specified origins to pull from api

        Addressing cors errors 
            is done on the api side add a header to the response that allow angular to trust data 
            program.cs 
                add the cors service 
                Code:
                    builder.Services.AddCors();
                
                create the middleware to inject the cors headers prior to sending back a response 
                add code just before the mapCOntroller call
                Code:
                    app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200"));

                request completes succ you can check the data passed back via 
                debug > network tab > click users form name list > preview tab to view data 
                [
                    {
                        "id": 2,
                        "userName": "Bob"
                    },
                    {
                        "id": 3,
                        "userName": "Tom"
                    },
                    {
                        "id": 4,
                        "userName": "Jane"
                    }
                ]

                quick angular tip just type the html tag name without the <> and you can add a class by adding .class name and then tab to auto create the html element 
                ie:
                    ul.ulClass name > turns into <ul class="ulClassNmae"></ul>

                add users to page and iterate over all users 
                    <li class="bold" *ngFor="let user of users">
                        {{user.id}} - {{user.userName}}
                    </li>
                    *ngFor is the key thing to not allows you iterate of a list of objects
                    FYI > .net api calls return json data with camelcasing by default 
                        userName insteaed of username 
                
        Add Bootstrap Styling 
            that has angular implementations
            ngx-bootstrap
            https://valor-software.com/ngx-bootstrap/#/
            cli command: 
                    ng add ngx-bootstrap
                received erro auto way went manual way instead 
                    npm install ngx-bootstrap --save
                imported the module manually
                added bootstrap.css 
                angular.json:
                    "styles": [
                        "src/styles.css",
                        "./node_modules/font-awesome/css/font-awesome.css",
                        "./node_modules/bootstrap/dist/css/bootstrap.min.css"
                        ],
                update app.module with:
                imported module via app.module 
                    mport { TooltipModule } from 'ngx-bootstrap/tooltip';
                    imports: [ TooltipModule.forRoot(), BrowserAnimationsModule]

                package.json should have entry for 
                    "ngx-bootstrap": "^12.0.0",
            install fontawesome 
                npm install fontawesome


        Error Port 4200 is already in use.:
            sudo kill -9 $(sudo lsof -t -i:4200) 
            to kill rogue angular app


Jan 21 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        Add ssl and certs to angular application:

    install mkcert:
        https://github.com/FiloSottile/mkcert
        brew install mkcert
        brew install nss # if you use Firefox   

    make ssl directory in the client folder
        mkdir ssl

    install the cert authority from the ssl directory 
        mkcert -install 

    Create the certificate for localhost for now domain later 
        mkcert localhost

        creates both a publich and private key for specified domain (localhost)

    Wire in cert to angular.json
        inside of "server":
        "serve": {
            "options": {
                "ssl": true,
                "sslCert": "./ssl/localhost.pem"
                "sslKey": "./ssl/localhost-key.pem"
            },
        restart angular app and site should auto redirect to https with a trusted cert 
        be aware this is a self signed certificate 

    fix cors to allow  
        ssl error:
            Access to XMLHttpRequest at 'https://localhost:5001/api/users' from origin 'https://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
       
        with the cert you will need to update the api to allow ssl connections 

        change: 
        app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200"));
        to ->
        app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("https://localhost:4200"));

    AUTHENTICATION BABY!!
        Learning Objectives 
            how to store pw's in db hint as a hash with a salt string to randomize the hash a bit 
            using inheritance 
            validation 
            json web tokens 
            c# services 

        add byte arrays props to the user class 
                public Byte PasswordHash { get; set; }
                public Byte PasswordSalt { get; set; }

        Create a migration to update the table entry
            Create migrations via command:
                dotnet ef migrations add UserPasswordAdded
            Update database 
                dotnet ef database update

        Create BaseAPiCOntroller to simplify and not repeat the route and api declarations 
            create the class then inherit from it ex:
                public class UsersController : BaseAPIController

        create an accounts controller to allow for user registration with a passwor dand setup hashing:
            public class AccountsController: BaseAPIController
            using var hmac = new HMACSHA3_512();
            ##Using keyword allows for the hmac object to be disposed of after use
            any classes that implement the idisposable method need a dispose() call to be initated
            using limits the scope of the variable to the function intantiate within and auto displose upon execution

        postman usage:
            you can set a url variable globally to use ion all you endpoint tests via:
                select main project in the collention and go to the variabl tab on the main page add a :
                    url variabl with intial value https://localhost:5001

                can inject into a endpoint test via formulating url as :
                    {{url}}/api/account/register

            parameters need to be passed via query string 
                Example
                Register(string username, string password)
                need to be request via 
                /api/register?username=examplname&password=expassword

        register error
            selected wrong sha crypto  full function for ref:
                [HttpPost("register")] // api/account/register
                public async Task<ActionResult<AppUser>> Register(string username, string password)
                {
                    using var hmac = new HMACSHA512();
                    var user = new AppUser()
                    {
                        UserName = username,
                        PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password)),
                        PasswordSalt = hmac.Key
                    };
                    _context.Users.Add(user);
                    await _context.SaveChangesAsync();
                    return user;
                }

        Adding dto's and validations 
            create dir dtos and add reigsterdto 
            public class RegisterDTO
            {
                public string Username { get; set; }
                public string Password { get; set; }
            }
            json sends in lower case for properties, dtop with upper case begins still bind as lowercase in json 
        
        Validate username and pw is not empty
            validation ad the db level
                add the [Required] decorator to the entitity data model 
                    [Required]
                    public string UserName {get; set;}
                you have to create a new migration to establish this change 
            
            At the dto level server side:
                add same required decorator to the sdt example:
                    public class RegisterDTO
                    {
                        [Required]
                        public string Username { get; set; }
                        [Required]
                        public string Password { get; set; }
                    }
                get a nice error whe passing in a blank user or pw 

                    "title": "One or more validation errors occurred.",
                    "status": 400,
                    "errors": {
                        "Password": [
                            "The Password field is required."
                        ],
                        "Username": [
                            "The Username field is required."
                        ]
                    },
                [ApiController]
                decorator enables this validation to occur on the Controllers
                without this decorator it wont do these checks and [fromBody] would need to be added to the controllers endpoint for it to map properly to a specified dto object
                this decorator automatically checks the model state that is establish when the endpoint is reached and dtop ios mapped 

        Setup login endpoint:  
            see code, validation for user and pass in place and hash compute and varification established here
                [HttpPost("login")]
                public async Task<ActionResult<AppUser>> Login(LoginDTO loginDTO)
                {
                    var user = await _context.Users.FirstOrDefaultAsync(u => u.UserName.ToLower() == loginDTO.Username.ToLower());
                    
                    if (user == null) return Unauthorized("Invalid Username");
                    //validate password by reversing the hash algo 
                    using var hmac = new HMACSHA512(user.PasswordSalt);
                    //pull the compute hash of user imput pw  
                    var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(loginDTO.Password));

                    for (int i = 0; i < computedHash.Length; i++)
                    {
                        if (computedHash[i] != user.PasswordHash[i]) return Unauthorized("Invalid password");
                    }
                    
                    return user;

                }

        JWT > JSON Web Tokens 
            Structure 3 parts
                Header contains algo and tokent type: 
                    {
                        "alg": "HS512",
                        "typ": "JWT"
                    }
                Payload Data
                    {
                        "nameid" : "lola"
                        "role" : "Member"
                        //time stamps for expiry dates of key and session nbf i the the time at wich token cannot be used before 
                        "nbf": 134653462,
                        "exp": 136345645,
                        "iat": 246357357,
                    }
                Verify Signature 
                    HMACSHA512(
                        base64UrlEncode(header) + "." +
                        base64UrlEncode(paylod),
                        your-256-secret
                    ) secret base64 encoded 

            Stages of auth 
                1 user logs in passing in username and password
                2 server receives login data and validates that password 
                3 server returns a token in respons if user is authenticate 
                4 client/user receives the jwt in response and stores locally passing the token back with each http subsequent http requests
                the request are sent with an additional authentication header portion
                5 the server then upon request uses the jwt header and validates with that key instead of the user needing to submit pw         information each time  

            JWT Beneftis:
                no session to manage jwts are self contained tokens 
                portable:  a single token can be used with multiplpe backends 
                no cookies required, mobile firendly as phone dont use cookies 
                performance once token established no need for more db calls to validate user auth 

            Token Service Creation:
                create the token interface 
                    public interface ITokenService
                    {
                        string CreateToken(AppUser user);
                    }
                Create the service that built using the interface 
                    public class TokenService: ITokenService
                    {
                        public string CreateToken(AppUser user)
                        {
                            throw new NotImplementedException();
                        }
                    }
                Imject the service to the program.cs 
                    builder.services.
                        AddTransient:
                            A very short lived service whose lifecycle is just for the duration of its call and use then it is dsipose 
                        AddScope: the standard 
                            A longer living service that lasts the duration of the https request meaning a specific controller call 
                        AddSingleton:
                            A service is instantiated once upon itself at the start of the api program launch and is never disposed ofbut only one instance exists typically better to dsipose after use to free memory especially with services are not need on a constant basis.
                            caching services typicall fall under this use case for quick data retrieval

                    Code: 
                    builder.Services.AddScoped<ITokenService, TokenService>();

                Build out service using config key:
                    creating a service as an interface will help later with testing 

                    Install System.IdentityModel.Tokens.Jwt by Microsoft
                        alolows you to establish a secret key for signing jwts tokens 

                    public class TokenService: ITokenService
                    {
                        private readonly SymmetricSecurityKey _key;
                        
                        public TokenService(IConfiguration config)
                        {
                            _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["TokenKey"]));
                        }
                        public string CreateToken(AppUser user)
                        {
                            // Add the users claimset, need to atleast have a username or id identifier further claims will be added later once funcitionailty requiring it is established
                            var claims = new List<Claim>()
                            {
                                new Claim(JwtRegisteredClaimNames.NameId, user.UserName),
                            };
                            //Establish the highest sha 512 ecryption key generation for token signature 
                            var credentials = new SigningCredentials(_key, SecurityAlgorithms.HmacSha512Signature);
                            //Set expiry and issuance dates along with claims
                            var tokenDescriptor = new SecurityTokenDescriptor()
                            {
                                Subject = new ClaimsIdentity(claims),
                                Expires = DateTime.Now.AddDays(7),
                                SigningCredentials = credentials
                            };

                            var tokenHandler = new JwtSecurityTokenHandler();
                            var token = tokenHandler.CreateToken(tokenDescriptor);
                            //using System.IdentityModel.Tokens.Jwt; takes provided token details and establishes a properly formatted jwt token 
                            return tokenHandler.WriteToken(token);
                        }
                    }

            Establish a dto for user and associated jwt
                public class UserDTO
                {
                    public string Username { get; set; }
                    public string Token { get; set; }

                }

            inject the Itoken service to the controller 
                private readonly ITokenService _tokenService;

                public AccountController(DataContext context, ITokenService tokenService)
                {
                    _context = context;
                    _tokenService = tokenService;
                }
            replace everywhen in the accountcontroller a user is return and return instead a userDTO with a generated token 
                return new UserDTO()
                {
                    Username = user.UserName,
                    Token = _tokenService.CreateToken(user)
                };
            Create you token key secret but just for development for now in appsettings.json.developmen
                {
                    "Logging": {
                        "LogLevel": {
                        "Default": "Information",
                        "Microsoft.AspNetCore": "Information"
                        }
                    },
                    "TokenKey": "dontevenbothertryingtoguessthiscuzyoucantitssosecretandifyoutellanyoneillkillyou"
                }
            rebuild code and  login endpoint upon successful login should return username and the token 
            example response :
                {
                    "username": "dildo",
                    "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJkaWxkbyIsIm5iZiI6MTcwNTg2MzY3N
                }iwiZXhwIjoxNzA2NDY4NDc2LCJpYXQiOjE3MDU4NjM2NzZ9.YJJKK9j0QOzuXW421ejToDOOKsqzH2Qr2I49odh0vTOUUeHBRBLWRl2wNkJ9THElLRjbmQs_hMnbkWZCWKl5mQ"

            
        How to peak inside a token block:
            jwt.ms > go to this site 
            heres example output
                paste the token here 
                {
                    "alg": "HS512",
                    "typ": "JWT"
                }.{
                    "nameid": "dildo",
                    "nbf": 1705863676,
                    "exp": 1706468476,
                    "iat": 1705863676
                }.[Signature]

        Authorize the routes:
            add the decorator to the routes in the controller 
            [Authorize] either on the route or on the controller as a whole

            need to then plug in the middleware that routes the authorize right to execute the routes
            
        Setup Authorize middleware for jwt bearer tokens 
            install nuget package Microsoft.AspNetCore.Authentication.JwtBearer by Microsoft 8.00
            Program.cs
            //The location of these need to be after cors establishment but prior to route and controller mapping 
            // Are you who you say you are 
            app.UseAuthentication();
            // What are you allowed to do
            app.UseAuthorization();
            also 
                app.UseHttpsRedirection();
                app.UseStaticFiles();
                app.UseRouting();
                needs to be setup prior to auth establishment in progrma.cs

        Test the route:
            Get the token from the login route 
            then use that toke value to add to get request to the users list route in postman 

            add key: Authorization
                value: Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJkaWxkbyIsIm5iZiI6MTcwNTg2NjMyNSwiZXhwIjoxNzA2NDcxMTI1LCJpYXQiOjE3MDU4NjYzMjV9.JQV2KIRmL7DL1JL9565ankWKKBMfHU31dWiAyp8tbo6_861tPDAAdr6SftrEN-a9dtsUqcRxbEUdy1-rNxKeGw"
            
            bear <spce> token
            the space is critical 

            or just go to the authorization tab at the top in postmat on the route and paste in the token optain from the login response /api/login with succ login 

        Adding extension methods and cleanup program.cs 

            public static class IdentityServiceExtensions
            {
                public static IServiceCollection AddIdentityServices(this IServiceCollection services, IConfiguration config)
                {
                    // Middleware to tie into the [Authorize] Routes called to validate jwt issuance nonexpiry and user
                    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                        .AddJwtBearer(opts =>
                        {
                            opts.TokenValidationParameters = new TokenValidationParameters
                            {
                                ValidateIssuerSigningKey = true,
                                IssuerSigningKey = new SymmetricSecurityKey(Encoding
                                    .UTF8.GetBytes(config["TokenKey"])),
                                ValidateIssuer = false,
                                ValidateAudience = false
                            };
                        });
                    return services;
                }
            }

            use this in the program.cs with the new extensions 
            builder.Services.AddApplicationsServices(builder.Configuration);
            builder.Services.AddIdentityServices(builder.Configuration);

January 24 2024:
    Back at it after a 3 day hiatus ready to get the next section down

    Build an app with ASPNET Core and Angular from scratch Notes:
    
    Section 2 Client login and register:
    Angular CLient work

    Commands:
        Create an angular component:
            ng generate component nav 
            shorthand command:
            ng g c nave
                This will create a set of 4 files the html, css, ts and spec.ts test file 
                and will place in the current directory creating a folder name nav

        Angular dry run to see what generates:
            ng g c --skip-test --dry-run
                this will not produce and files just a preview of wat will be produced the no tests leavs out the spec file as well 

    Eror:
        angular doesnt work with node 21 
        source ~/.nvm/nvm.sh
        to enable nvm 
        nvm install 20 
        installs node 20 
        nvm use 20 
        switches to 20 node version 

        removed node_modules and package lock just to be reset to proper versioning

    Fixing bootstrap:
        npm install bootstrap
        npm install font-awesome 
            
            add this to style.css 
            @import '../node_modules/bootstrap/dist/css/bootstrap.min.css';
            @import '../node_modules/font-awesome/css/font-awesome.min.css';
    
    Moving the maoin page contet under nav bar:
        wrap the app component content in
        div class="container" style="margin-top: 50px;"> 

    Wire up the login form at the navbar:
        Import angular forms in app.module
        instgall angular forms 
        npm install @angular/forms --save 

        convert the form to and angular form

        create generic model form now in the nav component 
            model : any = {}
        establish login function 
            login(){}
        
        Set the bootstrap nave bar login as a form :
        <form #loginForm ="ngForm" class="d-flex">

        wire the submit buttin to the login fucntion and make ng submit
        add in (ngSubmit)="login()"  to the form 
        <form #loginForm ="ngForm" class="d-flex" (ngSubmit)="login()" autocomplete="off">

        Add the ngmoduel to the inputs to 2 way data bind 
        <input 
            name = "username"
            [(ngModel)]="model.username"
            class="form-control me-2" 
            type="search" 
            placeholder="username" 
            aria-label="Login Username">
        <input 
            name = "password"
            [(ngModel)]="model.password"
            class="form-control me-2" 
            type="search" 
            placeholder="password" 
            aria-label="Password">
        <button class="btn btn-outline-success" type="submit">Login</button>


    Creating Angular services to handle http requests:
        create folder app/_services

        ang cli generate service 
        ng g service or ng s 
        command:
            ng g s _services/account
            output: 
                CREATE src/app/_services/account.service.spec.ts (362 bytes)
                CREATE src/app/_services/account.service.ts (136 bytes)
        
        Benefits of services :
            they are retained for the lifetime of tha application 
            unlike component which are created and destro per session after use 
            good for storign state 
            services are singletons 

        init  account service.ts:
                @Injectable({
                providedIn: 'root'
            })
                export class AccountService {
                baseUrl = "https://localhot:L5001/api/"

                constructor(private http: HttpClient) { }

                login(model: any){
                    return this.http.post(this.baseUrl + 'account/login', model)
                }
            }

        Slap that service into the nave bar yo:
            constructor(private accoutService: AccountService){}

              login(){
                    this.accoutService.login(this.model).subscribe({
                    next: response => {
                        console.log(response);
                        this.loggedIn = true;
                    },
                    error: error => {
                        console.log(error)
                    }
                })
    Update ui upon login success:
        <ul class="navbar-nav me-auto mb-2 mb-lg-0" *ngIf="loggedIn">
        will show or hide nested members based upon logged in boolean value

        ngif add it and tie to loggedIn
        <form #loginForm ="ngForm" class="d-flex" (ngSubmit)="login()" autocomplete="off" *ngIf="!loggedIn">

        !!ngif comlete removes the element from the dom not just hide it
        [hidden]="loggedIn" would simply hide it 


    Getting the dropdowns to work:
        angular bootstrap 
            npm install ngx-bootstrap 

            ng add ngx-bootstrap  --component dropdowns

            the auto doesnt work in t ang 17 need to do it manualy 
            waht a pain its not that big a pain 

        Add the dropdwon directive to the form modules 
            <div class="dropdown" *ngIf="loggedIn" dropdwon>
                <a class="dropdown-toggle text-light" dropdownToggle>Welcome {{model.username}} </a>
                <div class="dropdown-menu" *dropdownMenu>
                    <a class="dropdown-item"> Edit Profile</a>
                    <a class="dropdown-item" (click)="logout()"> Logout </a>
                </div>
            </div>

    Error Dropdown does not want to show still after manual install

January 25 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
    
    Time to fix bootstrap js 
        was missing the right imports in the app.module 
            BrowserAnimationsModule,
            BsDropdownModule.forRoot(),
        getting a null error now which .. is progress
            nav.component.ts:20 ERROR NullInjectorError: R3InjectorError(_AppModule)[_BsDropdownDirective -> _BsDropdownDirective]:
            it would hel if i spelled dropdown correctly
        
        Dropdown html workin: 
        <div class="dropdown" *ngIf="loggedIn" class="dropdown" dropdown>
        <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{model.username}} </a>
        <div class="dropdown-menu" *dropdownMenu>
            <a class="dropdown-item"> Edit Profile</a>
            <a class="dropdown-item" (click)="logout()"> Logout </a>
        </div>
        </div>

        Onwards!
        its dropdown not dropdrown 

    Understanding Observables:
        Promises vs Observable 
            Promise: 
                Provides a single future value 
                not lazy will load everytime 
                can not cancel 
            Observables:
                Emits multiple values overtime can stream changes essentially
                lazy 
                able to cancel 
                can use with map filter reduce and other operators

        rxjs:
            reactive extensions for javascript 
            allows you to pipe the data from an observable and translate/transform it into a workable data format

        http subscription ->
            will return and error message if the http response is > 200-300 response range 
        
        you can make the http request a promise instead not recommended 

        Async pipe:
            example:
                <li *ngFor= 'let member of service.getMembers() | async'> {member.username}}</>
            this will auto subscribe and unsubscribe from the observable. 

    Storing user token data browser side:
        AccountService:
            if(user) localStorage.setItem('user', JSON.stringify(user));
        Creating a dtop model for user in the front end:
            create user.ts interface 
                export interface User {
                    username: string;
                    token: string;
                }
            you can now use the user object and have it mapped as the rssponse in the user service 
            you need to prime http to expect this type of respnse by declaring it as a wrapper 
                return this.http.post<User>(this.baseUrl + 'account/login', model).pipe(

    Create a user information storage observable
        to broadcast if a user is logged in. 
        Crete Observable in account service.ts:
        $ symbol in currentUser$ denotes a subscriber
            private currentUserSource = new BehaviorSubject<User | null>(null);
            currentUser$ = this.currentUserSource.asObservable();
            constructor(private http: HttpClient) { }

                note the <User | null> 
                    this allow you to set an object as 2 possible type (or more) allowing it to be decalred as a null initially without ts yelling

        Set the uyser observable at login :
            this.currentUserSource.next(user);

            setCurrentUser(user: User){
                this.currentUserSource.next(user);
            }

        inject the account service to the app.component to allow for the user and it logged in status to be globally accessable

        ! turns off typescript safety , but beware 
            ex: 
                const user: User = JSON.parse(localStorage.getItem('user')!)
            the more safe better way is:
                const userString = localStorage.getItem('user');
                if(!userString) return;
                const user: User = JSON.parse(userString);
                this.accountService.setCurrentUser(user);

        subscribe to the current user to keep up to date on whether the user is logged in or not:
            nav.component:
                getCurrentUser(){
                    this.accountService.currentUser$.subscribe({
                    next: user => this.loggedIn = !!user,
                    error: error => console.log(error)
                    })
                }
                ngOnInit(): void {
                    this.getCurrentUser();
                }
                
                !!user returns true if the user exists 

            now the user will persist accross browser refreshing and local storage in chrome shows the user and the token

        Unsubscribe to the account service:
            Subscribtions need to be canceled to avoid memory leaks 
                unless its an http request > those actually complete closing the sub 
            own observables need manages 

            convert loggedin boolean to currentUser$ observable 
            nav.component:
                currentUser$ : Observable<User | null> = of(null)
                    of(null) allow ang to init a variable that is an observable with a type of null to start with bypass the type checks 

            remove getCurrentUser with 
                ngOnInit(): void {
                    this.currentUser$ = this.accountService.currentUser$;
                }
            swap the islogged in flag on the html template with the observable instead
                *ngIf="loggedIn" -> *ngIf="currentUser$ | async"

                <div class="dropdown" *ngIf="currentUser$ | async" class="dropdown" dropdown>
                <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(currentUser$ | async)?.username}} </a>
            
            this is pointless you can just use the account service directly 

                in nav component change the accountService to public to allo for it to be access from the template
                constructor(private accountService: AccountService){}
                  to 
                constructor(public accountService: AccountService){}

                can be accessed like this now instead 
                    <div class="dropdown" *ngIf="accountService.currentUser$ | async" class="dropdown" dropdown>
                    <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(accountService.currentUser$ | async)?.username}} </a>

        Create home compoenent:
            ng g c home 
            CREATE src/app/home/home.component.css (0 bytes)
            CREATE src/app/home/home.component.html (19 bytes)
            CREATE src/app/home/home.component.spec.ts (587 bytes)
            CREATE src/app/home/home.component.ts (191 bytes)
            UPDATE src/app/app.module.ts (1019 bytes)

            create buttons to register and a toggle to show these buttons if the not logged in 

            homeComponent:
                registerMode = false;
                registerToggle(){
                    this.registerMode = !this.registerMode;
                }
            Apply the ngif toggle to buttons 
                <div class="container mt-5">
                <div *ngIf="!registerMode" style="text-align: center;">
                    <h1> Welcome yo Teboraw! The one place you need to track your thoughts</h1>
                    <p class="lead">Sign up and start journalling</p>
                    <div class="text-center">
                        <button (click)="registerToggle()" class="btn btn-primary btn-lg me-2"> Register</button>
                        <button class="btn btn-primary btn-info btn-lg">Learn More</button>
                    </div>
                </div>
                <div *ngIf="registerMode" class="container">
                    <div class="row justify-content-center">
                        <div class="col-4">
                            <p>Register FOrm GOes here</p>
                        </div>
                    </div>
                </div>
            </div>

            make sure to add the component to the main appcomponet.html page

        new error to hunt down:
            Solve ReferenceError: localStorage is not defined 
            the login box doesnt come back when user logs out 
            after my jog tomorrow this is the first thing I set to 

January 26, 2024
    Trying to address the localstorage error in the appcomponent page:
        seems ang doesnt believe the local sotrage is available,
        attempted putting the call behind a try catch block and same issue appears to occur, 
        Attemp to print the log in the console:
            and this seems to narrow things down as the conseole being print to is the ng anagular one and not in fact the web browser itself,
            it seems this localstrorage call is being called server side and not client side so I need to figure out why exactly that is 
        i believe it was dues to the fact that i set up server side rendering 
            "ssr": false,
            best to let the client handle the rendering

        that was the issue golly I amaze myself sometimes 
        Changed angular.json:
        from:
            "prerender": true,
                "ssr": {
                "entry": "server.ts"
                } 
        to:
            "prerender": false,
            "ssr": false
        badabing bada boom 

    Still having issues with the login prompt not howing back up upon logout...
        needed to add 
        this.currentUserSource.next(null);
        to the logout method of account.service.ts

    Build an app with ASPNET Core and Angular from scratch Notes:

    Creating register component:
        ng g c register
        <form #registerForm="ngForm" (ngSubmit)="register()" autocomplete="off">
            <h2 class="text-center text-primary">Sign Up</h2>
            <hr>
            <div class="mb-3">
                <input type="text"
                    class="form-control"
                    name="username"
                    [(ngModel)]="model.username"
                    placeholder="Username">
            </div>
            <div class="text-center">
                <input type="password" 
                    class="form-control"
                    name="password"
                    [(ngModel)]="model.password"
                    placeholder="Password">
            </div>
            <hr>
            <div class="text-center">
                <button class="btn btn-success me-2" type="submit">Register</button>
                <button class="btn btn-default" type="button" (click)="cancel()">Cancel</button>
            </div>
        </form>

    Parent to child data sharing: home (parent) to register(child)
        sending data to the register component from the parent home comopnent:
        cut getUsers from appcomponent to home 
            inject the httpClient 
            add a global users
            this.getUsers in ngOnit to pull the users
        goal pass user list from home compoent to register component

        the input property:
            add to registerComponent: 
            @Input() usersFromHomeComponent: any;

            pass in the usersFromHomeComponent to the app-register html element est in home.component
            <app-register [usersFromHomeComponent]="users"></app-register>

            the register component should now be able to access the data assuming the component initialized 

            test the parent data registerComponent:
                remember angular types are case sensitive
                <div class="mb-3">
                    <label> Who is your favorite user</label>
                    <select name="favorit" id="fav" class="form-select">
                        <option *ngFor="let user of usersFromHomeComponent" [value] ="user.userName"> 
                            {{user.username}}
                        </option>
                    </select>
                </div>

    Child to Parent Communication:
        in registerComponent:
            @Output() cancelRegister = new EventEmitter();
            
            cancel(){
                this.cancelRegister.emit(false);
            }
        in homeComponent.html:
            <app-register [usersFromHomeComponent]="users" (cancelRegister)="cancelRegisterMode($event)"></app-register>
        in homeComponent.ts declare cancelRegisterMode():
            cancelRegisterMode(event:boolean){
                this.registerMode = event;
            }

    Wire up registration with api:
        account.service add register endpoint:
          register(model:any){
                return this.http.post<User>(this.baseUrl + 'account/register', model).pipe(
                map(user => {
                    if(user){
                    localStorage.setItem('user', JSON.stringify(user));
                    this.currentUserSource.next(user);
                    }
                })
                )
            }
        wire up the service in the registerComponent:
        inject the account service:
              constructor(private accountService: AccountService){}
        create register fn:
            register() {
                this.accountService.register(this.model).subscribe({
                next: response => {
                    console.log(response);
                    this.cancel();
                },
                error: error => console.log(error)
                })
            }
        the response is undefine due to the mapping occuring in the service 
        the response need to be return in the mapping fucntion 
            map(user => {
                if(user){
                localStorage.setItem('user', JSON.stringify(user));
                this.currentUserSource.next(user);
                }
                return user;
            })
    
    implementing routing:
        generate a few components:
            ng g c member/member-list

            ng g c member/member-detail

            ng g c lists

            ng g c messages

        modify app.routing create the routes for the new compoenents
            !!order matters the ** at the end will catch any routes that dont fit the bill and reroute to the home component
            const routes: Routes = [
                {path: '', component: HomeComponent},
                {path: 'members', component: MemberListComponent},
                {path: 'members/:id', component: MemberDetailComponent},
                {path: 'lists', component: ListsComponent},
                {path: 'messages', component: MessagesComponent},
                {path: '**', component: HomeComponent, pathMatch: 'full'},
            ];

            pathMatch: 'full'}, ensur this for last route to prevent circular link rerouting 

        apply the router link to the navbar links using routerLink
            example:
            <li class="nav-item">
                <a class="nav-link" routerLink="/members">Members</a>
            </li>

        make nav link active upon click and router loaded: 
            add routerLinkActive = "active"
            example:
                <a class="nav-link" routerLink="/lists" routerLinkActive = "active">Lists</a>
        
        Route upon login:
            navcomponent:
                inject the router 
                private router: Router
            route at login fn:
              login(){
                this.accountService.login(this.model).subscribe({
                next: response => {
                    this.router.navigateByUrl('/members')
                    console.log(response);
                },
                error: error => {
                    console.log(error)
                }
                })
            }
            the / in the route is critical it ids the route as a root route thats relative, will not cchain to the existing route 

    Apply toast notifications on errors:
        install ngx-toastr:
            npm install ngx-toastr --save 
            npm install @angular/animations --save

        add the toast to the css import in angular.json 
            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "node_modules/ngx-toastr/toastr.css",
              "src/styles.css"
            ],
        
        import style into the css :
            @import "../node_modules/ngx-bootstrap/datepicker/bs-datepicker.css";
            @import "../node_modules/ngx-toastr/toastr.css";

        add the toastr module to app.module:
            ToastrModule.forRoot(),

        implement in the navcomponent and register :
            inject toastr : private toast: ToastrService
            add  toast to the error response 
                this.accountService.login(this.model).subscribe({
                    next: _ => this.router.navigateByUrl('/members'),
                    error: error => this.toastr.error(error.error)
                })

        adjust toast positioning in _AppModule:
            ToastrModule.forRoot({
                positionClass: 'toast-bottom-right'
            }),

        address issue where toas display object object when register attempt with blank user and password
            cause  there are multiple errors so c# returns a list of error that needs to be mapped instead 
            this will be addressed later

    Route Gaurds for authorization:
        remember client side security is not really security that needs done on the api side.
        ang cli command to add gaurd 
        ng g gaurd or ng g g 
        example:
            ng g g _gaurds/auth
            select canActivate

        This create skeleton ts file with 
            import { CanActivateFn } from '@angular/router';
                export const authGuard: CanActivateFn = (route, state) => {
                return true;
            };

        Here you can specify the routes that need an account service check to allow the route to load and specify a toastr message is auth is not permitted 

        inject the toastr and accountServices:  
            const accountService = inject(AccountService);
            const toastr = inject(ToastrService);
        entirety of the gaurd:
        basically a boolean generator mapped to the user service to determin if ther is a current user 
        export const authGuard: CanActivateFn = (route, state) => {
            const accountService = inject(AccountService);
            const toastr = inject(ToastrService);
            return accountService.currentUser$.pipe(
                map(user => {
                if(user) return true;
                else{
                    toastr.error('You shall not pass!')
                    return false;
                }
                })
            )
        };

    Attach the route gaurd to the routes in the app.routes:
        {path: 'members', component: MemberListComponent, canActivate: [authGuard]},

        canActivate: [authGuard] specifies the auth gaurd to validate with can be multiple, and prevents rotuing if false

    Creating a dummy route with child routes:
        all paths that need the same gaurd can be declared under the same parent saving some boiler plate example:
        {path: '',
            runGuardsAndResolvers: 'always',
            canActivate: [authGuard],
            children: [
            {path: 'members', component: MemberListComponent, canActivate: [authGuard]},
            {path: 'members/:id', component: MemberDetailComponent},
            {path: 'lists', component: ListsComponent},
            {path: 'messages', component: MessagesComponent},
            ]
        },

    Hide the links to not temp the user:
        <ng-container *ngIf="accountService.currentUser$ | async">
            is an invisibale element that allow nested elements within it to be display or hiddened base on the ngIf Directive
            wont show in the dom at all 

    Adding a new theme:
        Bootswatch is a good free styling resource

        npm install bootswatch --save
         angular.json add style
         "bootswatch/dist/cyborg/bootstrap.min.css"
        add style.css 
        @import 'bootswatch/dist/cyborg/bootstrap.min.css';

    Make the interpolated value upper case
        Welcome {{user.username | titlecase}}
    Clean up the welcome bar when user is logged in:
        the as user modifier allows you to cast the accountservice and access its members 
        changed from:
            <div class="dropdown" *ngIf="accountService.currentUser$ | async" class="dropdown" dropdown>
            <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(accountService.currentUser$ | async)?.username}} </a>
            
        to:
            <div class="dropdown" *ngIf="accountService.currentUser$ | async as user"  class="dropdown" dropdown>
            <a class="dropdown-toggle text-decoration-none" dropdownToggle>Welcome {{user.username | titlecase}} </a>

    Creating a shared module to slim down the appModule.ts:
        use a share module for any 3rd party modules 

        ng cli:
            ng g --help
            look for module

            ng g m _modules/shared --dry-run 
                double check the dir creation 
                this makes a shared directory if you dont want a sep folder declare it as flat:

            ng g m _modules/shared  --flat
        
        Slap all the 3rd party modules into it with appropraite imnports:
            @NgModule({
                declarations: [],
                imports: [
                    CommonModule,
                    TooltipModule.forRoot(),
                    BsDropdownModule.forRoot(),
                    ToastrModule.forRoot({
                    positionClass: 'toast-bottom-right'
                    }),
                ]
                })
                export class SharedModule { }

        import the shared module into the app.module:
            add     SharedModule, to the imports list

        denote the sharedModule as exportable:
        add export arrays:
            exports:[
                TooltipModule,
                BsDropdownModule,
                ToastrModule
            ]

January 27, 2024
    Api middleware, interceptors , exception troubleshooting 
    centralize error handling to reduce code repetition 

    Create a buggycontroller to handle http errors:
        BuggyController.cs in the api:

        simply generate enpoints that will produce errors 
        public class BuggyController : BaseAPIController
            {
                private readonly DataContext _context;

                public BuggyController(DataContext context)
                {
                    _context = context;
                }

                [Authorize]
                [HttpGet("auth")]
                public ActionResult<string> GetSecret()
                {
                    return "secret text";
                }
                
                [HttpGet("not-found")]
                public ActionResult<AppUser> GetNotFound()
                {
                    var thing = _context.Users.Find(-1);
                    if(thing == null) return NotFound();
                    return thing;
                }
                
                [HttpGet("server-error")]
                public ActionResult<string> GetServerError()
                {
                    var thing = _context.Users.Find(-1);
                    var thingToReturn = thing.ToString();
                    return thingToReturn;
                }
                
                [HttpGet("bad-request")]
                public ActionResult<string> GetBadRequest()
                {
                    return BadRequest("This was a bad request");
                }

    Time to intercept the errors and produce a more readable response:
        in development mode which is set via the launchsetting.JSON
        .net api aut catches stack trace errors and passes them into the api requests 
        however in production this does not occur

        you slap your excecution block behind a try catch to handle the exceptions directly
        like so 
            [HttpGet("server-error")]
            public ActionResult<string> GetServerError()
            {
                try
                {
                    var thing = _context.Users.Find(-1);
                    var thingToReturn = thing.ToString();
                    return thingToReturn;
                }
                catch (Exception ex)
                {
                    return StatusCode(500, "Computer says no!");
                }

            }
        this bypass the dev exception stack trace req return and instead handles the error directly with a single response of computer say no

        it will be tedious to put every potention exec bloc behind a try catch when a null is possible instead you can intercept the error via: 
    exception handling middleware:
        Create error director in Api project
        Create APIException Class:
            data model for exceptions that will occurs simmpe with code details and message
            public class APIException
            {
                public APIException(int statusCode, string message, string details)
                {
                    StatusCode = statusCode;
                    Message = message;
                    Details = details;
                }

                public int StatusCode { get; set; }
                public string Message { get; set; }
                public string Details { get; set; }
                
            }

    Create a middleware directory with ExcemptionMiddleware.cs:
        this will end in the middle of an http request executing the http contexts invocation and catching if, exceptions occurs and translate the message into a error response with either the stack trace if in dev mode ot internal server error otherwise, along with the exceptions error message.

        public class ExceptionMiddleware
        {
            private RequestDelegate _next;
            private ILogger<ExceptionMiddleware> _logger;
            private IHostEnvironment _env;

            public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger, IHostEnvironment env)
            {
                _env = env;
                _logger = logger;
                _next = next;
            }

            public async Task InvokeAsync(HttpContext context)
            {
                try
                {
                    await _next(context);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, ex.Message);
                    context.Response.ContentType = "application/json";
                    context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;

                    var response = _env.IsDevelopment()
                        ? new APIException(context.Response.StatusCode, ex.Message, ex.StackTrace?.ToString())
                        : new APIException(context.Response.StatusCode, ex.Message, "Internal Server Error");

                    var options = new JsonSerializerOptions
                    {
                        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                    };

                    var json = JsonSerializer.Serialize(response, options);
                    await context.Response.WriteAsync(json);
                }
            }

            this middleware then needs embedded into the startup routine in order for the http context invokes to be passed through it before the http request pipeline:
            program.cs:
                app.UseMiddleware<ExceptionMiddleware>();
                // Configure the HTTP request pipeline.
                if (app.Environment.IsDevelopment())

            Postman now recieves error responses in json form with message and stack trace forh http exceptions:
                {"statusCode":500,"message":"Object reference not set to an instance of an object.","details":"   at TeborawAPI.Controllers.BuggyController.GetServerError() in /Users/rompasaurus/TeborawWebApp/TeborawAPI/Controllers/BuggyController.cs:line 36\n   at lambda_method3(Closure, Object, Object[])\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.SyncObjectResultExecutor.Execute(ActionContext actionContext, IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeActionMethodAsync()\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeNextActionFilterAsync()\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeInnerFilterAsync()\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeFilterPipelineAsync>g__Awaited|20_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Logged|17_1(ResourceInvoker invoker)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Logged|17_1(ResourceInvoker invoker)\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|7_0(Endpoint endpoint, Task requestTask, ILogger logger)\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at TeborawAPI.Middleware.ExceptionMiddleware.InvokeAsync(HttpContext context) in /Users/rompasaurus/TeborawWebApp/TeborawAPI/Middleware/ExceptionMiddleware.cs:line 24"}

    Create an angular component to handle api error responses:
        just a test page to ensure errors return to the console:
            create new component:
            ng g c error/test-error

            import { HttpClient } from '@angular/common/http';
            import {Component, OnInit} from '@angular/core';
            @Component({
            selector: 'app-test-error',
            templateUrl: './test-error.component.html',
            styleUrl: './test-error.component.css'
            })
            export class TestErrorComponent implements OnInit{
            baseUrl = "https://localhost:5001/api/";

            constructor(private http: HttpClient){

            }

            ngOnInit() {
            }

            get404Error() {
                this.http.get(this.baseUrl + 'buggy/not-Found').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get400Error() {
                this.http.get(this.baseUrl + 'buggy/bad-request').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get500Error() {
                this.http.get(this.baseUrl + 'buggy/server-error').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get401Error() {
                this.http.get(this.baseUrl + 'buggy/auth').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get400Error() {
                this.http.post(this.baseUrl + 'account/register').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }
            }
        html:
            <ng-container>
                <button class="btn btn-outline-primary me-3" (click)="get500Error()"> Test 500 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get400Error()"> Test 400 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get401Error()"> Test 401 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get404Error()"> Test 404 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get400ValidationError()"> Test 400 Validation Error </button>
            </ng-container>

        Route to this component 
              {path: 'errors', component: TestErrorComponent},


    Intercepting http Errors from angular:
        find requests that are error and display toast message 
        ng g --help 
        find interceptor options 

        cli:
            ng g interceptor _interceptors/error 

        this create a error.interceptor.ts in  its on interceptor folder:
        import {Injectable} from "@angular/core";
        import {HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest} from "@angular/common/http";
        import {NavigationExtras, Router} from "@angular/router";
        import {catchError, Observable} from "rxjs";
        import {ToastrService} from "ngx-toastr";
        @Injectable()
        export class ErrorInterceptor implements HttpInterceptor{
        constructor(private router: Router, private toastr: ToastrService) {
        }

        intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
            return next.handle(req).pipe(
            catchError((error:HttpErrorResponse)=> {
                if (error) {
                switch (error.status) {
                    case 400:
                    // multipl errors could be passed back this will check if a object was passed that needs iterated through
                    if (error.error.errors) {
                        const modelStateErrors = [];
                        for (const key in error.error.errors) {
                        if (error.error.errors[key]) {
                            modelStateErrors.push(error.error.errors[key])
                        }
                        }
                        throw modelStateErrors;
                    } else {
                        this.toastr.error(error.error, error.status.toString())
                    }
                    break;
                    case 401:
                    this.toastr.error('Unauthorized', error.status.toString());
                    break;
                    case 404:
                    this.router.navigateByUrl('/not-found')
                    break;
                    case 500:
                    //Navigation extras provides a way to pass the error information into a component to display it on the page
                    const navigationExtras: NavigationExtras = {state: {error: error.error}}
                    this.router.navigateByUrl('/server-error', navigationExtras);
                    break;
                    default:
                    this.toastr.error('Something unexpected occurred');
                    console.log(error);
                    break;
                }
                }
                throw error;
            }));
            }
        }

    Add the interceptor to app.modules in the providers array:
        {provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi:true}
        multi:true allows angular provided interceptors to continue working as well     

    Setup server side validation errors for 400 validation error:
    in error component:

        establish error list:
            validationErrors: string[] = []

        populate the error list in function:
            get400ValidationError() {
                this.http.post(this.baseUrl + 'account/register', {}).subscribe({
                next: response => console.log(response),
                error: error => {
                    console.log(error);
                    this.validationErrors = error;
                }
                })
            }
        Present the error in a list via template:
            <div class="row mt-5" *ngIf="validationErrors.length > 0">
                <ul class="text-danger">
                    <li *ngFor="let error of validationErrors">
                        {{error}}
                    </li>
                </ul>
            </div>

    Handle 401 and 500 error:
        create /not-found and /server-error components:
            ng g c errors/not-Found

            ng g c errors/server-error

        not-found.html :
        <div class="container">
            <h1>Not Found</h1>
            <button class="btn btn-info btn-lg" routerLink="/">Return to Home Page</button>
        </div>
        
        establish home route in route.ts:
            {path: 'not-found', component: NotFoundComponent},
            {path: 'server-error', component: ServerErrorComponent},
            //wildcards are implictly not found so ajust route to go to that comp as well
            {path: '**', component: NotFoundComponent, pathMatch: 'full'},

        Cleanup nav login and remove toast message since its already handled globally:
            removed toast message 
            register aslo no longer needs toast 

        Server-error html:
            <h4> Internal server error - refreshing this page will make the error disappear</h4>
            <ng-container *ngIf="error">
            <h5 class="text-danger">Error: {{error.message}}</h5>
            <p class="font-weight-bold"> Note: If you are seeing this then angular is probably not to blame </p>
            <p> What to do next?</p>
            <ol>
                <li> Open Chrome Dev tools then check the failing request in the network tab</li>
                <li> Examine the req url - What api endpoint are you requesting? </li>
                <li>Reproduce the problem in postman - iff same error angular is not the problem for certain</li>
            </ol>
            <p style="font-weight: bold">Following is the stack trace:</p>
            <code class="mt-5" style="background-color: whitesmoke;">
                {{error.details}}
            </code>
            </ng-container>

        server error ts:
            import {Component, OnInit} from '@angular/core';
            import {Router} from "@angular/router";

            @Component({
            selector: 'app-server-error',
                templateUrl: './server-error.component.html',
                styleUrl: './server-error.component.css'
                })
                export class ServerErrorComponent implements OnInit{
                error:any;
                constructor(private router: Router){
                    const navigation = this.router.getCurrentNavigation();
                    //The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
                    // For example, ?.() is used to call a function that may not exist.
                    // The ?.[] syntax also works, if wed like to use brackets [] to access properties instead of dot .. Similar to
                    this.error = navigation?.extras?.state?.['error']
                }

                ngOnInit() {

                }
            }


    next steps:
        Clean up the component styling make the compoent appear center aligned with a margin around the sides 


    Extending the api:
        Goals:
            entity framework, relationships,conventions
            seeding data to db
            repository pattern 
            using automapper
        
        Extend the app user class:
            add these props to the appuser 
                public Byte[] PasswordSalt { get; set; }
                public DateOnly DateOfBirth { get; set; }
                public string KnownAs { get; set; }
                public DateTime Created { get; set; }
                public DateTime LastActive { get; set; }
                public string Gender { get; set; }
                public string Introduction { get; set; }
                public string Country { get; set; }
                public string City { get; set; }
                public string Interests { get; set; }
                public string LookingFor { get; set; }
                public List<Photo> Photos { get; set; } = new();

            Create phot class to house photo information and be able to have a list in the appuser 
                public class Photo
                {
                    public int Id { get; set; }
                    public string Url { get; set; }
                    public bool IsMain { get; set; }
                    public string PublicId { get; set; }
                }
        
        DateTimeExtension to calc age base on DoB:
            create method in appUser class:
                public int getAge()
                {
                    return DateOfBirth.CalculateAge();
                }

            Create helper class/ extensiont 
                static class that allows for dateitme conversions
                in extensions/DateTimeExtensioons
                public static class DateTimeExtensioons
                {
                    public static int CalculateAge(this DateOnly dob)
                    {
                        var today = DateOnly.FromDateTime(DateTime.UtcNow);
                        var age = today.Year - dob.Year;
                        if (dob > today.AddYears(-age)) age--;
                        return age;
                    }
                }

    Entity Framework relationships:
        user and photos is a one to many relationship 
            one user can have many photo's
            should remain in the same context as the phontos will be linked directly to one user 
            photos will not be queried directly will be access via the user
        [Table("Photos")]
            public class Photo

        Create Migration to generate photos and add field to appuser
        dotnet ef migrations add ExtenededUserEntity

        migration is not quite right phots recieves an appuser id  which can be nullable, this is not ideal to have photos without a user need to addjust the entity to fully define th e user phot relationship

        dotnet ef migration remove 

        will remove the last unapplied migration

        adding this to photos will ensure that phot created will have to be tied to a user and cannot be orphaned : 
            public int AppUserId { get; set; }
            public AppUser AppUser { get; set; }

        apply migration:
        dotnet ef database update

    Genrating Seed Data:
        Use the Json Generator tool:
        https://json-generator.com/
        use provided json file in assets to generate:
        [
            '{{repeat(5)}}',
            {
                UserName: '{{firstName("female")}}',
                Gender: 'female',
                DateOfBirth: '{{date(new Date(1950,0,1), new Date(1999, 11, 31), "YYYY-MM-dd")}}',
                KnownAs: function(){ return this.UserName; },
                Created: '{{date(new Date(2019, 0, 1), new Date(2020,5,30), "YYYY-MM-dd")}}',
                LastActive: '{{date(new Date(2020, 4, 1), new Date(2020,5,30), "YYYY-MM-dd")}}',
                Introduction: '{{lorem(1, "paragraphs")}}',
                LookingFor: '{{lorem(1, "paragraphs")}}',
                Interests: '{{lorem(1, "sentences")}}',
                City: '{{city()}}',
                Country: '{{country()}}',
                Photos: [
                    {
                    Url: function(num) {
                    return 'https://randomuser.me/api/portraits/women/' + num.integer(1,99) + '.jpg';
                    },
                    IsMain: true
                }
                ]
            }
        ]
        add the json to userseed.json in the data folder of the api 

    Create seed class in data folder :
        public class Seed
        {
            public static async Task SeedUsers(DataContext context)
            {
                if (await context.Users.AnyAsync())
                {
                    return;
                }
                else
                {
                    var userData = await File.ReadAllTextAsync("Data/UserSeedDataNew.json");
                    //ignores and still adds lowercase property name 
                    var options = new JsonSerializerOptions{PropertyNameCaseInsensitive = true};
                    var users = JsonSerializer.Deserialize<List<AppUser>>(userData);
                    foreach (var user in users)
                    {
                        using var hmac = new HMACSHA512();
                        user.UserName = user.UserName.ToLower();
                        user.PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes("Pa$$w0ed"));

                        context.Users.Add((user));
                    }

                    await context.SaveChangesAsync();
                    

                }
            }
        }
    Init the seed method in the startup.cs class:
        immediately before app.Run place this try catch block 
        try
        {
            var context = services.GetRequiredService<DataContext>();
            //with a freshly dropped db this will rerun all the migration scripts create the db and 
            //then run seed
            await context.Database.MigrateAsync();
            await Seed.SeedUsers(context);
        }
        catch (Exception ex)
        {
            var logger = services.GetService<ILogger<Program>>();
            logger?.LogError(ex, "An error occured during migration");
        }

        app.Run();

    Test the seed, drop the db and remigrate 
        cli:
            dotnet ef database drop

        rerun app and watch the migration reoccur then... fail with error 
            ---> System.ArgumentException: Cannot write DateTime with Kind=Unspecified to PostgreSQL type 'timestamp with time zone', only UTC is supported. Note that it's not possible to mix DateTimes with different Kinds in an array, range, or multirange. (Parameter 'value')

        add AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true); to program.cs
            --> after the app.build

        rerun app again, that error should be gone one more remains 
            ---> Npgsql.PostgresException (0x80004005): 23502: null value in column "PasswordSalt" of relation "Users" violates not-null constraint
      
            DETAIL: Detail redacted as it may contain sensitive data. Specify 'Include Error Detail' in the connection string to include this information.
        
        needed to add:  
            user.PasswordSalt = hmac.Key;
        to the seed.cs method after generate hash

        That errors is gone another error remains:
            ---> Npgsql.PostgresException (0x80004005): 23502: null value in column "PublicId" of relation "Photos" violates not-null constraint
            
            a problem for tomorrow me to figure out 

            next steps:
                address seed error
                Clean up the component styling make the compoent appear center aligned with a margin around the sides 

January 28, 2024:
    Fixed seed error had to make the public id nullable in the migration script:
        PublicId = table.Column<string>(type: "text", nullable: true),

    To Do:
        Center the compoenent in the index page 

    
    Seed data postman testing:
        int the api route check there is a test tab that allows you to assert the response and store a return value:
            running the first route test in the auth tetsing folder will pull the auth token and allow it to be used in subsequent test without need to manulaly paste it in 
        top right icon with show the env variable that is stored with name token after test is run 

    Repository Pattern:
        martin fowler patterns of enterprise architecture:
            A repository mediates between the domain and data mapping layers acting like an in memory domain object collection

            Current app data workflow:
                web server <-> controller <-> dbContext <-> database 

            Repository Pattern workflow:
                web server <-> controller <-> repository <-> dbContext <-> database 

            Repo allow for quick data access for commonly used 
            may be exceesss as unitofwork and dbcontext act in similar fashion 

        Reason to use this thoughL:
            encapsulates the logic
                users.First turns into getUser can limit the scope of method accessed by the front end 
            reduce dupe query logic 
            promotes testability 
            easy to test against repo the context 
            decouples application from the persistance framework 
            decentralizes the queries 
            allows easy changes orm 
            promotes readablility 
            Drawbacks:
                each root entity should have its own repo 
                need to implement unit of work pattern 
        
    Pull the context our of the controller 
        create repoository interface for user in repo folder then implement it in the data folder 
        namespace TeborawAPI.Data;
            public class UserRepository : IUserRepository
            {
                private readonly DataContext _context;

                public UserRepository(DataContext context)
                {
                    _context = context;
                }
                public void Update(AppUser user)
                {
                    _context.Entry(user).State = EntityState.Modified;
                }

                public async Task<bool> SaveALlAsync()
                {
                    return await _context.SaveChangesAsync() > 0;
                }

                public async Task<IEnumerable<AppUser>> GetUsersAsync()
                {
                    await _context.Users.ToListAsync();
                }

                public async Task<AppUser> GetUserByIdAsync(int id)
                {
                    return await _context.Users.FindAsync(id);
                }

                public async Task<AppUser> GetUserByUsernameAsync(string username)
                {
                    return await _context.Users.SingleOrDefaultAsync(x => x.UserName == username);
                }
            } 
        add the repo as a service extenision in the application services extension:
            services.AddScoped<IUserRepository, UserRepository>();

    Refactor the User Controller
        inject user repo interface instead of the context:
            public UsersController(IUserRepository userRepository)
            call the repo and return need to return as 
            return Ok(await _userRepository.GetUsersAsync());
        Photos array is empty though when returning 
            the list of users doest not include related data 
            need the includes keyword to eager load the data
            code:
                return await _context.Users
                    .Include(p => p.Photos)
                    .ToListAsync();

            This fucked shit up apparantly
            Error:
                 "message": "A possible object cycle was detected. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 32. Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles. Path: $.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.",
                "details": "   at System.Text.Json.ThrowHelper.ThrowJsonException_SerializerCycleDetected(Int32 maxDepth)\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\n   at System.Text.Json.Serialization.Converters.ListOfTConverter`2.OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state)\n   at System.Text.Json.Serialization.JsonCollectionConverter`2.OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options,

            the includes is caught in a cyclical query because the AppUsers is associated to both the photos and User
            need to exclude the appuser upont quesry

            Need to shape the data via DTO's:
            Create the member and photo excluding the cyclical maps
                public class MemberDTO
                {
                    public int Id { get; set; }
                    public string UserName {get; set;}
                    public int Age { get; set; }
                    public string KnownAs { get; set; }
                    public DateTime Created { get; set; }
                    public DateTime LastActive { get; set; }
                    public string Gender { get; set; }
                    public string Introduction { get; set; }
                    public string Country { get; set; }
                    public string City { get; set; }
                    public string Interests { get; set; }
                    public string LookingFor { get; set; }
                    public List<PhotoDTO> Photos { get; set; }
                }

                public class PhotoDTO
                {
                    public int Id { get; set; }
                    public string Url{ get; set; }
                    public bool IsMain { get; set; }
                }

            Automapper!! Map the model/entity to the dto:
                nuget install the automapper: AutoMapper.Extensions.Microsoft.DependencyInjection
                
                Create helpers folder > AutoMapperProfiles: 
                    public class AutoMapperProfiles: Profile
                    {
                        public AutoMapperProfiles()
                        {
                            CreateMap<AppUser, MemberDTO>();
                            CreateMap<Photo, PhotoDTO>();
                        }
                    }
                
                AutoMappers shouold ideally compare the names and "auto" map the propertys and its smart enough to know Age in the dto refers to the getAge of user 
            
                Inject add as a service auto mapper to the controller 
                    ApplicationServiceExtensions:
                        services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());

                    usersController inject:
                        private readonly IUserRepository _userRepository;
                        private readonly IMapper _mapper;

                        public UsersController(IUserRepository userRepository, IMapper mapper)
                        {
                            _userRepository = userRepository;
                            _mapper = mapper;
                        }
                    
                Utilize the mapper in the UserController:
                    public async Task<ActionResult<IEnumerable<AppUser>>> GetUsers()
                    {
                        var users = await _userRepository.GetUsersAsync();
                        var usersToReturn = _mapper.Map <IEnumerable<MemberDTO>>(users);
                        return Ok(usersToReturn);
                    }

            Configure specified propers to be returned from a dto eg just the photo url not entire object:
                mapping to meber prop: public string PhotoUrl { get; set; }
                automapper auto sets this to null need to dictate how to fill this in the Automapper profiles
                Code:
                    CreateMap<AppUser, MemberDTO>()
                        .ForMember(dest => dest.PhotoUrl,
                            opt => opt
                                .MapFrom(src => src.Photos.FirstOrDefault(x => x.IsMain).Url));

                photo url should now populate properly without null gonna take a min to unpack this code

        Optimizing the entity queries:
            Right now the ef calls are pulling all the data from the user table event the password fields that down get mapped to anything 

            the non automapper way:
                public async Task<MemberDTO> GetMemberAsync(string username)
                {
                    return await _context.Users
                        .Where(x => x.UserName == username)
                        .Select(user => new MemberDTO
                        {
                            Id = user.Id,
                            UserName = user.UserName,
                            KnownAs = user.KnownAs,
                        }).SingleOrDefaultAsync();
                }

        the automapper way:
            IUserRepository inject Imapper and add at the projectTO inplace of the select statement:
                public async Task<MemberDTO> GetMemberAsync(string username)
                {
                    return await _context.Users
                        .Where(x => x.UserName == username)
                        .ProjectTo<MemberDTO>(_mapper.ConfigurationProvider)
                        .SingleOrDefaultAsync();
                }
            Swap the userController code to use the repo instead:
                    [HttpGet("{username}")] // /api/users/2
                    //gonna get  weird result if username not foune
                    public async Task<ActionResult<MemberDTO>> GetUser(string username)
                    {
                        return await _userRepository.GetMemberAsync(username);
                    }

            GetAge is fucking shit up automapper needs to load all members of the data entity before it can call that 
                comment that shit out in appuser:
                adjust the automapper profile to pull the ages as it mappes instead of from within the appuser class :
                      CreateMap<AppUser, MemberDTO>()
                        .ForMember(dest => dest.PhotoUrl,
                            opt => opt
                                .MapFrom(src => src.Photos.FirstOrDefault(x => x.IsMain).Url))
                        .ForMember(dest => dest.Age, opt => opt.MapFrom(src => src.DateOfBirth.CalculateAge()));
                    
            Note:
                The projectTo autoMapp call auto eager loads the pertinant data, in this case the photo url, you nolong need the includes keyword as that is handled already.
    
    Building the User Interface:
        Using Typescript:
            Declaring a type of 2 types:
                let date : number | string = 42;
                data can have either a number or stringassigned to it.

            Typescript will infer the type base on the value that it is initialized too and the first value assigned dictates the type going forward

            Declaring an interface:
                will dicate the types ahead of time without values ex:
                    interface Car {
                        color: string,
                        model: string,
                        topSpeed?: number
                    }

                an interface will assume that all properties listed are required unless you add a ? after field declarations
                like topSpeed

            infering types from function params:
                const multiply = (x,y) => {
                    return x * y;
                }
                typescript inferes x and y can be any type but based on the function using multiplication it can only be numbers so its best to decalre it as a number 

        Create the Member and photo Interface:
            the front end needs a model to pass values to the api a viewmodel so to speak 
            ng cli:
                ng c i 

            The quick way to make a angular ts interface from a json file:
                json2ts.com > the snappy easy lazy way to do it you can get the user data passed back from the user controller and slapp it in here,
                to get a quick interface created 

                copy example user json data into the site ex: 
                    { 
                        "User":[{
                            "id": 1,
                            "userName": "lisa",
                            "age": 67,
                            "knownAs": "Lisa",
                            "created": "2020-06-24T02:00:00+02:00",
                            "lastActive": "2020-06-21T02:00:00+02:00",
                            "gender": "female",
                            "introduction": "Sunt esse aliqua ullamco in incididunt consequat commodo. Nisi ad esse elit ipsum commodo fugiat est ad. Incididunt nostrud incididunt nostrud sit excepteur occaecat.\r\n",
                            "country": "Martinique",
                            "city": "Greenbush",
                            "interests": "Sit sit incididunt proident velit.",
                            "lookingFor": "Dolor anim cupidatat occaecat aliquip et Lorem ut elit fugiat. Mollit eu pariatur est sunt. Minim fugiat sit do dolore eu elit ex do id sunt. Qui fugiat nostrud occaecat nisi est dolor qui fugiat laborum cillum. Occaecat consequat ex mollit commodo ad irure cillum nulla velit ex pariatur veniam cupidatat. Officia veniam officia non deserunt mollit.\r\n",
                            "photos": [
                                {
                                    "id": 1,
                                    "url": "https://randomuser.me/api/portraits/women/54.jpg",
                                    "isMain": true
                                }
                            ],
                            "photoUrl": "https://randomuser.me/api/portraits/women/54.jpg"
                        }]
                    }
                produces this ts interface:
                    export interface User {
                        id: number;
                        userName: string;
                        age: number;
                        knownAs: string;
                        created: string;
                        lastActive: string;
                        gender: string;
                        introduction: string;
                        country: string;
                        city: string;
                        interests: string;
                        lookingFor: string;
                        photos: Photo[];
                        photoUrl: string;
                        }

                    export interface Photo {
                        id: number;
                        url: string;
                        isMain: boolean;
                        }
            Create a member.ts interface file in _models folder:
                ng g interface _models/member
                cmd . on the photo interface to make the interface a new file 

    Get Ride of harcoded baseUrl:
        add a env file to house this data 
        
        ng cli:
            ng g environments
                creates 2 files 
                    CREATE src/environments/environment.ts (31 bytes)
                    CREATE src/environments/environment.development.ts (31 bytes)
            establis url and env in the dev and prod files:
                dev:
                    export const environment = {
                        prodution: false,
                        apiUrl: 'https://localhot:L5001/api/'
                    };
                prod:
                    export const environment = {
                        prodution: true,
                        apiUrl: 'api/'
                    };

        import the environment vars everwhere the baseUrl is swap em:
            DI environment and swap Ex:
                //ensure to inmport from root import { environment } from '../../environments/environment'; 
                //and not the dev one otherwise it will not change in production
                baseUrl = environment.apiUrl;
    
    Marshalling Data:
        In computer science, marshalling (similar to serialization) is the process of transforming the memory representation of an object to a data format suitable for storage or transmission. It is typically used when data must be moved between different parts of a computer program or from one program to another.
    
    
    Create a member service to to marshal data from the controller to components:
        ng cli: 
            ng g s _services/members 

        member.service.ts:
            @Injectable({
            providedIn: 'root'
            })
            export class MembersService {
            baseUrl = environment.apiUrl

            constructor(private http: HttpClient) { }

            getMembers(){
                return this.http.get<Member[]>(this.baseUrl + 'users' + this.getHttpOptions())
            }

            getMember(username:string){
                return this.http.get<Member>(this.baseUrl + 'users/' + username, this.getHttpOptions());
            }

            //need a way to pass authentication, the wrong way first then the proper way later 
            getHttpOptions(){
                const userString = localStorage.getItem('user')
                if(!userString) return;
                const user = JSON.parse(userString)
                return{
                headers: new HttpHeaders({
                    Authorization: 'Bearer ' + user.token
                })
                }
        
        put the service to use in the member list component:
            export class MemberListComponent implements OnInit {
                members : Member[] = []

                constructor(private memberService:MembersService){}

                ngOnInit(): void {
                    this.loadMembers()
                }

                loadMembers(){
                    this.memberService.getMembers().subscribe({
                    next: members => this.members = members
                    })
                }
            }

    List the names in the member-list.component:
        <div class="row">
            <div class="col-2">
                <p *ngFor="let member of members">{{member.knownAs}}</p>
            </div>
        </div>

    Create memeber card components:
        ng cli:
            ng g c member/member-card

            tsconfig.ts can be adjust to reduce ts's strictness
                "strictPropertInitialization" : false
            not a good idea to do this 
        member card is achild to the member list and thus need input data 
        @Input() member : Member
            angular will yell at you until this initialized you can do this in 2 ways:
            @Input() member : Member = {} as Member
            or:
            @Input() member : Member | undefined;
                prefferred way is this as initialy the member will start out undefined 

        Create template card:
        <div class="card mb-4">
            <div class="card-img-wrapper">
                <img src="{{member?.photoUrl}}" alt="{{member?.knownAs}}">
            </div>
        </div>
        Or check for member existance:
        <div class="card mb-4" *ngIf="member">
            <div class="card-img-wrapper">
                <img src="{{member.photoUrl}}" alt="{{member.knownAs}}">
            </div>
        </div>

        slap that component into the list component template passing in the member as the input 
        <div class="row">
            <div class="col-2" *ngFor="let member of members">
                <app-member-card [member]="member"></app-member-card>
            </div>
        </div>

    Make the cards interactive with hovering:
        member-card.component.css
            .card:hover img {
                transform: scale(1.2,1.2);
                transition-duration: 500ms;
                transition-timing-function: ease-out;
                opacity: 0.7;
            }

            .card img {
                transform: scale(1.0,1.0);
                transition-duration: 500ms;
                transition-timing-function: ease-out;
            }

            .card-img-wrapper {
                overflow: hidden;
            }
        this zooms the image in the box when you hover over it.

        encapsulation attribute of a component.ts 
            encapsulation: ViewEncapsulation.Emulated
                when set to emulate which by default it is 
                will generate unique class ids with the class name and random number at the end for each compoent ensuring that the css declare in the component.cc only applies to that specific component generate from that ts component you can however set the ViewEncapsulation to none and the css will be set to the class declared within the template without random ids tacked to the end:

            example:
                encapsulation: ViewEncapsulation.None
                @Component({
                    selector: 'app-member-card',
                    templateUrl: './member-card.component.html',
                    styleUrl: './member-card.component.css',
                    encapsulation: ViewEncapsulation.None
                })

January 29 2024:
    Adding animated buttons member card and member card css:
        .member-icons {
            position: absolute;
            bottom: -30%;
            left: 0;
            right: 0;
            margin-left: auto;
            margin-right: auto;
            opacity: 0;
        }

        .card-img-wrapper:hover .member-icons{
            bottom: 0;
            opacity: 1;
        }

        .animate {
            transition: all .3s ease-in-out;
        }
        <ul class="list-inline member-icons animate text-center">
                <li class="list-inline-item">
                    <button class="btn btn-primary">
                        <i class="fa fa-user"></i>
                    </button>
                </li>
                <li class="list-inline-item">
                    <button class="btn btn-primary">
                        <i class="fa fa-heart"></i>
                    </button>
                </li>
                <li class="list-inline-item">
                    <button class="btn btn-primary">
                        <i class="fa fa-envelope"></i>
                    </button>
                </li>
            </ul>
        </div>

    Using interceptor to send jwt token instead of hardwiring header with barer on each request"

        create interceptor ng cli:
            ng g interceptor _interceptors/jwt

        jwt.intercepot.ts:
            export class jwtInterceptor implements HttpInterceptor{

            constructor(private accountService: AccountService){}

            intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
                //THis is a trick to ensure that the subscription completes and unsubscribing is not required 
                this.accountService.currentUser$.pipe(take(1)).subscribe({
                next: user=>{
                    if(user){
                    req = req.clone({
                        setHeaders: {
                        //back ticks allow for string interpols to be added inline without need of + '' nonsense
                        Authorization: `Bearer ${user.token}`
                        }
                    })
                    }
                }
                })
                return next.handle(req)
                }
            }
        add the intercepto to the app.module:
            {provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi:true},
        
        remove the headers added in the members service


    Routing to the detailed page:
        member-detail.component.ts:
            inject the member service and activated route and pass in the member username passed in from the router

            export class MemberDetailComponent implements OnInit {
                member: Member | undefined;

                //Route allows access to the the username passed into the routers upon loading this component
                constructor(private memberService: MembersService, private route: ActivatedRoute){}

                ngOnInit(): void {
                    this.loadMember()
                }

                loadMember(){
                    var username = this.route.snapshot.paramMap.get('username')
                    if(!username) return;
                    this.memberService.getMember(username).subscribe({
                    next: member => this.member = member
                    })
                }
            }
        apply the router linke for the memebrs in the member card:
            <button class="btn btn-primary" routerLink="/member/{{member.userName}}">

    Creating the member  card template: member-detail card.ts:
        <div class="row" *ngIf="member">
            <div class="col-4">
                <div class="card">
                    <img src="{{member.photoUrl || './assets/user.png'}}" alt="{{member.knownAs}}"
                        class="card-img-top img-thumbnail">
                    <div class="card-body">
                    <div>
                        <strong>Location:</strong>
                        <p>{{member.city}}</p>
                    </div>
                    <div>
                        <strong>Age:</strong>
                        <p>{{member.age}}</p>
                    </div>
                    <div>
                        <strong>Last Active:</strong>
                        <p>{{member.lastActive}}</p>
                    </div>
                    <div>
                        <strong>Member Since:</strong>
                        <p>{{member.created}}</p>
                    </div>
                    <div class="card-footer">
                        <div class="btn-group d-flex">
                        <button class="btn btn-primary">Like</button>
                        <button class="btn btn-success">Message</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        Style:

        .img-thumbnail{
            margin: 25px;
            width: 85%;
            height: 85%;
            }

        .card-body{
            padding: 0 25px;
            }

        .card-footer{
            padding: 10px 20px;
            border-top: none;
            }


    Create tabs for details:
        add  TabsModule.forRoot(), to the shared modules 
        
        add tabset element to the member-detail template  
        <div class="col-8">
            <tabset></tabset>
        </div>

        specifie its properties as its an ngx component:
          <div class="col-8">
            <tabset class="member-tabs">
            <tab heading="About {{member.knownAs}}">
                <h4>Description</h4>
                <p>{{member.introduction}}</p>
                <h4>Looking for</h4>
                <p>{{member.lookingFor}}</p>
            </tab>
            <tab heading="Interests">
                <h4>Interests</h4>
                <p>{{member.interests}}</p>
            </tab>
            <tab heading="Photos">
                <p>Photos will go hear</p>
            </tab>
            <tab heading="Messages">
                <p>Messages will go hear</p>
            </tab>
            </tabset>
        </div>

    Adding Photo Gallery to the tab:
        ngx-gallery will be used here:
            npm install ng-gallery @angular/cdk --save

        This is a standalone component which allows component to be created appart from an ng module 
        meaning the component does not need to be declared in the app module
        but you cant use a standalone in a component that is not a standalone

        MemberDetailComponent needs declared as standalone to use gallery:
            @Component({
                selector: 'app-member-detail',
                standalone: true,

            MemberDetailComponent needs undeclared from the app module
                this will break the ang declarations in the MemberDetailComponent.html template
                cant use ngif and temp set 
                these elements need to import these on there in 
                need to add an imports stamement 
                this should fix that:
                    import {NgIf} from "@angular/common";
                    import {TabsModule} from "ngx-bootstrap/tabs";      

                      imports: [
                        NgIf,
                        TabsModule
                    ],
            
            then import the ng gallery now too this > GalleryModule

        pull the photos into a galleryitem array via:
            images: GalleryItem[] = []
            getImages(){
                if(!this.member) return;
                for(const photo of this.member.photos){
                this.images.push(new ImageItem({src: photo.url, thumb:photo.url}))
                }
            }

        added the gallerey component to the members details component
            <tab heading="Photos">
                <gallery [items]="images"></gallery>
            </tab>

        however because the gallery is being put in a tab the tab needs a #photTab reference added
        with a if to check if the the phot tab is active
            <tab heading="Photos" #photoTab = "tab">
                <gallery *ngIf="photoTab.active" [items]="images"></gallery>
            </tab>

Updating Resources:
    Goals:
        Angular template forms , 
        can deactivate routegaurd, 
        @ViewChild, 
        persisting changes to the api, 
        adding loading indicators, 
        cavhhing data in angular services

    
    Create profile edit page:
        ng cli:
            ng g c member/member-edit

        Add router link to the nav bar to get to member and add routing as well 
            {path: 'member/edit', component: MemberEditComponent},
            <a class="dropdown-item" routerLink="/member/edit"> Edit Profile</a>

        Member-edit:
            pull the members user data and quckly slap a user name in the template 
                member: Member | undefined
                user: User | null = null

                constructor(private accountService : AccountService, private memberService : MembersService) {
                    this.accountService.currentUser$.pipe(take(1)).subscribe({
                    next: user => this.user = user
                    })
                }

                ngOnInit(): void {
                    this.loadMember()
                }

                loadMember(){
                    if(!this.user) return
                    this.memberService.getMember(this.user.username).subscribe({
                    next: member => this.member = member
                    })
                }

    Create edit template:
        copy fair bit from the member detail page:
            turn field into forms and add edit alert will make dynamic later 
            <div class="row" *ngIf="member">
                <div class="col-4">
                    <h1>Your Profile</h1>
                </div>
                <div class="col-8">
                    <div class="alert alert-info">
                    <p><strong>You have made changes, any unsaved changes will be lost. </strong></p>
                    </div>
                </div>
                <div class="col-4">
                    <div class="card">
                    <div class="card-body">
                        <img src="{{member.photoUrl || './assets/user.png'}}" alt="{{member.knownAs}}"
                            class="card-img-top img-thumbnail">
                        <div>
                        <strong>Location:</strong>
                        <p>{{member.city}}</p>
                        </div>
                        <div>
                        <strong>Age:</strong>
                        <p>{{member.age}}</p>
                        </div>
                        <div>
                        <strong>Last Active:</strong>
                        <p>{{member.lastActive}}</p>
                        </div>
                        <div>
                        <strong>Member Since:</strong>
                        <p>{{member.created}}</p>
                        </div>
                        <div class="card-footer">
                            <button class="btn btn-success col-12">Save CHanges</button>
                        </div>
                    </div>
                    </div>
                </div>

                <div class="col-8">
                    <tabset class="member-tabset">
                    <tab heading="About {{member.knownAs}}">
                        <form>
                        <h4 class="mt-2">Description</h4>
                        <textarea class="form-control" [(ngModel)]="member.introduction"
                                    name="introduction"
                                    rows="6">

                        </textarea>
                        <h4 class="mt-2">Looking for</h4>
                        <textarea class="form-control" [(ngModel)]="member.lookingFor"
                                    name="lookingFor"
                                    rows="6">

                        </textarea>
                        <h4 class="mt-2">Interests</h4>
                        <textarea class="form-control" [(ngModel)]="member.interests"
                                    name="interests"
                                    rows="6">

                        </textarea>
                        <h4 class="mt-2">Location Details: </h4>
                        <div class="d-flex flex-row align-items-center">
                            <label for="city">City:</label>
                            <input type="text"[(ngModel)]="member.city" name="city" class="form-control mx-2">
                            <label for="country">Country: </label>
                            <input type="text" [(ngModel)]="member.country" name="country" class="form-control mx-2">
                        </div>
                        </form>
                    </tab>
                    <tab heading="Edit Photos">
                        <p>Photo edit will go here</p>
                        <p>{{member.interests}}</p>
                    </tab>
                    </tabset>
                </div>
            </div>

    Plugin the form and submit:
        MemberEditComponent:
            to tie a a button to a form that is outside of the form element you need to assign the form and id and assign a form to the button like so:
            <button class="btn btn-success col-12" form="editForm">Save Changes</button>

            creating form element:
            <form #editForm="ngForm" id="editForm" (ngSubmit)="updateMember()" >

            updateMember(){
                console.log("Updating Member: ",this.member)
                this.toastr.success("Profile Updated Successfully")
            }


        Dynamic alert for if form has been editted:
            <div class="alert alert-info" *ngIf="editForm.dirty">
                <p><strong>You have made changes, any unsaved changes will be lost. </strong></p>
            </div>
        ngif dirty will make element appear of the the form editForm cantains altered values yet to be save also you can hide the save button as well 
            <button class="btn btn-success col-12"
                form="editForm"
                [disabled]="!editForm.dirty">Save Changes</button>   
        
        Add a reset button:
            need to be able to access the form element established on the template page 
            using ViewChild()
            in the memberedit component ts

            @ViewChild('editForm') editForm: NgForm | undefined

            then the forms values can be accessed or reset in this case:
              updateMember(){
                    console.log("Updating Member: ",this.member)
                    this.toastr.success("Profile Updated Successfully")
                    this.editForm?.reset(this.member)
                }

            !!the name property of each form fied is criticval for angular to map the field to the models property 2 way thus if mispelled or case is wrong shit gets f'ed in the a when you go to submit the form dont fuck it up 

    Prevent Navigation away from page if unsaved changes exist:
        CanDeactivate Gaurd is just the ticket:
        
        ng cli:
            ng g g _gaurds/prevent-unsaved-changes
                select canDeactivate unselect activate

        preventUnsavedChangesGuard.ts
            export const preventUnsavedChangesGuard: CanDeactivateFn<MemberEditComponent> = (component) => {
                if(component.editForm?.dirty){
                    return confirm('Are you sure you want to continue? all unsaved changes will be lost')
                }
                return true;
            };

        apply this gaurd to the route in question:
            {path: 'member/edit', component: MemberEditComponent, canDeactivate: [preventUnsavedChangesGuard]},


        this will not prevent navigate to entirely different domains need access to the browser for this.
        @Hostlistener is the ticket for this

        this bad boy gone be huge for user sanity
          @HostListener('window:beforeunload', ['$event']) unloadNotification($event: any){
            if(this.editForm?.dirty){
            $event.returnValue = true
        }

    Persisting the Changes to the api:
        create memberUpdateDtop:
            namespace TeborawAPI.DTOs;
            public class MemberUpdateDTO
            {
                public string Introduction { get; set; }
                public string LookingFor { get; set; }
                public string City { get; set; }
                public string Country { get; set; }
                public string Interests { get; set; }
            }
        add mapping profile:
            CreateMap<MemberUpdateDTO, AppUser>();

        updateuser via UsersController:
            [HttpPut]
            public async Task<ActionResult> UpdateUser(MemberUpdateDTO memberUpdateDto)
            {
                //THe username will be accessble via the claims principle of the user obtain via the token passed 
                //in via the headed of this request
                //debug will show this > user >results view > 
                //[0] > ex: {http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier: lisa}
                //nameidentifier: lisa or the value of 0 array memebr will be the user name as establishe in the Token service
                // Via new Claim(JwtRegisteredClaimNames.NameId, user.UserName),
                var username = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                var user = await _userRepository.GetUserByUsernameAsync(username);
                
                if(user == null) return NotFound();

                _mapper.Map(memberUpdateDto, user);

                if (await _userRepository.SaveALlAsync()) return NoContent();

                return BadRequest("Failed to Update User");
            }

    Wire in the api endpoint to the frontend:  
        update memberService:   
              updateMember(member:Member){
                return this.http.put(this.baseUrl + 'users', member)
            }
        Utilize this in the MemberEditComponent:
            updateMember(){
                console.log("Updating Member: ",this.member)
                this.memberService.updateMember(this.editForm?.value).subscribe({
                next: _ =>{
                    this.toastr.success("Profile Updated Successfully")
                    this.editForm?.reset(this.member)
                }
                })
            }

    Adding a loading indicator upon updates:
        install a spinner -> ngx-spinner 
            https://napster2210.github.io/ngx-spinner/
            
            npm install :
                npm install ngx-spinner --save

        Add the css for animations:
            angular.json:
                "node_modules/ngx-spinner/animations/square-spin.css"
            style.css
                @import "node_modules/ngx-spinner/animations/square-spin.css";
        
        import into the share modules:
            NgxSpinnerModule.forRoot({
                type: 'square-spin'
            }),
        Export the module as well:
            NgxSpinnerModule,

        now to add a effectively an interceptor to show the loading bar upon http request:
            create busy service ng cli to display the spinner :
                ng g s _services/busy
                BusyService:
                    @Injectable({
                        providedIn: 'root'
                    })
                    export class BusyService {
                        busyRequestCount = 0;
                        constructor(private spinnerService : NgxSpinnerService) { }

                        busy(){
                            this.busyRequestCount++
                            this.spinnerService.show(undefined, {
                            type: 'square-spin',
                            bdColor: 'grey',
                            color: 'blue'
                            })
                        }

                        idle(){
                            this.busyRequestCount--
                            if(this.busyRequestCount <= 0){
                            this.busyRequestCount = 0
                            this.spinnerService.hide();
                            }
                        }
                    }

        apply this service to an interceptor 
            ng cli:
                ng g interceptor _interceptors/loading

            loadingInterceptor:

                @Injectable()
                    export class loadingInterceptor implements HttpInterceptor{

                    constructor(private busyService: BusyService){}

                    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
                        this.busyService.busy();
                        return next.handle(req).pipe(
                        //this is a synthetic delay for development to allow for loading bar to show itself
                        delay(1000),
                        finalize(()=> {
                            this.busyService.idle()
                        })
                        )
                    }
                }

        Slap that Interceptor into the app.modules providor:
            {provide: HTTP_INTERCEPTORS, useClass: LoadingInterceptor, multi:true},

        need to add the spinner to the appcomponent // the root component of the entire app allowing the spinner potential to show on any page or route:
            app.component.html:
                <ngx-spinner type = "square-spin" [fullScreen] = "true"><p style="color: white" > Loading... </p></ngx-spinner>

    TIme to cache the data you already done did load like, the users info  and the photos n such:
        you can cache data within a service:
            member service ftw:
                add a global member list
                    members : Member[] = [];

                then either populate the members if its empty or return the member usinf of() rxjs to return an observable
                    //member deets are conveniently housed in the member list, so if that was already loaded you can get it from there without phoning home
                    getMembers(){
                        if(this.members.length > 0) return of(this.members)
                        return this.http.get<Member[]>(this.baseUrl + 'users').pipe(
                        map(members =>{
                            this.members = members
                            return members
                        })
                    )}
        now you will not a distinct lack of loading screen after loading memebrs for the first time and then loading it again

        NOTE BUG: Journal and about pages redirect the user from the app entirely and clear out services 
            this is prolly due to them not being in the same route child group and outside of them may want toplay around wiht this later to see 
            what I can do to address that.

        SHould also cache the individual member details as well 
            //member deets are conveniently housed in the member list, so if that was already loaded you can get it from there without phoning home
            getMember(username:string){
                const member = this.members.find(x => x.userName === username)
                if(member) return of(member)
                return this.http.get<Member>(this.baseUrl + 'users/' + username);
                //not needed any more now that jwt interceptor is in place
                //return this.http.get<Member>(this.baseUrl + 'users/' + username, this.getHttpOptions());
            }

        also update profile changes need the cache to be updated as well:
            //cached data needs updated so that the user can see his update details if he re-nav'd to his profile after updates
            updateMember(member:Member){
                return this.http.put(this.baseUrl + 'users', member).pipe(
                map(()=>{
                    const index = this.members.indexOf(member)
                    //... is the spread operator will spread all the propertied of the member at this.members specified index and will map then
                    // the properties from the parameter and updated member 1 to 1 , because they are the same type it will update each field with out
                    // a literal loop needed to be defined
                    this.members[index] = {...this.members[index], ...member}
                })
                )
            }

    Lastly Modify the way the members are load make it an observable:
        allow for better readability.
        MemberListComponent:
            export class MemberListComponent implements OnInit {
                members$ : Observable<Member[]> | undefined


                constructor(private memberService:MembersService){}

                ngOnInit(): void {
                    this.members$ = this.memberService.getMembers();
                }

            }
        MemberListComponent.html:
            <div class="row">
                <div class="col-2" *ngFor="let member of members$ | async">
                    <app-member-card [member]="member"></app-member-card>
                </div>
            </div>

    Conclusion:
        Real fuckin neat section really learned a whole bunch of design pradignms with angular and services, and interceptors,
        and how service act as singletons allowing for the caching of data reducing the db calll backs that occur

January 30 2024:
    Adding image upload functionality:
        goals:
            photo storage options 
            added related entities 
            using 3rd party api's 
            debug dis shit
            updating and deleting resources 
            what to return when creating resources in rest based api (representative state transfer)

    Photo storage options:  
        store as blobs in the db  but not an effiecient way to do this as dbs are'nt optimized for this 
        server filesystem > not a bad option downsides: space issues concerns if the file servfer is on the same pace as webserver, 
            image variability and types and aspect ratios
        Account service : virtual unlimited space but at a cost 
    
    Cloudinary Photo storage:
        has free tier with 10gb of storage with image translations and storage

    Image upload workflow:
        client uploads photo to api with jwt 
        server uploads the photo to cloudinary 
        cloudinary stores the photo andd sends response 
        api saves thes the photo url and the public id to the DB 
        saved in adb and given autogenerated id 
        201 created response sent to the client with location header

        photo <-> a p i <-> cloudinary 
                    |
                   db 

    Create cloudinary account:
        https://console.cloudinary.com/console/c-a47dee7f03fb19a983847ec6bf2c31/welcome
        api documentation:
            https://cloudinary.com/documentation/dotnet_integration

    Setup the api with cloudinary;
        install nuget cloudinary package: 
            CloudinaryDotNet

        Configure setting in the appsettings.json
            git ignore this file now 
            add api details:
                "CloudinarySettings":{
                    "CloudName": "",
                    "ApiKey": "",
                    "ApiSecret": ""
                },

    Create helper cloudinarysetting.cs
        public class CloudinarySettings
        {
            public string Name { get; set; }
            public string ApiKey { get; set; }
            public string ApiSecret { get; set; }
        }
    
    Add the cloudinary service to ApplicationServiceExtensions using the helper to hose the env config vars
        services.Configure <CloudinarySettings>(config.GetSection("CloudinarySettings"));


    Create photo upload service :
        create the interface first:
            namespace TeborawAPI.Interfaces;
            public interface IPhotoService
            {
                Task<ImageUploadResult> AppPhotoAsync(IFormFile file);
                Task<DeletionResult> DeletePhotoAsync(string publicId);
            }
        Create the service implementing the interface:
            public class PhotoService : IPhotoService
            {
                private readonly Cloudinary _cloudinary;
                public PhotoService(IOptions<CloudinarySettings> config)
                {
                    var acc = new Account(
                        config.Value.CloudName,
                        config.Value.ApiKey,
                        config.Value.ApiSecret
                    );

                    _cloudinary = new Cloudinary(acc);
                }
                public async Task<ImageUploadResult> AppPhotoAsync(IFormFile file)
                {
                    var uploadResults = new ImageUploadResult();
                    if (file.Length > 0)
                    {
                        using var stream = file.OpenReadStream();
                        var uploadParams = new ImageUploadParams
                        {
                            File = new FileDescription(file.FileName, stream),
                            Transformation = new Transformation().Height(500).Width(500).Crop("fill").Gravity("face"),
                            Folder = "Teboraw-net8"
                        };
                        uploadResults = await _cloudinary.UploadAsync(uploadParams);
                    }

                    return uploadResults;
                }

                public async Task<DeletionResult> DeletePhotoAsync(string publicId)
                {
                    var deleteParams = new DeletionParams(publicId);
                    return await _cloudinary.DestroyAsync(deleteParams);
                }
            }
        Add the service to extension:
            services.AddScoped<IPhotoService, PhotoService>();

    Inject that service to the users controller create endpoint:
        create extension class to provide for the username and user data quickly and reduce code duplication:
            public static class ClaimsPrincipalExtensions
            {
                public static string GetUserNamethis ClaimsPrincipal user)
                {
                    return user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                }
            }

        public static string GetUserNamethis ClaimsPrincipal user)
            allows you to exted the ClaimsPrincipal as if you were inside the class itself adding a method or creating a class that extends it with additional functionality
            its dope as fuck you dont have to go through all that noise just for one method and you can call it then like this:

            var username = User.GetUserName();

            UserController:
                [HttpPost("add-photo")]
                public async Task<ActionResult<PhotoDTO>> AddPhoto(IFormFile file)
                {
                    var user = await _userRepository.GetUserByUsernameAsync(User.GetUserName());
                    if (user == null) return NotFound();
                    var result = await _photoService.AppPhotoAsync(file);
                    if(result.Error != null) return BadRequest(result.Error.Message);
                    var photo = new Photo
                    {
                        Url = result.SecureUrl.AbsoluteUri,
                        PublicId = result.PublicId
                    };

                    if (user.Photos.Count == 0) photo.IsMain = true;

                    user.Photos.Add(photo);
                    
                    if(await _userRepository.SaveALlAsync()) return _mapper.Map<PhotoDTO>(photo);

                    return BadRequest("Problem Adding Photo");
                }

    Testing the photo upload:
        ran into image upload error:
            hadd to install the standalone postman client to get it access to my local drive and all is 
            
        postman > teboraw > photos upload and delete test > Add photo 
            set the body > file value to a local picture and watch teh magic

        Quick not the key value is called File and that should match with what the parameter is called and spelled as in the :
            user controller > addPhoto > IFormFile file

    Return the right response for post request that creates a new resource:
        SHould return ideally a 201 response instead of 200ok response 
        this will have a location url response with the new content.
        usercontroller:
        //need to return a 201 response instead of 200 with new resource url not this way 
            //if(await _userRepository.SaveALlAsync()) return _mapper.Map<PhotoDTO>(photo);
            //This way below create a action or enpoint utl to the getuser endpoint passing in the username as an object 
            //along with the mapped photo
            if(await _userRepository.SaveALlAsync())
                return CreatedAtAction(nameof(GetUser), 
                    new { username = user.UserName }, 
                    _mapper.Map<PhotoDTO>(photo));

        retest the endpoint in postman and you will see an additiona field in the header returns with 
        location : https://localhost:5001/api/Users/lisa 
        along with a 201 reponse


    Adding the phot upload component to angular:
        ng cli:
            ng g c member/photo-editor

            html:
                <div class="row" *ngIf="member">
                    <div class="col-2" *ngFor="let photo of member.photos">
                        <img src="{{photo.url}}" alt="photo of user" class="img-thumbnail mb-1">
                        <div class="text-center">
                        <button class="btn btn-sm">Main</button>
                        <button class="btn btn-sm btn-danger"><i class="fa fa-trash"></i></button>
                        </div>
                    </div>
                </div>


        add the compoennt to the edit component tab:
            <tab heading="Edit Photos">
                <app-photo-editor [member]="member"></app-photo-editor>
            </tab>

    Create photo upload:
        need to install the file uploader util 
        ng2-file-upload
            https://valor-software.com/ng2-file-upload/

        npm install:
            npm install ng2-file-upload --save
            what do you know it dont work for 17 fudger

            I used the following, which ties it to the version you otherwise have installed (so you don't have to muck with the versions manually over time). Thanks for the tip!
        package.json add
            "overrides": {
                "ng2-file-upload": {
                "@angular/common": "$@angular/common",
                "@angular/core": "$@angular/core"
                }
            }

        Then cli install:
            npm install ng2-file-upload --save


        copy the ng2 file boiler plate 
            to the photo editor

        Add the file uploader module to the share modules:
            import and export FileUploadModule

        photoeditor component ts: 
            quite alot going on here not sure what everything is dpoing will need to review later:
                export class PhotoEditorComponent implements OnInit{
                    @Input() member: Member | undefined
                    uploader : FileUploader | undefined
                    hasBaseDropzoneOver = false
                    baseUrl = environment.apiUrl
                    user: User |undefined
                    constructor(private accountService: AccountService) {
                        this.accountService.currentUser$.pipe(take(1)).subscribe({
                        next: user=>{
                            if(user) this.user = user
                        }
                        })
                    }

                    ngOnInit() {
                        this.initializeUploader()
                    }

                    fileOverBase(e: any){
                        this.hasBaseDropzoneOver = e;
                    }
                    initializeUploader(){
                        this.uploader = new FileUploader({
                        url: this.baseUrl + 'users/add-photo',
                        authToken: 'Bearer ' + this.user?.token,
                        isHTML5: true,
                        allowedFileType: ['image'],
                        removeAfterUpload: true,
                        autoUpload: false,
                        maxFileSize: 10 * 1024 *1024
                        })
                        this.uploader.onAfterAddingFile = (file) => {
                        file.withCredentials = false
                        }

                        this.uploader.onSuccessItem = (item, response, status, headers){
                        if(response){
                            const photo = JSON.parse(response)
                            this.member?.photos.push(photo)
                        }
                        }
                    }
                }

        Adjust the html and type checks:
            way too much code to really copy and paste byt 
            photoeditor was modified to pull the boiler and add optionals to potential nulls and delete the extra progress bars and info to fit on tab 
            styling added to allow file drag to highlight the upload box 

        Allow selection of main photo:
            create a endpoint in th euser controller to set main photo:
                quite a bit of null checking here 
                [HttpPut("set-main-photo/{photoId}")]
                public async Task<ActionResult> SetMainPhoto(int photoId)
                {
                    var user = await _userRepository.GetUserByUsernameAsync(User.GetUserName());
                    
                    if(user == null) return NotFound();
                    
                    var photo = user.Photos.FirstOrDefault(x => x.Id == photoId);
                    
                    if(photo == null) return NotFound();
                    
                    if (photo.IsMain) return BadRequest("This is already the main photo!");
                    
                    var currentMain = user.Photos.FirstOrDefault(x => x.IsMain);

                    if (currentMain != null) currentMain.IsMain = false;
                    photo.IsMain = true;
                    
                    if(await _userRepository.SaveALlAsync()) return NoContent();

                    return BadRequest("There was a problem setting the main photo");
                }

            postman is happy 

        Now to set the ui to allow for main photo setting:
            add the photo to the navebar:
                need to apply the photo url of the main photo to the userDto Object:
                    public string PhotoUrl { get; set; }
                return this value with the account contorller getuser endpoint:
                    return new UserDTO()
                    {
                        Username = user.UserName,
                        Token = _tokenService.CreateToken(user),
                        PhotoUrl = user.Photos.Include(p => p.Photos).FirstOrDefault(x => x.IsMain)?.Url
                    };
                add prop to user ts as well 
                    export interface User {
                        username: string;
                        token: string;
                        photoUrl: string;
                    }
            refactor the current user local storage call in account services

            in the navbar.htm set the now availble image url to the user:
                add image tage to the user dropdown
                    <img src="{{user.photoUrl}}" alt="user photo">
                add a bit of styling 
                    img{
                        max-height: 50px;
                        border: 2px solid white;
                        display: inline;
                    }

            Amake sure to include the photos otherwize ef will be lazy and not load it on th elogin call

            now to allow the user to set a main:
                update the mmebr service to hit the update main photo endpoint:
                    setMainPhoto(photId: number){
                        return this.http.put(this.baseUrl + 'users/set-main-photo/' + photId, {})
                    }
                photo.editor.ts 
                    setMainPhoto(photo: Photo){
                        this.memberService.setMainPhoto(photo.id).subscribe({
                        next: () => {
                            if(this.user && this.member){
                            this.user.photoUrl = photo.url
                            // this will broadcas the phot update to all the subscribers ie the nave bar n such
                            this.accountService.setCurrentUser(this.user)
                            this.member.photoUrl = photo.url
                            this.member.photos.forEach(p => {
                                if(p.isMain) p.isMain = false
                                if(p.id === photo.id) p.isMain = true;
                            })
                            }
                        }
                        })
                    }

                photo.editor.html:
                //this code will disable the set main button if already main 
                // and change styling based on if its main or not
                    <button
                        class="btn btn-sm"
                        [disabled]="photo.isMain"
                        (click)="setMainPhoto(photo)"
                        [ngClass]="photo.isMain ? 'btn-success active' : 'btn-outline-success'"
                    >Main</button>


        Deleting Photos:
            add api ep in userController:
                [HttpDelete("delete-photo/{photoId}")]
                public async Task<ActionResult> DeletePhoto(int photoId)
                {
                    var user = await _userRepository.GetUserByUsernameAsync(User.GetUserName());

                    var photo = user.Photos.FirstOrDefault(x => x.Id == photoId);
                    
                    if(photo == null) return NotFound();
                    
                    if(photo.IsMain) return BadRequest("You cannot delete your main photo.");
                    
                    if(photo.PublicId != null)
                    {
                        var result = await _photoService.DeletePhotoAsync(photo.PublicId);
                        if(result.Error != null) return BadRequest(result.Error.Message);
                    }

                    user.Photos.Remove(photo);
                    
                    if(await _userRepository.SaveALlAsync()) return Ok();

                    return BadRequest("Problem Deleting Photo");
                }
            add member service method to delete the photo:
                deletePhoto(photoId:number){
                    return this.http.delete(this.baseUrl + 'users/delete-photo/' + photoId)
                }

            Call the delete phot service from the photo editor:
                deletePhoto(photoId:number){
                    this.memberService.deletePhoto(photoId).subscribe({
                    next: _ => {
                        if(this.member){
                        //this createed the member photo list with all photos but the one being deleted
                        this.member.photos = this.member.photos.filter(x => x.id != photoId)
                        }
                    }
                })
                                
            wire up the html template: 
                  <button
                        class="btn btn-sm btn-danger"
                        [disabled]="photo.isMain"
                        (click)="deletePhoto(photo.id)"
                    ><i class="fa fa-trash"></i></button>
        done diggity delete works yo!!!