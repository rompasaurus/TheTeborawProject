This document is intend to be a snapshot of what I am doing and learning each time I make progress towards Teboarw development with its primary focus being on the Dotnet API back bone of the application.

Currently I am progreessing through some tutorial videos and msft documentation in hopes to get a better ground of the ms dev environment and the best way to get an api in place that also handles authentication

Jan 18 2024:
    Began Udemy coursework going from scaatch and creating an angular/ c# web application 

    Build an app with ASPNET Core and Angular from scratch Notes:

        Dotnet CLI Commands:
            dotnet --info
                will show which sdks and runtimes are available to use and dev against and run dlls against
                    Example output: 
                        Runtime Environment:
                        OS Name:     Mac OS X
                        OS Version:  14.2
                        OS Platform: Darwin
                        RID:         osx-arm64
                        Base Path:   /usr/local/share/dotnet/sdk/8.0.100/

                        .NET workloads installed:
                        Workload version: 8.0.100-manifests.6c33ef20
                        There are no installed workloads to display.

                        Host:
                        Version:      8.0.0
                        Architecture: arm64
                        Commit:       5535e31a71

                        .NET SDKs installed:
                        6.0.414 [/usr/local/share/dotnet/sdk]
                        6.0.416 [/usr/local/share/dotnet/sdk]
                        6.0.417 [/usr/local/share/dotnet/sdk]
                        7.0.308 [/usr/local/share/dotnet/sdk]
                        7.0.310 [/usr/local/share/dotnet/sdk]
                        7.0.311 [/usr/local/share/dotnet/sdk]
                        8.0.100 [/usr/local/share/dotnet/sdk]

                        .NET runtimes installed:
                        Microsoft.AspNetCore.App 6.0.22 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 6.0.24 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.11 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.13 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
                        Microsoft.NETCore.App 6.0.22 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 6.0.24 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.11 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.13 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
                        Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]

            dotnet -h 

            
                output all the available commands 
                outpu:
                    Execute a .NET SDK command.
                    sdk-options:
                    -d|--diagnostics  Enable diagnostic output.
                    -h|--help         Show command line help.
                    --info            Display .NET information.
                    --list-runtimes   Display the installed runtimes.
                    --list-sdks       Display the installed SDKs.
                    --version         Display .NET SDK version in use.

                    SDK commands:
                    add               Add a package or reference to a .NET project.
                    build             Build a .NET project.
                    build-server      Interact with servers started by a build.
                    clean             Clean build outputs of a .NET project.
                    format            Apply style preferences to a project or solution.
                    help              Show command line help.
                    list              List project references of a .NET project.
                    msbuild           Run Microsoft Build Engine (MSBuild) commands.
                    new               Create a new .NET project or file.
                    nuget             Provides additional NuGet commands.
                    pack              Create a NuGet package.
                    publish           Publish a .NET project for deployment.
                    remove            Remove a package or reference from a .NET project.
                    restore           Restore dependencies specified in a .NET project.
                    run               Build and run a .NET project output.
                    sdk               Manage .NET SDK installation.
                    sln               Modify Visual Studio solution files.
                    store             Store the specified assemblies in the runtime package store.
                    test              Run unit tests using the test runner specified in a .NET project.
                    tool              Install or manage tools that extend the .NET experience.
                    vstest            Run Microsoft Test Engine (VSTest) commands.
                    workload          Manage optional workloads.

                    Additional commands from bundled tools:
                    dev-certs         Create and manage development certificates.
                    fsi               Start F# Interactive / execute F# scripts.
                    user-jwts         Manage JSON Web Tokens in development.
                    user-secrets      Manage development user secrets.
                    watch             Start a file watcher that runs a command when files change.

            dotnet new -h 
                lists what you can do with the new command 
                output:
                    Usage:
                    dotnet new [<template-short-name> [<template-args>...]] [options]
                    dotnet new [command] [options]

                    Arguments:
                    <template-short-name>  A short name of the template to create.
                    <template-args>        Template specific options to use.

                    Options:
                    -o, --output <output>    Location to place the generated output.
                    -n, --name <name>        The name for the output being created. If no name is specified, the name of the output directory is used.
                    --dry-run                Displays a summary of what would happen if the given command line were run if it would result in a template creation.
                    --force                  Forces content to be generated even if it would change existing files.
                    --no-update-check        Disables checking for the template package updates when instantiating a template.
                    --project <project>      The project that should be used for context evaluation.
                    -v, --verbosity <LEVEL>  Sets the verbosity level. Allowed values are q[uiet], m[inimal], n[ormal], and diag[nostic]. [default: normal]
                    -d, --diagnostics        Enables diagnostic output.
                    -?, -h, --help           Show command line help.

                    Commands:
                    create <template-short-name> <template-args>  Instantiates a template with given short name. An alias of 'dotnet new <template name>'.
                    install <package>                             Installs a template package.
                    uninstall <package>                           Uninstalls a template package.
                    update                                        Checks the currently installed template packages for update, and install the updates.
                    search <template-name>                        Searches for the templates on NuGet.org.
                    list <template-name>                          Lists templates containing the specified template name. If no name is specified, lists all templates.
                    details <package-identifier>                  Provides the details for specified template package.
                                                                        The command checks if the package is installed locally, if it was not found, it searches the configured NuGet feeds.

            dotnet new list
                lists all the templates available to create projects 
                output:
                    Template Name                                 Short Name                  Language    Tags                            
                    --------------------------------------------  --------------------------  ----------  --------------------------------
                    API Controller                                apicontroller               [C#]        Web/ASP.NET                     
                    ASP.NET Core Empty                            web                         [C#],F#     Web/Empty                       
                    ASP.NET Core gRPC Service                     grpc                        [C#]        Web/gRPC/API/Service            
                    ASP.NET Core Web API                          webapi                      [C#],F#     Web/WebAPI/Web API/API/Service  
                    ASP.NET Core Web API (native AOT)             webapiaot                   [C#]        Web/Web API/API/Service         
                    ASP.NET Core Web App (Model-View-Controller)  mvc                         [C#],F#     Web/MVC                         
                    ASP.NET Core Web App (Razor Pages)            webapp,razor                [C#]        Web/MVC/Razor Pages             
                    ASP.NET Core with Angular                     angular                     [C#]        Web/MVC/SPA                     
                    ASP.NET Core with React.js                    react                       [C#]        Web/MVC/SPA                     
                    Blazor Server App                             blazorserver                [C#]        Web/Blazor                      
                    Blazor Server App Empty                       blazorserver-empty          [C#]        Web/Blazor/Empty                
                    Blazor Web App                                blazor                      [C#]        Web/Blazor/WebAssembly          
                    Blazor WebAssembly App Empty                  blazorwasm-empty            [C#]        Web/Blazor/WebAssembly/PWA/Empty
                    Blazor WebAssembly Standalone App             blazorwasm                  [C#]        Web/Blazor/WebAssembly/PWA      
                    Class Library                                 classlib                    [C#],F#,VB  Common/Library                  
                    Console App                                   console                     [C#],F#,VB  Common/Console                  
                    dotnet gitignore file                         gitignore,.gitignore                    Config                          
                    Dotnet local tool manifest file               tool-manifest                           Config                          
                    EditorConfig file                             editorconfig,.editorconfig              Config                          
                    global.json file                              globaljson,global.json                  Config                          
                    MSBuild Directory.Build.props file            buildprops                              MSBuild/props                   
                    MSBuild Directory.Build.targets file          buildtargets                            MSBuild/props                   
                    MSTest Playwright Test Project                mstest-playwright           [C#]        Test/MSTest/Playwright          
                    MSTest Test Project                           mstest                      [C#],F#,VB  Test/MSTest                     
                    MVC Controller                                mvccontroller               [C#]        Web/ASP.NET                     
                    MVC ViewImports                               viewimports                 [C#]        Web/ASP.NET                     
                    MVC ViewStart                                 viewstart                   [C#]        Web/ASP.NET                     
                    NuGet Config                                  nugetconfig,nuget.config                Config                          
                    NUnit 3 Test Item                             nunit-test                  [C#],F#,VB  Test/NUnit                      
                    NUnit 3 Test Project                          nunit                       [C#],F#,VB  Test/NUnit                      
                    NUnit Playwright Test Project                 nunit-playwright            [C#]        Test/NUnit/Playwright           
                    Protocol Buffer File                          proto                                   Web/gRPC                        
                    Razor Class Library                           razorclasslib               [C#]        Web/Razor/Library               
                    Razor Component                               razorcomponent              [C#]        Web/ASP.NET                     
                    Razor Page                                    page                        [C#]        Web/ASP.NET                     
                    Razor View                                    view                        [C#]        Web/ASP.NET                     
                    Solution File                                 sln,solution                            Solution                        
                    Web Config                                    webconfig                               Config                          
                    Worker Service                                worker                      [C#],F#     Common/Worker/Web               
                    xUnit Test Project                            xunit                       [C#],F#,VB  Test/xUnit   

            dotnet new sln
                created a new sln file with the director name if none specified

            dotnet new webapi -n TeborawAPI
                creates a new api project in the solution directory and pull in the default templated files courtesy of msfy 

            dotnet sln -h 
                list all commands available to use on the soution 

            dotnet sln add TeborawAPI 
                Adds the Templated Project to the solutions file 

            code .
                if no command found open vs code cmd shift + p and type shell in the search box and select the option to instal the code shell utility 
                will open the containing folder in vscode 

            code color highlight were not working:
                THe code them dark was at fault 
                cmd shift + p and changed them to dark + isntead voila 

            dotnet run:
                from the api proj directory if you run this command it will compile and run the template projcect
                output:
                    Building...
                    info: Microsoft.Hosting.Lifetime[14]
                        Now listening on: http://localhost:5224
                    info: Microsoft.Hosting.Lifetime[0]
                        Application started. Press Ctrl+C to shut down.
                    info: Microsoft.Hosting.Lifetime[0]
                        Hosting environment: Development
                    info: Microsoft.Hosting.Lifetime[0]
                        Content root path: /Users/rompasaurus/TeborawWebApp/TeborawAPI

            http://localhost:5224/swagger
                takes you to the swagger endpoint which should show all available api enpoints in dev mode of course

            port and url mappings:
                Held within the launchsettigns.json
                
                adjusted http launch settings to allow https and http specifying port 5000
                  "profiles": {
                    "http": {
                    "commandName": "Project",
                    "dotnetRunMessages": true,
                    "launchBrowser": true,
                    "launchUrl": "swagger",
                    "applicationUrl": "http://localhost:5000;https://localhost:5001",
                    "environmentVariables": {
                        "ASPNETCORE_ENVIRONMENT": "Development"
                    }
                },


            dotnet watch:
                runs your .net application with hot reloading checking for file updates and auto pushing if available
                will log those events as well 

Jan 19 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        https certificates:
            Are issue typically by default with the dotnet sdk if not trusted by browser run 
            dotnet dev-certs https --trust 
            clean than trust if not work 
            dotnet dev-certs https --clean 
            dotnet dev-certs https --trust 

        get debugs to be more verbose 
        appsettings.development.json > set Loglevel > default to onformational

        installed the entity framework and postgres entity drivers 
            had to install the nuget package manager and library 

        Double check the namespace when you make a new class or file ensure the namespace follows:
            projectname.folder 

        cmd + p > quickest way to open a file in vscode 

        created dbContext with the AppUser to start and DI'd via the program.cs

        builder.Services.AddDbContext<DataContext>(opts =>
        {
            opts.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"));
        });
        create DefaultConnection in appsettings.json 
              "ConnectionStrings": {
                    //Postgres docker db  
                    "DefaultConnection": "Server=localhost; Port=5432; Database=Teboraw; Username=Teboraw; Password =Bigmac12!;TrustServerCertificate=true"
                }
        Going to need to obfuscate these creds eventually 

        Create first migration -> dotnet ef cli tools need to be installed first 
            command:
                dotnet tool install --global dotnet-ef

                dotnet ef -h
                    help options for ef and commands available 

                dotnet ef migrations add InitialCreate -o Data/Migrations
                    creates the first migration pack and scripts 

                dotnet tool -list
                    shows all dn tools available including ef cli 

                dotnet ef database update 
                    applies all migrations existing and unapplied
                    applies the table and you should be able to view newly create column and db via connecor (datagrip)

                Creeated a users controller:
                    namespace TeborawAPI.Controllers;
                        [ApiController]
                        [Route("api/[controller]")] // /api/users
                        public class UsersController : ControllerBase
                        {
                            private readonly DataContext context;

                            public UsersController(DataContext context)
                            {
                                this.context = context;
                            }
                        }
            
        Routing error The routes dont get mapped without this ffs:
            added this to the startup.cs and all is well 
            app.MapControllerRoute(
                name: "default",
                pattern: "{controller}/{action=Index}/{id?}");

        Asynchronous api operations:
            public async Task 
            ex:     public async Task<ActionResult<AppUser>> GetUser(int id)
            allows the api server to pass this query to a delegate and handle other requests while sql retrieves
            make sure to await the return call to allow the function to be delegated 
                examle var users = await _context.Users.ToListAsync();

Jan 20 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        Starting with angulare install the node cli along with angular cli gonna go with angular 17 instead of 16 

        npm install -g @angular/cli

        ng version:
            will show you the install angualr version number along with node version as well
        
        Create angular application 
        ng new client 
            css styling select and 
            enable Server-Side Rendering (SSR) to allow for better web anayitics and google search availability
            this didnt have all the features i needed including routing and app module template had to use 
            ng new client --no-standalone --routing --ssr=true

        running angular template app 
            cd into template folder 
            command: 
                ng serve

            index.html is the starting page for the angular > which then cascades and loads the <app-root></app-root> which a component named app.compoennt.html/ts

        ctr + p allow quick open of a file 

        wire up angular to hit controller endpoint
            import the httpclienmodule in app.module 
              imports: [
                    BrowserModule,
                    AppRoutingModule,
                    HttpClientModule
                ],
        Slap that httpmodule into a component 
            via DI in the conststructor 
                constructor(private http: HttpClient){}
            extend componet class from OnInit to add a lifecycle step
            implement oninit method and try out a quick http get pull 
                this.http.get('https://localhost:5001/api/users').subscribe({
                    next: response => this.users = response,
                    error: error => console.log("Failed to pull user data error: ", error),
                    complete: () => console.log('User Request Completed! ')
                })
            make sure api is running > dotnet watch 
            gonna invariably get a cors cross site rejection error need to setup dotnet to allow specified origins to pull from api

        Addressing cors errors 
            is done on the api side add a header to the response that allow angular to trust data 
            program.cs 
                add the cors service 
                Code:
                    builder.Services.AddCors();
                
                create the middleware to inject the cors headers prior to sending back a response 
                add code just before the mapCOntroller call
                Code:
                    app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200"));

                request completes succ you can check the data passed back via 
                debug > network tab > click users form name list > preview tab to view data 
                [
                    {
                        "id": 2,
                        "userName": "Bob"
                    },
                    {
                        "id": 3,
                        "userName": "Tom"
                    },
                    {
                        "id": 4,
                        "userName": "Jane"
                    }
                ]

                quick angular tip just type the html tag name without the <> and you can add a class by adding .class name and then tab to auto create the html element 
                ie:
                    ul.ulClass name > turns into <ul class="ulClassNmae"></ul>

                add users to page and iterate over all users 
                    <li class="bold" *ngFor="let user of users">
                        {{user.id}} - {{user.userName}}
                    </li>
                    *ngFor is the key thing to not allows you iterate of a list of objects
                    FYI > .net api calls return json data with camelcasing by default 
                        userName insteaed of username 
                
        Add Bootstrap Styling 
            that has angular implementations
            ngx-bootstrap
            https://valor-software.com/ngx-bootstrap/#/
            cli command: 
                    ng add ngx-bootstrap
                received erro auto way went manual way instead 
                    npm install ngx-bootstrap --save
                imported the module manually
                added bootstrap.css 
                angular.json:
                    "styles": [
                        "src/styles.css",
                        "./node_modules/font-awesome/css/font-awesome.css",
                        "./node_modules/bootstrap/dist/css/bootstrap.min.css"
                        ],
                update app.module with:
                imported module via app.module 
                    mport { TooltipModule } from 'ngx-bootstrap/tooltip';
                    imports: [ TooltipModule.forRoot(), BrowserAnimationsModule]

                package.json should have entry for 
                    "ngx-bootstrap": "^12.0.0",
            install fontawesome 
                npm install fontawesome


        Error Port 4200 is already in use.:
            sudo kill -9 $(sudo lsof -t -i:4200) 
            to kill rogue angular app


Jan 21 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
        Add ssl and certs to angular application:

    install mkcert:
        https://github.com/FiloSottile/mkcert
        brew install mkcert
        brew install nss # if you use Firefox   

    make ssl directory in the client folder
        mkdir ssl

    install the cert authority from the ssl directory 
        mkcert -install 

    Create the certificate for localhost for now domain later 
        mkcert localhost

        creates both a publich and private key for specified domain (localhost)

    Wire in cert to angular.json
        inside of "server":
        "serve": {
            "options": {
                "ssl": true,
                "sslCert": "./ssl/localhost.pem"
                "sslKey": "./ssl/localhost-key.pem"
            },
        restart angular app and site should auto redirect to https with a trusted cert 
        be aware this is a self signed certificate 

    fix cors to allow  
        ssl error:
            Access to XMLHttpRequest at 'https://localhost:5001/api/users' from origin 'https://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
       
        with the cert you will need to update the api to allow ssl connections 

        change: 
        app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200"));
        to ->
        app.UseCors(cPolicyBuilder => cPolicyBuilder.AllowAnyHeader().AllowAnyMethod().WithOrigins("https://localhost:4200"));

    AUTHENTICATION BABY!!
        Learning Objectives 
            how to store pw's in db hint as a hash with a salt string to randomize the hash a bit 
            using inheritance 
            validation 
            json web tokens 
            c# services 

        add byte arrays props to the user class 
                public Byte PasswordHash { get; set; }
                public Byte PasswordSalt { get; set; }

        Create a migration to update the table entry
            Create migrations via command:
                dotnet ef migrations add UserPasswordAdded
            Update database 
                dotnet ef database update

        Create BaseAPiCOntroller to simplify and not repeat the route and api declarations 
            create the class then inherit from it ex:
                public class UsersController : BaseAPIController

        create an accounts controller to allow for user registration with a passwor dand setup hashing:
            public class AccountsController: BaseAPIController
            using var hmac = new HMACSHA3_512();
            ##Using keyword allows for the hmac object to be disposed of after use
            any classes that implement the idisposable method need a dispose() call to be initated
            using limits the scope of the variable to the function intantiate within and auto displose upon execution

        postman usage:
            you can set a url variable globally to use ion all you endpoint tests via:
                select main project in the collention and go to the variabl tab on the main page add a :
                    url variabl with intial value https://localhost:5001

                can inject into a endpoint test via formulating url as :
                    {{url}}/api/account/register

            parameters need to be passed via query string 
                Example
                Register(string username, string password)
                need to be request via 
                /api/register?username=examplname&password=expassword

        register error
            selected wrong sha crypto  full function for ref:
                [HttpPost("register")] // api/account/register
                public async Task<ActionResult<AppUser>> Register(string username, string password)
                {
                    using var hmac = new HMACSHA512();
                    var user = new AppUser()
                    {
                        UserName = username,
                        PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password)),
                        PasswordSalt = hmac.Key
                    };
                    _context.Users.Add(user);
                    await _context.SaveChangesAsync();
                    return user;
                }

        Adding dto's and validations 
            create dir dtos and add reigsterdto 
            public class RegisterDTO
            {
                public string Username { get; set; }
                public string Password { get; set; }
            }
            json sends in lower case for properties, dtop with upper case begins still bind as lowercase in json 
        
        Validate username and pw is not empty
            validation ad the db level
                add the [Required] decorator to the entitity data model 
                    [Required]
                    public string UserName {get; set;}
                you have to create a new migration to establish this change 
            
            At the dto level server side:
                add same required decorator to the sdt example:
                    public class RegisterDTO
                    {
                        [Required]
                        public string Username { get; set; }
                        [Required]
                        public string Password { get; set; }
                    }
                get a nice error whe passing in a blank user or pw 

                    "title": "One or more validation errors occurred.",
                    "status": 400,
                    "errors": {
                        "Password": [
                            "The Password field is required."
                        ],
                        "Username": [
                            "The Username field is required."
                        ]
                    },
                [ApiController]
                decorator enables this validation to occur on the Controllers
                without this decorator it wont do these checks and [fromBody] would need to be added to the controllers endpoint for it to map properly to a specified dto object
                this decorator automatically checks the model state that is establish when the endpoint is reached and dtop ios mapped 

        Setup login endpoint:  
            see code, validation for user and pass in place and hash compute and varification established here
                [HttpPost("login")]
                public async Task<ActionResult<AppUser>> Login(LoginDTO loginDTO)
                {
                    var user = await _context.Users.FirstOrDefaultAsync(u => u.UserName.ToLower() == loginDTO.Username.ToLower());
                    
                    if (user == null) return Unauthorized("Invalid Username");
                    //validate password by reversing the hash algo 
                    using var hmac = new HMACSHA512(user.PasswordSalt);
                    //pull the compute hash of user imput pw  
                    var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(loginDTO.Password));

                    for (int i = 0; i < computedHash.Length; i++)
                    {
                        if (computedHash[i] != user.PasswordHash[i]) return Unauthorized("Invalid password");
                    }
                    
                    return user;

                }

        JWT > JSON Web Tokens 
            Structure 3 parts
                Header contains algo and tokent type: 
                    {
                        "alg": "HS512",
                        "typ": "JWT"
                    }
                Payload Data
                    {
                        "nameid" : "lola"
                        "role" : "Member"
                        //time stamps for expiry dates of key and session nbf i the the time at wich token cannot be used before 
                        "nbf": 134653462,
                        "exp": 136345645,
                        "iat": 246357357,
                    }
                Verify Signature 
                    HMACSHA512(
                        base64UrlEncode(header) + "." +
                        base64UrlEncode(paylod),
                        your-256-secret
                    ) secret base64 encoded 

            Stages of auth 
                1 user logs in passing in username and password
                2 server receives login data and validates that password 
                3 server returns a token in respons if user is authenticate 
                4 client/user receives the jwt in response and stores locally passing the token back with each http subsequent http requests
                the request are sent with an additional authentication header portion
                5 the server then upon request uses the jwt header and validates with that key instead of the user needing to submit pw         information each time  

            JWT Beneftis:
                no session to manage jwts are self contained tokens 
                portable:  a single token can be used with multiplpe backends 
                no cookies required, mobile firendly as phone dont use cookies 
                performance once token established no need for more db calls to validate user auth 

            Token Service Creation:
                create the token interface 
                    public interface ITokenService
                    {
                        string CreateToken(AppUser user);
                    }
                Create the service that built using the interface 
                    public class TokenService: ITokenService
                    {
                        public string CreateToken(AppUser user)
                        {
                            throw new NotImplementedException();
                        }
                    }
                Imject the service to the program.cs 
                    builder.services.
                        AddTransient:
                            A very short lived service whose lifecycle is just for the duration of its call and use then it is dsipose 
                        AddScope: the standard 
                            A longer living service that lasts the duration of the https request meaning a specific controller call 
                        AddSingleton:
                            A service is instantiated once upon itself at the start of the api program launch and is never disposed ofbut only one instance exists typically better to dsipose after use to free memory especially with services are not need on a constant basis.
                            caching services typicall fall under this use case for quick data retrieval

                    Code: 
                    builder.Services.AddScoped<ITokenService, TokenService>();

                Build out service using config key:
                    creating a service as an interface will help later with testing 

                    Install System.IdentityModel.Tokens.Jwt by Microsoft
                        alolows you to establish a secret key for signing jwts tokens 

                    public class TokenService: ITokenService
                    {
                        private readonly SymmetricSecurityKey _key;
                        
                        public TokenService(IConfiguration config)
                        {
                            _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["TokenKey"]));
                        }
                        public string CreateToken(AppUser user)
                        {
                            // Add the users claimset, need to atleast have a username or id identifier further claims will be added later once funcitionailty requiring it is established
                            var claims = new List<Claim>()
                            {
                                new Claim(JwtRegisteredClaimNames.NameId, user.UserName),
                            };
                            //Establish the highest sha 512 ecryption key generation for token signature 
                            var credentials = new SigningCredentials(_key, SecurityAlgorithms.HmacSha512Signature);
                            //Set expiry and issuance dates along with claims
                            var tokenDescriptor = new SecurityTokenDescriptor()
                            {
                                Subject = new ClaimsIdentity(claims),
                                Expires = DateTime.Now.AddDays(7),
                                SigningCredentials = credentials
                            };

                            var tokenHandler = new JwtSecurityTokenHandler();
                            var token = tokenHandler.CreateToken(tokenDescriptor);
                            //using System.IdentityModel.Tokens.Jwt; takes provided token details and establishes a properly formatted jwt token 
                            return tokenHandler.WriteToken(token);
                        }
                    }

            Establish a dto for user and associated jwt
                public class UserDTO
                {
                    public string Username { get; set; }
                    public string Token { get; set; }

                }

            inject the Itoken service to the controller 
                private readonly ITokenService _tokenService;

                public AccountController(DataContext context, ITokenService tokenService)
                {
                    _context = context;
                    _tokenService = tokenService;
                }
            replace everywhen in the accountcontroller a user is return and return instead a userDTO with a generated token 
                return new UserDTO()
                {
                    Username = user.UserName,
                    Token = _tokenService.CreateToken(user)
                };
            Create you token key secret but just for development for now in appsettings.json.developmen
                {
                    "Logging": {
                        "LogLevel": {
                        "Default": "Information",
                        "Microsoft.AspNetCore": "Information"
                        }
                    },
                    "TokenKey": "dontevenbothertryingtoguessthiscuzyoucantitssosecretandifyoutellanyoneillkillyou"
                }
            rebuild code and  login endpoint upon successful login should return username and the token 
            example response :
                {
                    "username": "dildo",
                    "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJkaWxkbyIsIm5iZiI6MTcwNTg2MzY3N
                }iwiZXhwIjoxNzA2NDY4NDc2LCJpYXQiOjE3MDU4NjM2NzZ9.YJJKK9j0QOzuXW421ejToDOOKsqzH2Qr2I49odh0vTOUUeHBRBLWRl2wNkJ9THElLRjbmQs_hMnbkWZCWKl5mQ"

            
        How to peak inside a token block:
            jwt.ms > go to this site 
            heres example output
                paste the token here 
                {
                    "alg": "HS512",
                    "typ": "JWT"
                }.{
                    "nameid": "dildo",
                    "nbf": 1705863676,
                    "exp": 1706468476,
                    "iat": 1705863676
                }.[Signature]

        Authorize the routes:
            add the decorator to the routes in the controller 
            [Authorize] either on the route or on the controller as a whole

            need to then plug in the middleware that routes the authorize right to execute the routes
            
        Setup Authorize middleware for jwt bearer tokens 
            install nuget package Microsoft.AspNetCore.Authentication.JwtBearer by Microsoft 8.00
            Program.cs
            //The location of these need to be after cors establishment but prior to route and controller mapping 
            // Are you who you say you are 
            app.UseAuthentication();
            // What are you allowed to do
            app.UseAuthorization();
            also 
                app.UseHttpsRedirection();
                app.UseStaticFiles();
                app.UseRouting();
                needs to be setup prior to auth establishment in progrma.cs

        Test the route:
            Get the token from the login route 
            then use that toke value to add to get request to the users list route in postman 

            add key: Authorization
                value: Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJkaWxkbyIsIm5iZiI6MTcwNTg2NjMyNSwiZXhwIjoxNzA2NDcxMTI1LCJpYXQiOjE3MDU4NjYzMjV9.JQV2KIRmL7DL1JL9565ankWKKBMfHU31dWiAyp8tbo6_861tPDAAdr6SftrEN-a9dtsUqcRxbEUdy1-rNxKeGw"
            
            bear <spce> token
            the space is critical 

            or just go to the authorization tab at the top in postmat on the route and paste in the token optain from the login response /api/login with succ login 

        Adding extension methods and cleanup program.cs 

            public static class IdentityServiceExtensions
            {
                public static IServiceCollection AddIdentityServices(this IServiceCollection services, IConfiguration config)
                {
                    // Middleware to tie into the [Authorize] Routes called to validate jwt issuance nonexpiry and user
                    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                        .AddJwtBearer(opts =>
                        {
                            opts.TokenValidationParameters = new TokenValidationParameters
                            {
                                ValidateIssuerSigningKey = true,
                                IssuerSigningKey = new SymmetricSecurityKey(Encoding
                                    .UTF8.GetBytes(config["TokenKey"])),
                                ValidateIssuer = false,
                                ValidateAudience = false
                            };
                        });
                    return services;
                }
            }

            use this in the program.cs with the new extensions 
            builder.Services.AddApplicationsServices(builder.Configuration);
            builder.Services.AddIdentityServices(builder.Configuration);

January 24 2024:
    Back at it after a 3 day hiatus ready to get the next section down

    Build an app with ASPNET Core and Angular from scratch Notes:
    
    Section 2 Client login and register:
    Angular CLient work

    Commands:
        Create an angular component:
            ng generate component nav 
            shorthand command:
            ng g c nave
                This will create a set of 4 files the html, css, ts and spec.ts test file 
                and will place in the current directory creating a folder name nav

        Angular dry run to see what generates:
            ng g c --skip-test --dry-run
                this will not produce and files just a preview of wat will be produced the no tests leavs out the spec file as well 

    Eror:
        angular doesnt work with node 21 
        source ~/.nvm/nvm.sh
        to enable nvm 
        nvm install 20 
        installs node 20 
        nvm use 20 
        switches to 20 node version 

        removed node_modules and package lock just to be reset to proper versioning

    Fixing bootstrap:
        npm install bootstrap
        npm install font-awesome 
            
            add this to style.css 
            @import '../node_modules/bootstrap/dist/css/bootstrap.min.css';
            @import '../node_modules/font-awesome/css/font-awesome.min.css';
    
    Moving the maoin page contet under nav bar:
        wrap the app component content in
        div class="container" style="margin-top: 50px;"> 

    Wire up the login form at the navbar:
        Import angular forms in app.module
        instgall angular forms 
        npm install @angular/forms --save 

        convert the form to and angular form

        create generic model form now in the nav component 
            model : any = {}
        establish login function 
            login(){}
        
        Set the bootstrap nave bar login as a form :
        <form #loginForm ="ngForm" class="d-flex">

        wire the submit buttin to the login fucntion and make ng submit
        add in (ngSubmit)="login()"  to the form 
        <form #loginForm ="ngForm" class="d-flex" (ngSubmit)="login()" autocomplete="off">

        Add the ngmoduel to the inputs to 2 way data bind 
        <input 
            name = "username"
            [(ngModel)]="model.username"
            class="form-control me-2" 
            type="search" 
            placeholder="username" 
            aria-label="Login Username">
        <input 
            name = "password"
            [(ngModel)]="model.password"
            class="form-control me-2" 
            type="search" 
            placeholder="password" 
            aria-label="Password">
        <button class="btn btn-outline-success" type="submit">Login</button>


    Creating Angular services to handle http requests:
        create folder app/_services

        ang cli generate service 
        ng g service or ng s 
        command:
            ng g s _services/account
            output: 
                CREATE src/app/_services/account.service.spec.ts (362 bytes)
                CREATE src/app/_services/account.service.ts (136 bytes)
        
        Benefits of services :
            they are retained for the lifetime of tha application 
            unlike component which are created and destro per session after use 
            good for storign state 
            services are singletons 

        init  account service.ts:
                @Injectable({
                providedIn: 'root'
            })
                export class AccountService {
                baseUrl = "https://localhot:L5001/api/"

                constructor(private http: HttpClient) { }

                login(model: any){
                    return this.http.post(this.baseUrl + 'account/login', model)
                }
            }

        Slap that service into the nave bar yo:
            constructor(private accoutService: AccountService){}

              login(){
                    this.accoutService.login(this.model).subscribe({
                    next: response => {
                        console.log(response);
                        this.loggedIn = true;
                    },
                    error: error => {
                        console.log(error)
                    }
                })
    Update ui upon login success:
        <ul class="navbar-nav me-auto mb-2 mb-lg-0" *ngIf="loggedIn">
        will show or hide nested members based upon logged in boolean value

        ngif add it and tie to loggedIn
        <form #loginForm ="ngForm" class="d-flex" (ngSubmit)="login()" autocomplete="off" *ngIf="!loggedIn">

        !!ngif comlete removes the element from the dom not just hide it
        [hidden]="loggedIn" would simply hide it 


    Getting the dropdowns to work:
        angular bootstrap 
            npm install ngx-bootstrap 

            ng add ngx-bootstrap  --component dropdowns

            the auto doesnt work in t ang 17 need to do it manualy 
            waht a pain its not that big a pain 

        Add the dropdwon directive to the form modules 
            <div class="dropdown" *ngIf="loggedIn" dropdwon>
                <a class="dropdown-toggle text-light" dropdownToggle>Welcome {{model.username}} </a>
                <div class="dropdown-menu" *dropdownMenu>
                    <a class="dropdown-item"> Edit Profile</a>
                    <a class="dropdown-item" (click)="logout()"> Logout </a>
                </div>
            </div>

    Error Dropdown does not want to show still after manual install

January 25 2024:
    Build an app with ASPNET Core and Angular from scratch Notes:
    
    Time to fix bootstrap js 
        was missing the right imports in the app.module 
            BrowserAnimationsModule,
            BsDropdownModule.forRoot(),
        getting a null error now which .. is progress
            nav.component.ts:20 ERROR NullInjectorError: R3InjectorError(_AppModule)[_BsDropdownDirective -> _BsDropdownDirective]:
            it would hel if i spelled dropdown correctly
        
        Dropdown html workin: 
        <div class="dropdown" *ngIf="loggedIn" class="dropdown" dropdown>
        <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{model.username}} </a>
        <div class="dropdown-menu" *dropdownMenu>
            <a class="dropdown-item"> Edit Profile</a>
            <a class="dropdown-item" (click)="logout()"> Logout </a>
        </div>
        </div>

        Onwards!
        its dropdown not dropdrown 

    Understanding Observables:
        Promises vs Observable 
            Promise: 
                Provides a single future value 
                not lazy will load everytime 
                can not cancel 
            Observables:
                Emits multiple values overtime can stream changes essentially
                lazy 
                able to cancel 
                can use with map filter reduce and other operators

        rxjs:
            reactive extensions for javascript 
            allows you to pipe the data from an observable and translate/transform it into a workable data format

        http subscription ->
            will return and error message if the http response is > 200-300 response range 
        
        you can make the http request a promise instead not recommended 

        Async pipe:
            example:
                <li *ngFor= 'let member of service.getMembers() | async'> {member.username}}</>
            this will auto subscribe and unsubscribe from the observable. 

    Storing user token data browser side:
        AccountService:
            if(user) localStorage.setItem('user', JSON.stringify(user));
        Creating a dtop model for user in the front end:
            create user.ts interface 
                export interface User {
                    username: string;
                    token: string;
                }
            you can now use the user object and have it mapped as the rssponse in the user service 
            you need to prime http to expect this type of respnse by declaring it as a wrapper 
                return this.http.post<User>(this.baseUrl + 'account/login', model).pipe(

    Create a user information storage observable
        to broadcast if a user is logged in. 
        Crete Observable in account service.ts:
        $ symbol in currentUser$ denotes a subscriber
            private currentUserSource = new BehaviorSubject<User | null>(null);
            currentUser$ = this.currentUserSource.asObservable();
            constructor(private http: HttpClient) { }

                note the <User | null> 
                    this allow you to set an object as 2 possible type (or more) allowing it to be decalred as a null initially without ts yelling

        Set the uyser observable at login :
            this.currentUserSource.next(user);

            setCurrentUser(user: User){
                this.currentUserSource.next(user);
            }

        inject the account service to the app.component to allow for the user and it logged in status to be globally accessable

        ! turns off typescript safety , but beware 
            ex: 
                const user: User = JSON.parse(localStorage.getItem('user')!)
            the more safe better way is:
                const userString = localStorage.getItem('user');
                if(!userString) return;
                const user: User = JSON.parse(userString);
                this.accountService.setCurrentUser(user);

        subscribe to the current user to keep up to date on whether the user is logged in or not:
            nav.component:
                getCurrentUser(){
                    this.accountService.currentUser$.subscribe({
                    next: user => this.loggedIn = !!user,
                    error: error => console.log(error)
                    })
                }
                ngOnInit(): void {
                    this.getCurrentUser();
                }
                
                !!user returns true if the user exists 

            now the user will persist accross browser refreshing and local storage in chrome shows the user and the token

        Unsubscribe to the account service:
            Subscribtions need to be canceled to avoid memory leaks 
                unless its an http request > those actually complete closing the sub 
            own observables need manages 

            convert loggedin boolean to currentUser$ observable 
            nav.component:
                currentUser$ : Observable<User | null> = of(null)
                    of(null) allow ang to init a variable that is an observable with a type of null to start with bypass the type checks 

            remove getCurrentUser with 
                ngOnInit(): void {
                    this.currentUser$ = this.accountService.currentUser$;
                }
            swap the islogged in flag on the html template with the observable instead
                *ngIf="loggedIn" -> *ngIf="currentUser$ | async"

                <div class="dropdown" *ngIf="currentUser$ | async" class="dropdown" dropdown>
                <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(currentUser$ | async)?.username}} </a>
            
            this is pointless you can just use the account service directly 

                in nav component change the accountService to public to allo for it to be access from the template
                constructor(private accountService: AccountService){}
                  to 
                constructor(public accountService: AccountService){}

                can be accessed like this now instead 
                    <div class="dropdown" *ngIf="accountService.currentUser$ | async" class="dropdown" dropdown>
                    <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(accountService.currentUser$ | async)?.username}} </a>

        Create home compoenent:
            ng g c home 
            CREATE src/app/home/home.component.css (0 bytes)
            CREATE src/app/home/home.component.html (19 bytes)
            CREATE src/app/home/home.component.spec.ts (587 bytes)
            CREATE src/app/home/home.component.ts (191 bytes)
            UPDATE src/app/app.module.ts (1019 bytes)

            create buttons to register and a toggle to show these buttons if the not logged in 

            homeComponent:
                registerMode = false;
                registerToggle(){
                    this.registerMode = !this.registerMode;
                }
            Apply the ngif toggle to buttons 
                <div class="container mt-5">
                <div *ngIf="!registerMode" style="text-align: center;">
                    <h1> Welcome yo Teboraw! The one place you need to track your thoughts</h1>
                    <p class="lead">Sign up and start journalling</p>
                    <div class="text-center">
                        <button (click)="registerToggle()" class="btn btn-primary btn-lg me-2"> Register</button>
                        <button class="btn btn-primary btn-info btn-lg">Learn More</button>
                    </div>
                </div>
                <div *ngIf="registerMode" class="container">
                    <div class="row justify-content-center">
                        <div class="col-4">
                            <p>Register FOrm GOes here</p>
                        </div>
                    </div>
                </div>
            </div>

            make sure to add the component to the main appcomponet.html page

        new error to hunt down:
            Solve ReferenceError: localStorage is not defined 
            the login box doesnt come back when user logs out 
            after my jog tomorrow this is the first thing I set to 

January 26, 2024
    Trying to address the localstorage error in the appcomponent page:
        seems ang doesnt believe the local sotrage is available,
        attempted putting the call behind a try catch block and same issue appears to occur, 
        Attemp to print the log in the console:
            and this seems to narrow things down as the conseole being print to is the ng anagular one and not in fact the web browser itself,
            it seems this localstrorage call is being called server side and not client side so I need to figure out why exactly that is 
        i believe it was dues to the fact that i set up server side rendering 
            "ssr": false,
            best to let the client handle the rendering

        that was the issue golly I amaze myself sometimes 
        Changed angular.json:
        from:
            "prerender": true,
                "ssr": {
                "entry": "server.ts"
                } 
        to:
            "prerender": false,
            "ssr": false
        badabing bada boom 

    Still having issues with the login prompt not howing back up upon logout...
        needed to add 
        this.currentUserSource.next(null);
        to the logout method of account.service.ts

    Build an app with ASPNET Core and Angular from scratch Notes:

    Creating register component:
        ng g c register
        <form #registerForm="ngForm" (ngSubmit)="register()" autocomplete="off">
            <h2 class="text-center text-primary">Sign Up</h2>
            <hr>
            <div class="mb-3">
                <input type="text"
                    class="form-control"
                    name="username"
                    [(ngModel)]="model.username"
                    placeholder="Username">
            </div>
            <div class="text-center">
                <input type="password" 
                    class="form-control"
                    name="password"
                    [(ngModel)]="model.password"
                    placeholder="Password">
            </div>
            <hr>
            <div class="text-center">
                <button class="btn btn-success me-2" type="submit">Register</button>
                <button class="btn btn-default" type="button" (click)="cancel()">Cancel</button>
            </div>
        </form>

    Parent to child data sharing: home (parent) to register(child)
        sending data to the register component from the parent home comopnent:
        cut getUsers from appcomponent to home 
            inject the httpClient 
            add a global users
            this.getUsers in ngOnit to pull the users
        goal pass user list from home compoent to register component

        the input property:
            add to registerComponent: 
            @Input() usersFromHomeComponent: any;

            pass in the usersFromHomeComponent to the app-register html element est in home.component
            <app-register [usersFromHomeComponent]="users"></app-register>

            the register component should now be able to access the data assuming the component initialized 

            test the parent data registerComponent:
                remember angular types are case sensitive
                <div class="mb-3">
                    <label> Who is your favorite user</label>
                    <select name="favorit" id="fav" class="form-select">
                        <option *ngFor="let user of usersFromHomeComponent" [value] ="user.userName"> 
                            {{user.username}}
                        </option>
                    </select>
                </div>

    Child to Parent Communication:
        in registerComponent:
            @Output() cancelRegister = new EventEmitter();
            
            cancel(){
                this.cancelRegister.emit(false);
            }
        in homeComponent.html:
            <app-register [usersFromHomeComponent]="users" (cancelRegister)="cancelRegisterMode($event)"></app-register>
        in homeComponent.ts declare cancelRegisterMode():
            cancelRegisterMode(event:boolean){
                this.registerMode = event;
            }

    Wire up registration with api:
        account.service add register endpoint:
          register(model:any){
                return this.http.post<User>(this.baseUrl + 'account/register', model).pipe(
                map(user => {
                    if(user){
                    localStorage.setItem('user', JSON.stringify(user));
                    this.currentUserSource.next(user);
                    }
                })
                )
            }
        wire up the service in the registerComponent:
        inject the account service:
              constructor(private accountService: AccountService){}
        create register fn:
            register() {
                this.accountService.register(this.model).subscribe({
                next: response => {
                    console.log(response);
                    this.cancel();
                },
                error: error => console.log(error)
                })
            }
        the response is undefine due to the mapping occuring in the service 
        the response need to be return in the mapping fucntion 
            map(user => {
                if(user){
                localStorage.setItem('user', JSON.stringify(user));
                this.currentUserSource.next(user);
                }
                return user;
            })
    
    implementing routing:
        generate a few components:
            ng g c member/member-list

            ng g c member/member-detail

            ng g c lists

            ng g c messages

        modify app.routing create the routes for the new compoenents
            !!order matters the ** at the end will catch any routes that dont fit the bill and reroute to the home component
            const routes: Routes = [
                {path: '', component: HomeComponent},
                {path: 'members', component: MemberListComponent},
                {path: 'members/:id', component: MemberDetailComponent},
                {path: 'lists', component: ListsComponent},
                {path: 'messages', component: MessagesComponent},
                {path: '**', component: HomeComponent, pathMatch: 'full'},
            ];

            pathMatch: 'full'}, ensur this for last route to prevent circular link rerouting 

        apply the router link to the navbar links using routerLink
            example:
            <li class="nav-item">
                <a class="nav-link" routerLink="/members">Members</a>
            </li>

        make nav link active upon click and router loaded: 
            add routerLinkActive = "active"
            example:
                <a class="nav-link" routerLink="/lists" routerLinkActive = "active">Lists</a>
        
        Route upon login:
            navcomponent:
                inject the router 
                private router: Router
            route at login fn:
              login(){
                this.accountService.login(this.model).subscribe({
                next: response => {
                    this.router.navigateByUrl('/members')
                    console.log(response);
                },
                error: error => {
                    console.log(error)
                }
                })
            }
            the / in the route is critical it ids the route as a root route thats relative, will not cchain to the existing route 

    Apply toast notifications on errors:
        install ngx-toastr:
            npm install ngx-toastr --save 
            npm install @angular/animations --save

        add the toast to the css import in angular.json 
            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "node_modules/ngx-toastr/toastr.css",
              "src/styles.css"
            ],
        
        import style into the css :
            @import "../node_modules/ngx-bootstrap/datepicker/bs-datepicker.css";
            @import "../node_modules/ngx-toastr/toastr.css";

        add the toastr module to app.module:
            ToastrModule.forRoot(),

        implement in the navcomponent and register :
            inject toastr : private toast: ToastrService
            add  toast to the error response 
                this.accountService.login(this.model).subscribe({
                    next: _ => this.router.navigateByUrl('/members'),
                    error: error => this.toastr.error(error.error)
                })

        adjust toast positioning in _AppModule:
            ToastrModule.forRoot({
                positionClass: 'toast-bottom-right'
            }),

        address issue where toas display object object when register attempt with blank user and password
            cause  there are multiple errors so c# returns a list of error that needs to be mapped instead 
            this will be addressed later

    Route Gaurds for authorization:
        remember client side security is not really security that needs done on the api side.
        ang cli command to add gaurd 
        ng g gaurd or ng g g 
        example:
            ng g g _gaurds/auth
            select canActivate

        This create skeleton ts file with 
            import { CanActivateFn } from '@angular/router';
                export const authGuard: CanActivateFn = (route, state) => {
                return true;
            };

        Here you can specify the routes that need an account service check to allow the route to load and specify a toastr message is auth is not permitted 

        inject the toastr and accountServices:  
            const accountService = inject(AccountService);
            const toastr = inject(ToastrService);
        entirety of the gaurd:
        basically a boolean generator mapped to the user service to determin if ther is a current user 
        export const authGuard: CanActivateFn = (route, state) => {
            const accountService = inject(AccountService);
            const toastr = inject(ToastrService);
            return accountService.currentUser$.pipe(
                map(user => {
                if(user) return true;
                else{
                    toastr.error('You shall not pass!')
                    return false;
                }
                })
            )
        };

    Attach the route gaurd to the routes in the app.routes:
        {path: 'members', component: MemberListComponent, canActivate: [authGuard]},

        canActivate: [authGuard] specifies the auth gaurd to validate with can be multiple, and prevents rotuing if false

    Creating a dummy route with child routes:
        all paths that need the same gaurd can be declared under the same parent saving some boiler plate example:
        {path: '',
            runGuardsAndResolvers: 'always',
            canActivate: [authGuard],
            children: [
            {path: 'members', component: MemberListComponent, canActivate: [authGuard]},
            {path: 'members/:id', component: MemberDetailComponent},
            {path: 'lists', component: ListsComponent},
            {path: 'messages', component: MessagesComponent},
            ]
        },

    Hide the links to not temp the user:
        <ng-container *ngIf="accountService.currentUser$ | async">
            is an invisibale element that allow nested elements within it to be display or hiddened base on the ngIf Directive
            wont show in the dom at all 

    Adding a new theme:
        Bootswatch is a good free styling resource

        npm install bootswatch --save
         angular.json add style
         "bootswatch/dist/cyborg/bootstrap.min.css"
        add style.css 
        @import 'bootswatch/dist/cyborg/bootstrap.min.css';

    Make the interpolated value upper case
        Welcome {{user.username | titlecase}}
    Clean up the welcome bar when user is logged in:
        the as user modifier allows you to cast the accountservice and access its members 
        changed from:
            <div class="dropdown" *ngIf="accountService.currentUser$ | async" class="dropdown" dropdown>
            <a class="dropdown-toggle text-light text-decoration-none" dropdownToggle>Welcome {{(accountService.currentUser$ | async)?.username}} </a>
            
        to:
            <div class="dropdown" *ngIf="accountService.currentUser$ | async as user"  class="dropdown" dropdown>
            <a class="dropdown-toggle text-decoration-none" dropdownToggle>Welcome {{user.username | titlecase}} </a>

    Creating a shared module to slim down the appModule.ts:
        use a share module for any 3rd party modules 

        ng cli:
            ng g --help
            look for module

            ng g m _modules/shared --dry-run 
                double check the dir creation 
                this makes a shared directory if you dont want a sep folder declare it as flat:

            ng g m _modules/shared  --flat
        
        Slap all the 3rd party modules into it with appropraite imnports:
            @NgModule({
                declarations: [],
                imports: [
                    CommonModule,
                    TooltipModule.forRoot(),
                    BsDropdownModule.forRoot(),
                    ToastrModule.forRoot({
                    positionClass: 'toast-bottom-right'
                    }),
                ]
                })
                export class SharedModule { }

        import the shared module into the app.module:
            add     SharedModule, to the imports list

        denote the sharedModule as exportable:
        add export arrays:
            exports:[
                TooltipModule,
                BsDropdownModule,
                ToastrModule
            ]

January 27, 2024
    Api middleware, interceptors , exception troubleshooting 
    centralize error handling to reduce code repetition 

    Create a buggycontroller to handle http errors:
        BuggyController.cs in the api:

        simply generate enpoints that will produce errors 
        public class BuggyController : BaseAPIController
            {
                private readonly DataContext _context;

                public BuggyController(DataContext context)
                {
                    _context = context;
                }

                [Authorize]
                [HttpGet("auth")]
                public ActionResult<string> GetSecret()
                {
                    return "secret text";
                }
                
                [HttpGet("not-found")]
                public ActionResult<AppUser> GetNotFound()
                {
                    var thing = _context.Users.Find(-1);
                    if(thing == null) return NotFound();
                    return thing;
                }
                
                [HttpGet("server-error")]
                public ActionResult<string> GetServerError()
                {
                    var thing = _context.Users.Find(-1);
                    var thingToReturn = thing.ToString();
                    return thingToReturn;
                }
                
                [HttpGet("bad-request")]
                public ActionResult<string> GetBadRequest()
                {
                    return BadRequest("This was a bad request");
                }

    Time to intercept the errors and produce a more readable response:
        in development mode which is set via the launchsetting.JSON
        .net api aut catches stack trace errors and passes them into the api requests 
        however in production this does not occur

        you slap your excecution block behind a try catch to handle the exceptions directly
        like so 
            [HttpGet("server-error")]
            public ActionResult<string> GetServerError()
            {
                try
                {
                    var thing = _context.Users.Find(-1);
                    var thingToReturn = thing.ToString();
                    return thingToReturn;
                }
                catch (Exception ex)
                {
                    return StatusCode(500, "Computer says no!");
                }

            }
        this bypass the dev exception stack trace req return and instead handles the error directly with a single response of computer say no

        it will be tedious to put every potention exec bloc behind a try catch when a null is possible instead you can intercept the error via: 
    exception handling middleware:
        Create error director in Api project
        Create APIException Class:
            data model for exceptions that will occurs simmpe with code details and message
            public class APIException
            {
                public APIException(int statusCode, string message, string details)
                {
                    StatusCode = statusCode;
                    Message = message;
                    Details = details;
                }

                public int StatusCode { get; set; }
                public string Message { get; set; }
                public string Details { get; set; }
                
            }

    Create a middleware directory with ExcemptionMiddleware.cs:
        this will end in the middle of an http request executing the http contexts invocation and catching if, exceptions occurs and translate the message into a error response with either the stack trace if in dev mode ot internal server error otherwise, along with the exceptions error message.

        public class ExceptionMiddleware
        {
            private RequestDelegate _next;
            private ILogger<ExceptionMiddleware> _logger;
            private IHostEnvironment _env;

            public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger, IHostEnvironment env)
            {
                _env = env;
                _logger = logger;
                _next = next;
            }

            public async Task InvokeAsync(HttpContext context)
            {
                try
                {
                    await _next(context);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, ex.Message);
                    context.Response.ContentType = "application/json";
                    context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;

                    var response = _env.IsDevelopment()
                        ? new APIException(context.Response.StatusCode, ex.Message, ex.StackTrace?.ToString())
                        : new APIException(context.Response.StatusCode, ex.Message, "Internal Server Error");

                    var options = new JsonSerializerOptions
                    {
                        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                    };

                    var json = JsonSerializer.Serialize(response, options);
                    await context.Response.WriteAsync(json);
                }
            }

            this middleware then needs embedded into the startup routine in order for the http context invokes to be passed through it before the http request pipeline:
            program.cs:
                app.UseMiddleware<ExceptionMiddleware>();
                // Configure the HTTP request pipeline.
                if (app.Environment.IsDevelopment())

            Postman now recieves error responses in json form with message and stack trace forh http exceptions:
                {"statusCode":500,"message":"Object reference not set to an instance of an object.","details":"   at TeborawAPI.Controllers.BuggyController.GetServerError() in /Users/rompasaurus/TeborawWebApp/TeborawAPI/Controllers/BuggyController.cs:line 36\n   at lambda_method3(Closure, Object, Object[])\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.SyncObjectResultExecutor.Execute(ActionContext actionContext, IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeActionMethodAsync()\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeNextActionFilterAsync()\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeInnerFilterAsync()\n--- End of stack trace from previous location ---\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeFilterPipelineAsync>g__Awaited|20_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Logged|17_1(ResourceInvoker invoker)\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Logged|17_1(ResourceInvoker invoker)\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|7_0(Endpoint endpoint, Task requestTask, ILogger logger)\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\n   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\n   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\n   at TeborawAPI.Middleware.ExceptionMiddleware.InvokeAsync(HttpContext context) in /Users/rompasaurus/TeborawWebApp/TeborawAPI/Middleware/ExceptionMiddleware.cs:line 24"}

    Create an angular component to handle api error responses:
        just a test page to ensure errors return to the console:
            create new component:
            ng g c error/test-error

            import { HttpClient } from '@angular/common/http';
            import {Component, OnInit} from '@angular/core';
            @Component({
            selector: 'app-test-error',
            templateUrl: './test-error.component.html',
            styleUrl: './test-error.component.css'
            })
            export class TestErrorComponent implements OnInit{
            baseUrl = "https://localhost:5001/api/";

            constructor(private http: HttpClient){

            }

            ngOnInit() {
            }

            get404Error() {
                this.http.get(this.baseUrl + 'buggy/not-Found').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get400Error() {
                this.http.get(this.baseUrl + 'buggy/bad-request').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get500Error() {
                this.http.get(this.baseUrl + 'buggy/server-error').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get401Error() {
                this.http.get(this.baseUrl + 'buggy/auth').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }

            get400Error() {
                this.http.post(this.baseUrl + 'account/register').subscribe({
                next: response => console.log(response),
                error: error => console.log(error)
                })
            }
            }
        html:
            <ng-container>
                <button class="btn btn-outline-primary me-3" (click)="get500Error()"> Test 500 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get400Error()"> Test 400 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get401Error()"> Test 401 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get404Error()"> Test 404 Error </button>
                <button class="btn btn-outline-primary me-3" (click)="get400ValidationError()"> Test 400 Validation Error </button>
            </ng-container>

        Route to this component 
              {path: 'errors', component: TestErrorComponent},


    Intercepting http Errors from angular:
        find requests that are error and display toast message 
        ng g --help 
        find interceptor options 

        cli:
            ng g interceptor _interceptors/error 

        this create a error.interceptor.ts in  its on interceptor folder:
        import {Injectable} from "@angular/core";
        import {HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest} from "@angular/common/http";
        import {NavigationExtras, Router} from "@angular/router";
        import {catchError, Observable} from "rxjs";
        import {ToastrService} from "ngx-toastr";
        @Injectable()
        export class ErrorInterceptor implements HttpInterceptor{
        constructor(private router: Router, private toastr: ToastrService) {
        }

        intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
            return next.handle(req).pipe(
            catchError((error:HttpErrorResponse)=> {
                if (error) {
                switch (error.status) {
                    case 400:
                    // multipl errors could be passed back this will check if a object was passed that needs iterated through
                    if (error.error.errors) {
                        const modelStateErrors = [];
                        for (const key in error.error.errors) {
                        if (error.error.errors[key]) {
                            modelStateErrors.push(error.error.errors[key])
                        }
                        }
                        throw modelStateErrors;
                    } else {
                        this.toastr.error(error.error, error.status.toString())
                    }
                    break;
                    case 401:
                    this.toastr.error('Unauthorized', error.status.toString());
                    break;
                    case 404:
                    this.router.navigateByUrl('/not-found')
                    break;
                    case 500:
                    //Navigation extras provides a way to pass the error information into a component to display it on the page
                    const navigationExtras: NavigationExtras = {state: {error: error.error}}
                    this.router.navigateByUrl('/server-error', navigationExtras);
                    break;
                    default:
                    this.toastr.error('Something unexpected occurred');
                    console.log(error);
                    break;
                }
                }
                throw error;
            }));
            }
        }

    Add the interceptor to app.modules in the providers array:
        {provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi:true}
        multi:true allows angular provided interceptors to continue working as well     

    Setup server side validation errors for 400 validation error:
    in error component:

        establish error list:
            validationErrors: string[] = []

        populate the error list in function:
            get400ValidationError() {
                this.http.post(this.baseUrl + 'account/register', {}).subscribe({
                next: response => console.log(response),
                error: error => {
                    console.log(error);
                    this.validationErrors = error;
                }
                })
            }
        Present the error in a list via template:
            <div class="row mt-5" *ngIf="validationErrors.length > 0">
                <ul class="text-danger">
                    <li *ngFor="let error of validationErrors">
                        {{error}}
                    </li>
                </ul>
            </div>

    Handle 401 and 500 error:
        create /not-found and /server-error components:
            ng g c errors/not-Found

            ng g c errors/server-error

        not-found.html :
        <div class="container">
            <h1>Not Found</h1>
            <button class="btn btn-info btn-lg" routerLink="/">Return to Home Page</button>
        </div>
        
        establish home route in route.ts:
            {path: 'not-found', component: NotFoundComponent},
            {path: 'server-error', component: ServerErrorComponent},
            //wildcards are implictly not found so ajust route to go to that comp as well
            {path: '**', component: NotFoundComponent, pathMatch: 'full'},

        Cleanup nav login and remove toast message since its already handled globally:
            removed toast message 
            register aslo no longer needs toast 

        Server-error html:
            <h4> Internal server error - refreshing this page will make the error disappear</h4>
            <ng-container *ngIf="error">
            <h5 class="text-danger">Error: {{error.message}}</h5>
            <p class="font-weight-bold"> Note: If you are seeing this then angular is probably not to blame </p>
            <p> What to do next?</p>
            <ol>
                <li> Open Chrome Dev tools then check the failing request in the network tab</li>
                <li> Examine the req url - What api endpoint are you requesting? </li>
                <li>Reproduce the problem in postman - iff same error angular is not the problem for certain</li>
            </ol>
            <p style="font-weight: bold">Following is the stack trace:</p>
            <code class="mt-5" style="background-color: whitesmoke;">
                {{error.details}}
            </code>
            </ng-container>

        server error ts:
            import {Component, OnInit} from '@angular/core';
            import {Router} from "@angular/router";

            @Component({
            selector: 'app-server-error',
                templateUrl: './server-error.component.html',
                styleUrl: './server-error.component.css'
                })
                export class ServerErrorComponent implements OnInit{
                error:any;
                constructor(private router: Router){
                    const navigation = this.router.getCurrentNavigation();
                    //The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
                    // For example, ?.() is used to call a function that may not exist.
                    // The ?.[] syntax also works, if wed like to use brackets [] to access properties instead of dot .. Similar to
                    this.error = navigation?.extras?.state?.['error']
                }

                ngOnInit() {

                }
            }


    next steps:
        Clean up the component styling make the compoent appear center aligned with a margin around the sides 


    Extending the api:
        Goals:
            entity framework, relationships,conventions
            seeding data to db
            repository pattern 
            using automapper
        
        Extend the app user class:
            add these props to the appuser 
                public Byte[] PasswordSalt { get; set; }
                public DateOnly DateOfBirth { get; set; }
                public string KnownAs { get; set; }
                public DateTime Created { get; set; }
                public DateTime LastActive { get; set; }
                public string Gender { get; set; }
                public string Introduction { get; set; }
                public string Country { get; set; }
                public string City { get; set; }
                public string Interests { get; set; }
                public string LookingFor { get; set; }
                public List<Photo> Photos { get; set; } = new();

            Create phot class to house photo information and be able to have a list in the appuser 
                public class Photo
                {
                    public int Id { get; set; }
                    public string Url { get; set; }
                    public bool IsMain { get; set; }
                    public string PublicId { get; set; }
                }
        
        DateTimeExtension to calc age base on DoB:
            create method in appUser class:
                public int getAge()
                {
                    return DateOfBirth.CalculateAge();
                }

            Create helper class/ extensiont 
                static class that allows for dateitme conversions
                in extensions/DateTimeExtensioons
                public static class DateTimeExtensioons
                {
                    public static int CalculateAge(this DateOnly dob)
                    {
                        var today = DateOnly.FromDateTime(DateTime.UtcNow);
                        var age = today.Year - dob.Year;
                        if (dob > today.AddYears(-age)) age--;
                        return age;
                    }
                }

    Entity Framework relationships:
        user and photos is a one to many relationship 
            one user can have many photo's
            should remain in the same context as the phontos will be linked directly to one user 
            photos will not be queried directly will be access via the user
        [Table("Photos")]
            public class Photo

        Create Migration to generate photos and add field to appuser
        dotnet ef migrations add ExtenededUserEntity

        migration is not quite right phots recieves an appuser id  which can be nullable, this is not ideal to have photos without a user need to addjust the entity to fully define th e user phot relationship

        dotnet ef migration remove 

        will remove the last unapplied migration

        adding this to photos will ensure that phot created will have to be tied to a user and cannot be orphaned : 
            public int AppUserId { get; set; }
            public AppUser AppUser { get; set; }

        apply migration:
        dotnet ef database update

    Genrating Seed Data:
        Use the Json Generator tool:
        https://json-generator.com/
        use provided json file in assets to generate:
        [
            '{{repeat(5)}}',
            {
                UserName: '{{firstName("female")}}',
                Gender: 'female',
                DateOfBirth: '{{date(new Date(1950,0,1), new Date(1999, 11, 31), "YYYY-MM-dd")}}',
                KnownAs: function(){ return this.UserName; },
                Created: '{{date(new Date(2019, 0, 1), new Date(2020,5,30), "YYYY-MM-dd")}}',
                LastActive: '{{date(new Date(2020, 4, 1), new Date(2020,5,30), "YYYY-MM-dd")}}',
                Introduction: '{{lorem(1, "paragraphs")}}',
                LookingFor: '{{lorem(1, "paragraphs")}}',
                Interests: '{{lorem(1, "sentences")}}',
                City: '{{city()}}',
                Country: '{{country()}}',
                Photos: [
                    {
                    Url: function(num) {
                    return 'https://randomuser.me/api/portraits/women/' + num.integer(1,99) + '.jpg';
                    },
                    IsMain: true
                }
                ]
            }
        ]
        add the json to userseed.json in the data folder of the api 

    Create seed class in data folder :
        public class Seed
        {
            public static async Task SeedUsers(DataContext context)
            {
                if (await context.Users.AnyAsync())
                {
                    return;
                }
                else
                {
                    var userData = await File.ReadAllTextAsync("Data/UserSeedDataNew.json");
                    //ignores and still adds lowercase property name 
                    var options = new JsonSerializerOptions{PropertyNameCaseInsensitive = true};
                    var users = JsonSerializer.Deserialize<List<AppUser>>(userData);
                    foreach (var user in users)
                    {
                        using var hmac = new HMACSHA512();
                        user.UserName = user.UserName.ToLower();
                        user.PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes("Pa$$w0ed"));

                        context.Users.Add((user));
                    }

                    await context.SaveChangesAsync();
                    

                }
            }
        }
    Init the seed method in the startup.cs class:
        immediately before app.Run place this try catch block 
        try
        {
            var context = services.GetRequiredService<DataContext>();
            //with a freshly dropped db this will rerun all the migration scripts create the db and 
            //then run seed
            await context.Database.MigrateAsync();
            await Seed.SeedUsers(context);
        }
        catch (Exception ex)
        {
            var logger = services.GetService<ILogger<Program>>();
            logger?.LogError(ex, "An error occured during migration");
        }

        app.Run();

    Test the seed, drop the db and remigrate 
        cli:
            dotnet ef database drop

        rerun app and watch the migration reoccur then... fail with error 
            ---> System.ArgumentException: Cannot write DateTime with Kind=Unspecified to PostgreSQL type 'timestamp with time zone', only UTC is supported. Note that it's not possible to mix DateTimes with different Kinds in an array, range, or multirange. (Parameter 'value')

        add AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true); to program.cs
            --> after the app.build

        rerun app again, that error should be gone one more remains 
            ---> Npgsql.PostgresException (0x80004005): 23502: null value in column "PasswordSalt" of relation "Users" violates not-null constraint
      
            DETAIL: Detail redacted as it may contain sensitive data. Specify 'Include Error Detail' in the connection string to include this information.
        
        needed to add:  
            user.PasswordSalt = hmac.Key;
        to the seed.cs method after generate hash

        That errors is gone another error remains:
            ---> Npgsql.PostgresException (0x80004005): 23502: null value in column "PublicId" of relation "Photos" violates not-null constraint
            
            a problem for tomorrow me to figure out 

            next steps:
                address seed error
                Clean up the component styling make the compoent appear center aligned with a margin around the sides 

January 28, 2024:
    Fixed seed error had to make the public id nullable in the migration script:
        PublicId = table.Column<string>(type: "text", nullable: true),

    To Do:
        Center the compoenent in the index page 

    
    Seed data postman testing:
        int the api route check there is a test tab that allows you to assert the response and store a return value:
            running the first route test in the auth tetsing folder will pull the auth token and allow it to be used in subsequent test without need to manulaly paste it in 
        top right icon with show the env variable that is stored with name token after test is run 

    Repository Pattern:
        martin fowler patterns of enterprise architecture:
            A repository mediates between the domain and data mapping layers acting like an in memory domain object collection

            Current app data workflow:
                web server <-> controller <-> dbContext <-> database 

            Repository Pattern workflow:
                web server <-> controller <-> repository <-> dbContext <-> database 

            Repo allow for quick data access for commonly used 
            may be exceesss as unitofwork and dbcontext act in similar fashion 

        Reason to use this thoughL:
            encapsulates the logic
                users.First turns into getUser can limit the scope of method accessed by the front end 
            reduce dupe query logic 
            promotes testability 
            easy to test against repo the context 
            decouples application from the persistance framework 
            decentralizes the queries 
            allows easy changes orm 
            promotes readablility 
            Drawbacks:
                each root entity should have its own repo 
                need to implement unit of work pattern 
        
    Pull the context our of the controller 
        create repoository interface for user in repo folder then implement it in the data folder 
        namespace TeborawAPI.Data;
            public class UserRepository : IUserRepository
            {
                private readonly DataContext _context;

                public UserRepository(DataContext context)
                {
                    _context = context;
                }
                public void Update(AppUser user)
                {
                    _context.Entry(user).State = EntityState.Modified;
                }

                public async Task<bool> SaveALlAsync()
                {
                    return await _context.SaveChangesAsync() > 0;
                }

                public async Task<IEnumerable<AppUser>> GetUsersAsync()
                {
                    await _context.Users.ToListAsync();
                }

                public async Task<AppUser> GetUserByIdAsync(int id)
                {
                    return await _context.Users.FindAsync(id);
                }

                public async Task<AppUser> GetUserByUsernameAsync(string username)
                {
                    return await _context.Users.SingleOrDefaultAsync(x => x.UserName == username);
                }
            } 
        add the repo as a service extenision in the application services extension:
            services.AddScoped<IUserRepository, UserRepository>();

    Refactor the User Controller
        inject user repo interface instead of the context:
            public UsersController(IUserRepository userRepository)
            call the repo and return need to return as 
            return Ok(await _userRepository.GetUsersAsync());
        Photos array is empty though when returning 
            the list of users doest not include related data 
            need the includes keyword to eager load the data
            code:
                return await _context.Users
                    .Include(p => p.Photos)
                    .ToListAsync();

            This fucked shit up apparantly
            Error:
                 "message": "A possible object cycle was detected. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 32. Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles. Path: $.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.AppUser.Photos.",
                "details": "   at System.Text.Json.ThrowHelper.ThrowJsonException_SerializerCycleDetected(Int32 maxDepth)\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\n   at System.Text.Json.Serialization.Converters.ListOfTConverter`2.OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state)\n   at System.Text.Json.Serialization.JsonCollectionConverter`2.OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options,

            the includes is caught in a cyclical query because the AppUsers is associated to both the photos and User
            need to exclude the appuser upont quesry

            Need to shape the data via DTO's:
            Create the member and photo excluding the cyclical maps
                public class MemberDTO
                {
                    public int Id { get; set; }
                    public string UserName {get; set;}
                    public int Age { get; set; }
                    public string KnownAs { get; set; }
                    public DateTime Created { get; set; }
                    public DateTime LastActive { get; set; }
                    public string Gender { get; set; }
                    public string Introduction { get; set; }
                    public string Country { get; set; }
                    public string City { get; set; }
                    public string Interests { get; set; }
                    public string LookingFor { get; set; }
                    public List<PhotoDTO> Photos { get; set; }
                }

                public class PhotoDTO
                {
                    public int Id { get; set; }
                    public string Url{ get; set; }
                    public bool IsMain { get; set; }
                }

            Automapper!! Map the model/entity to the dto:
                nuget install the automapper: AutoMapper.Extensions.Microsoft.DependencyInjection
                
                Create helpers folder > AutoMapperProfiles: 
                    public class AutoMapperProfiles: Profile
                    {
                        public AutoMapperProfiles()
                        {
                            CreateMap<AppUser, MemberDTO>();
                            CreateMap<Photo, PhotoDTO>();
                        }
                    }
                
                AutoMappers shouold ideally compare the names and "auto" map the propertys and its smart enough to know Age in the dto refers to the getAge of user 
            
                Inject add as a service auto mapper to the controller 
                    ApplicationServiceExtensions:
                        services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());

                    usersController inject:
                        private readonly IUserRepository _userRepository;
                        private readonly IMapper _mapper;

                        public UsersController(IUserRepository userRepository, IMapper mapper)
                        {
                            _userRepository = userRepository;
                            _mapper = mapper;
                        }
                    
                Utilize the mapper in the UserController:
                    public async Task<ActionResult<IEnumerable<AppUser>>> GetUsers()
                    {
                        var users = await _userRepository.GetUsersAsync();
                        var usersToReturn = _mapper.Map <IEnumerable<MemberDTO>>(users);
                        return Ok(usersToReturn);
                    }

            Configure specified propers to be returned from a dto eg just the photo url not entire object:
                mapping to meber prop: public string PhotoUrl { get; set; }
                automapper auto sets this to null need to dictate how to fill this in the Automapper profiles
                Code:
                    CreateMap<AppUser, MemberDTO>()
                        .ForMember(dest => dest.PhotoUrl,
                            opt => opt
                                .MapFrom(src => src.Photos.FirstOrDefault(x => x.IsMain).Url));

                photo url should now populate properly without null gonna take a min to unpack this code

        Optimizing the entity queries:
            Right now the ef calls are pulling all the data from the user table event the password fields that down get mapped to anything 

            the non automapper way:
                public async Task<MemberDTO> GetMemberAsync(string username)
                {
                    return await _context.Users
                        .Where(x => x.UserName == username)
                        .Select(user => new MemberDTO
                        {
                            Id = user.Id,
                            UserName = user.UserName,
                            KnownAs = user.KnownAs,
                        }).SingleOrDefaultAsync();
                }

        the automapper way:
            IUserRepository inject Imapper and add at the projectTO inplace of the select statement:
                public async Task<MemberDTO> GetMemberAsync(string username)
                {
                    return await _context.Users
                        .Where(x => x.UserName == username)
                        .ProjectTo<MemberDTO>(_mapper.ConfigurationProvider)
                        .SingleOrDefaultAsync();
                }
            Swap the userController code to use the repo instead:
                    [HttpGet("{username}")] // /api/users/2
                    //gonna get  weird result if username not foune
                    public async Task<ActionResult<MemberDTO>> GetUser(string username)
                    {
                        return await _userRepository.GetMemberAsync(username);
                    }

            GetAge is fucking shit up automapper needs to load all members of the data entity before it can call that 
                comment that shit out in appuser:
                adjust the automapper profile to pull the ages as it mappes instead of from within the appuser class :
                      CreateMap<AppUser, MemberDTO>()
                        .ForMember(dest => dest.PhotoUrl,
                            opt => opt
                                .MapFrom(src => src.Photos.FirstOrDefault(x => x.IsMain).Url))
                        .ForMember(dest => dest.Age, opt => opt.MapFrom(src => src.DateOfBirth.CalculateAge()));
                    
            Note:
                The projectTo autoMapp call auto eager loads the pertinant data, in this case the photo url, you nolong need the includes keyword as that is handled already.
    
    Building the User Interface:
        Using Typescript:
            Declaring a type of 2 types:
                let date : number | string = 42;
                data can have either a number or stringassigned to it.

            Typescript will infer the type base on the value that it is initialized too and the first value assigned dictates the type going forward

            Declaring an interface:
                will dicate the types ahead of time without values ex:
                    interface Car {
                        color: string,
                        model: string,
                        topSpeed?: number
                    }

                an interface will assume that all properties listed are required unless you add a ? after field declarations
                like topSpeed

            infering types from function params:
                const multiply = (x,y) => {
                    return x * y;
                }
                typescript inferes x and y can be any type but based on the function using multiplication it can only be numbers so its best to decalre it as a number 

        Create the Member and photo Interface:
            the front end needs a model to pass values to the api a viewmodel so to speak 
            ng cli:
                ng c i 

            The quick way to make a angular ts interface from a json file:
                json2ts.com > the snappy easy lazy way to do it you can get the user data passed back from the user controller and slapp it in here,
                to get a quick interface created 

                copy example user json data into the site ex: 
                    { 
                        "User":[{
                            "id": 1,
                            "userName": "lisa",
                            "age": 67,
                            "knownAs": "Lisa",
                            "created": "2020-06-24T02:00:00+02:00",
                            "lastActive": "2020-06-21T02:00:00+02:00",
                            "gender": "female",
                            "introduction": "Sunt esse aliqua ullamco in incididunt consequat commodo. Nisi ad esse elit ipsum commodo fugiat est ad. Incididunt nostrud incididunt nostrud sit excepteur occaecat.\r\n",
                            "country": "Martinique",
                            "city": "Greenbush",
                            "interests": "Sit sit incididunt proident velit.",
                            "lookingFor": "Dolor anim cupidatat occaecat aliquip et Lorem ut elit fugiat. Mollit eu pariatur est sunt. Minim fugiat sit do dolore eu elit ex do id sunt. Qui fugiat nostrud occaecat nisi est dolor qui fugiat laborum cillum. Occaecat consequat ex mollit commodo ad irure cillum nulla velit ex pariatur veniam cupidatat. Officia veniam officia non deserunt mollit.\r\n",
                            "photos": [
                                {
                                    "id": 1,
                                    "url": "https://randomuser.me/api/portraits/women/54.jpg",
                                    "isMain": true
                                }
                            ],
                            "photoUrl": "https://randomuser.me/api/portraits/women/54.jpg"
                        }]
                    }
                produces this ts interface:
                    export interface User {
                        id: number;
                        userName: string;
                        age: number;
                        knownAs: string;
                        created: string;
                        lastActive: string;
                        gender: string;
                        introduction: string;
                        country: string;
                        city: string;
                        interests: string;
                        lookingFor: string;
                        photos: Photo[];
                        photoUrl: string;
                        }

                    export interface Photo {
                        id: number;
                        url: string;
                        isMain: boolean;
                        }
            Create a member.ts interface file in _models folder:
                ng g interface _models/member
                cmd . on the photo interface to make the interface a new file 

    Get Ride of harcoded baseUrl:
        add a env file to house this data 
        
        ng cli:
            ng g environments
                creates 2 files 
                    CREATE src/environments/environment.ts (31 bytes)
                    CREATE src/environments/environment.development.ts (31 bytes)
            establis url and env in the dev and prod files:
                dev:
                    export const environment = {
                        prodution: false,
                        apiUrl: 'https://localhot:L5001/api/'
                    };
                prod:
                    export const environment = {
                        prodution: true,
                        apiUrl: 'api/'
                    };

        import the environment vars everwhere the baseUrl is swap em:
            DI environment and swap Ex:
                //ensure to inmport from root import { environment } from '../../environments/environment'; 
                //and not the dev one otherwise it will not change in production
                baseUrl = environment.apiUrl;
    
    Marshalling Data:
        In computer science, marshalling (similar to serialization) is the process of transforming the memory representation of an object to a data format suitable for storage or transmission. It is typically used when data must be moved between different parts of a computer program or from one program to another.
    
    
    Create a member service to to marshal data from the controller to components:
        ng cli: 
            ng g s _services/members 

        member.service.ts:
            @Injectable({
            providedIn: 'root'
            })
            export class MembersService {
            baseUrl = environment.apiUrl

            constructor(private http: HttpClient) { }

            getMembers(){
                return this.http.get<Member[]>(this.baseUrl + 'users' + this.getHttpOptions())
            }

            getMember(username:string){
                return this.http.get<Member>(this.baseUrl + 'users/' + username, this.getHttpOptions());
            }

            //need a way to pass authentication, the wrong way first then the proper way later 
            getHttpOptions(){
                const userString = localStorage.getItem('user')
                if(!userString) return;
                const user = JSON.parse(userString)
                return{
                headers: new HttpHeaders({
                    Authorization: 'Bearer ' + user.token
                })
                }
        
        put the service to use in the member list component:
            export class MemberListComponent implements OnInit {
                members : Member[] = []

                constructor(private memberService:MembersService){}

                ngOnInit(): void {
                    this.loadMembers()
                }

                loadMembers(){
                    this.memberService.getMembers().subscribe({
                    next: members => this.members = members
                    })
                }
            }

    List the names in the member-list.component:
        <div class="row">
            <div class="col-2">
                <p *ngFor="let member of members">{{member.knownAs}}</p>
            </div>
        </div>

    Create memeber card components:
        ng cli:
            ng g c member/member-card

            tsconfig.ts can be adjust to reduce ts's strictness
                "strictPropertInitialization" : false
            not a good idea to do this 
        member card is achild to the member list and thus need input data 
        @Input() member : Member
            angular will yell at you until this initialized you can do this in 2 ways:
            @Input() member : Member = {} as Member
            or:
            @Input() member : Member | undefined;
                prefferred way is this as initialy the member will start out undefined 

        Create template card:
        <div class="card mb-4">
            <div class="card-img-wrapper">
                <img src="{{member?.photoUrl}}" alt="{{member?.knownAs}}">
            </div>
        </div>
        Or check for member existance:
        <div class="card mb-4" *ngIf="member">
            <div class="card-img-wrapper">
                <img src="{{member.photoUrl}}" alt="{{member.knownAs}}">
            </div>
        </div>

        slap that component into the list component template passing in the member as the input 
        <div class="row">
            <div class="col-2" *ngFor="let member of members">
                <app-member-card [member]="member"></app-member-card>
            </div>
        </div>

    Make the cards interactive with hovering:
        member-card.component.css
            .card:hover img {
                transform: scale(1.2,1.2);
                transition-duration: 500ms;
                transition-timing-function: ease-out;
                opacity: 0.7;
            }

            .card img {
                transform: scale(1.0,1.0);
                transition-duration: 500ms;
                transition-timing-function: ease-out;
            }

            .card-img-wrapper {
                overflow: hidden;
            }
        this zooms the image in the box when you hover over it.

        encapsulation attribute of a component.ts 
            encapsulation: ViewEncapsulation.Emulated
                when set to emulate which by default it is 
                will generate unique class ids with the class name and random number at the end for each compoent ensuring that the css declare in the component.cc only applies to that specific component generate from that ts component you can however set the ViewEncapsulation to none and the css will be set to the class declared within the template without random ids tacked to the end:

            example:
                encapsulation: ViewEncapsulation.None
                @Component({
                    selector: 'app-member-card',
                    templateUrl: './member-card.component.html',
                    styleUrl: './member-card.component.css',
                    encapsulation: ViewEncapsulation.None
                })

January 29 2024:
    Adding animated buttons member card and member card css:
        .member-icons {
            position: absolute;
            bottom: -30%;
            left: 0;
            right: 0;
            margin-left: auto;
            margin-right: auto;
            opacity: 0;
        }

        .card-img-wrapper:hover .member-icons{
            bottom: 0;
            opacity: 1;
        }

        .animate {
            transition: all .3s ease-in-out;
        }
        <ul class="list-inline member-icons animate text-center">
                <li class="list-inline-item">
                    <button class="btn btn-primary">
                        <i class="fa fa-user"></i>
                    </button>
                </li>
                <li class="list-inline-item">
                    <button class="btn btn-primary">
                        <i class="fa fa-heart"></i>
                    </button>
                </li>
                <li class="list-inline-item">
                    <button class="btn btn-primary">
                        <i class="fa fa-envelope"></i>
                    </button>
                </li>
            </ul>
        </div>

    Using interceptor to send jwt token instead of hardwiring header with barer on each request"

        create interceptor ng cli:
            ng g interceptor _interceptors/jwt

        jwt.intercepot.ts:
            export class jwtInterceptor implements HttpInterceptor{

            constructor(private accountService: AccountService){}

            intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
                //THis is a trick to ensure that the subscription completes and unsubscribing is not required 
                this.accountService.currentUser$.pipe(take(1)).subscribe({
                next: user=>{
                    if(user){
                    req = req.clone({
                        setHeaders: {
                        //back ticks allow for string interpols to be added inline without need of + '' nonsense
                        Authorization: `Bearer ${user.token}`
                        }
                    })
                    }
                }
                })
                return next.handle(req)
                }
            }
        add the intercepto to the app.module:
            {provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi:true},
        
        remove the headers added in the members service


    Routing to the detailed page:
        member-detail.component.ts:
            inject the member service and activated route and pass in the member username passed in from the router

            export class MemberDetailComponent implements OnInit {
                member: Member | undefined;

                //Route allows access to the the username passed into the routers upon loading this component
                constructor(private memberService: MembersService, private route: ActivatedRoute){}

                ngOnInit(): void {
                    this.loadMember()
                }

                loadMember(){
                    var username = this.route.snapshot.paramMap.get('username')
                    if(!username) return;
                    this.memberService.getMember(username).subscribe({
                    next: member => this.member = member
                    })
                }
            }
        apply the router linke for the memebrs in the member card:
            <button class="btn btn-primary" routerLink="/member/{{member.userName}}">

    Creating the member  card template: member-detail card.ts:
        <div class="row" *ngIf="member">
            <div class="col-4">
                <div class="card">
                    <img src="{{member.photoUrl || './assets/user.png'}}" alt="{{member.knownAs}}"
                        class="card-img-top img-thumbnail">
                    <div class="card-body">
                    <div>
                        <strong>Location:</strong>
                        <p>{{member.city}}</p>
                    </div>
                    <div>
                        <strong>Age:</strong>
                        <p>{{member.age}}</p>
                    </div>
                    <div>
                        <strong>Last Active:</strong>
                        <p>{{member.lastActive}}</p>
                    </div>
                    <div>
                        <strong>Member Since:</strong>
                        <p>{{member.created}}</p>
                    </div>
                    <div class="card-footer">
                        <div class="btn-group d-flex">
                        <button class="btn btn-primary">Like</button>
                        <button class="btn btn-success">Message</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        Style:

        .img-thumbnail{
            margin: 25px;
            width: 85%;
            height: 85%;
            }

        .card-body{
            padding: 0 25px;
            }

        .card-footer{
            padding: 10px 20px;
            border-top: none;
            }


    Create tabs for details:
        add  TabsModule.forRoot(), to the shared modules 
        
        add tabset element to the member-detail template  
        <div class="col-8">
            <tabset></tabset>
        </div>

        specifie its properties as its an ngx component:
          <div class="col-8">
            <tabset class="member-tabs">
            <tab heading="About {{member.knownAs}}">
                <h4>Description</h4>
                <p>{{member.introduction}}</p>
                <h4>Looking for</h4>
                <p>{{member.lookingFor}}</p>
            </tab>
            <tab heading="Interests">
                <h4>Interests</h4>
                <p>{{member.interests}}</p>
            </tab>
            <tab heading="Photos">
                <p>Photos will go hear</p>
            </tab>
            <tab heading="Messages">
                <p>Messages will go hear</p>
            </tab>
            </tabset>
        </div>

    Adding Photo Gallery to the tab:
        ngx-gallery will be used here:
            npm install ng-gallery @angular/cdk --save

        This is a standalone component which allows component to be created appart from an ng module 
        meaning the component does not need to be declared in the app module
        but you cant use a standalone in a component that is not a standalone

        MemberDetailComponent needs declared as standalone to use gallery:
            @Component({
                selector: 'app-member-detail',
                standalone: true,

            MemberDetailComponent needs undeclared from the app module
                this will break the ang declarations in the MemberDetailComponent.html template
                cant use ngif and temp set 
                these elements need to import these on there in 
                need to add an imports stamement 
                this should fix that:
                    import {NgIf} from "@angular/common";
                    import {TabsModule} from "ngx-bootstrap/tabs";      

                      imports: [
                        NgIf,
                        TabsModule
                    ],
            
            then import the ng gallery now too this > GalleryModule

        pull the photos into a galleryitem array via:
            images: GalleryItem[] = []
            getImages(){
                if(!this.member) return;
                for(const photo of this.member.photos){
                this.images.push(new ImageItem({src: photo.url, thumb:photo.url}))
                }
            }

        added the gallerey component to the members details component
            <tab heading="Photos">
                <gallery [items]="images"></gallery>
            </tab>

        however because the gallery is being put in a tab the tab needs a #photTab reference added
        with a if to check if the the phot tab is active
            <tab heading="Photos" #photoTab = "tab">
                <gallery *ngIf="photoTab.active" [items]="images"></gallery>
            </tab>

Updating Resources:
    Goals:
        Angular template forms , 
        can deactivate routegaurd, 
        @ViewChild, 
        persisting changes to the api, 
        adding loading indicators, 
        cavhhing data in angular services

    
    Create profile edit page:
        ng cli:
            ng g c member/member-edit

        Add router link to the nav bar to get to member and add routing as well 
            {path: 'member/edit', component: MemberEditComponent},
            <a class="dropdown-item" routerLink="/member/edit"> Edit Profile</a>

        Member-edit:
            pull the members user data and quckly slap a user name in the template 
                member: Member | undefined
                user: User | null = null

                constructor(private accountService : AccountService, private memberService : MembersService) {
                    this.accountService.currentUser$.pipe(take(1)).subscribe({
                    next: user => this.user = user
                    })
                }

                ngOnInit(): void {
                    this.loadMember()
                }

                loadMember(){
                    if(!this.user) return
                    this.memberService.getMember(this.user.username).subscribe({
                    next: member => this.member = member
                    })
                }

    Create edit template:
        copy fair bit from the member detail page:
            turn field into forms and add edit alert will make dynamic later 
            <div class="row" *ngIf="member">
                <div class="col-4">
                    <h1>Your Profile</h1>
                </div>
                <div class="col-8">
                    <div class="alert alert-info">
                    <p><strong>You have made changes, any unsaved changes will be lost. </strong></p>
                    </div>
                </div>
                <div class="col-4">
                    <div class="card">
                    <div class="card-body">
                        <img src="{{member.photoUrl || './assets/user.png'}}" alt="{{member.knownAs}}"
                            class="card-img-top img-thumbnail">
                        <div>
                        <strong>Location:</strong>
                        <p>{{member.city}}</p>
                        </div>
                        <div>
                        <strong>Age:</strong>
                        <p>{{member.age}}</p>
                        </div>
                        <div>
                        <strong>Last Active:</strong>
                        <p>{{member.lastActive}}</p>
                        </div>
                        <div>
                        <strong>Member Since:</strong>
                        <p>{{member.created}}</p>
                        </div>
                        <div class="card-footer">
                            <button class="btn btn-success col-12">Save CHanges</button>
                        </div>
                    </div>
                    </div>
                </div>

                <div class="col-8">
                    <tabset class="member-tabset">
                    <tab heading="About {{member.knownAs}}">
                        <form>
                        <h4 class="mt-2">Description</h4>
                        <textarea class="form-control" [(ngModel)]="member.introduction"
                                    name="introduction"
                                    rows="6">

                        </textarea>
                        <h4 class="mt-2">Looking for</h4>
                        <textarea class="form-control" [(ngModel)]="member.lookingFor"
                                    name="lookingFor"
                                    rows="6">

                        </textarea>
                        <h4 class="mt-2">Interests</h4>
                        <textarea class="form-control" [(ngModel)]="member.interests"
                                    name="interests"
                                    rows="6">

                        </textarea>
                        <h4 class="mt-2">Location Details: </h4>
                        <div class="d-flex flex-row align-items-center">
                            <label for="city">City:</label>
                            <input type="text"[(ngModel)]="member.city" name="city" class="form-control mx-2">
                            <label for="country">Country: </label>
                            <input type="text" [(ngModel)]="member.country" name="country" class="form-control mx-2">
                        </div>
                        </form>
                    </tab>
                    <tab heading="Edit Photos">
                        <p>Photo edit will go here</p>
                        <p>{{member.interests}}</p>
                    </tab>
                    </tabset>
                </div>
            </div>

    Plugin the form and submit:
        MemberEditComponent:
            to tie a a button to a form that is outside of the form element you need to assign the form and id and assign a form to the button like so:
            <button class="btn btn-success col-12" form="editForm">Save Changes</button>

            creating form element:
            <form #editForm="ngForm" id="editForm" (ngSubmit)="updateMember()" >

            updateMember(){
                console.log("Updating Member: ",this.member)
                this.toastr.success("Profile Updated Successfully")
            }


        Dynamic alert for if form has been editted:
            <div class="alert alert-info" *ngIf="editForm.dirty">
                <p><strong>You have made changes, any unsaved changes will be lost. </strong></p>
            </div>
        ngif dirty will make element appear of the the form editForm cantains altered values yet to be save also you can hide the save button as well 
            <button class="btn btn-success col-12"
                form="editForm"
                [disabled]="!editForm.dirty">Save Changes</button>   
        
        Add a reset button:
            need to be able to access the form element established on the template page 
            using ViewChild()
            in the memberedit component ts

            @ViewChild('editForm') editForm: NgForm | undefined

            then the forms values can be accessed or reset in this case:
              updateMember(){
                    console.log("Updating Member: ",this.member)
                    this.toastr.success("Profile Updated Successfully")
                    this.editForm?.reset(this.member)
                }

            !!the name property of each form fied is criticval for angular to map the field to the models property 2 way thus if mispelled or case is wrong shit gets f'ed in the a when you go to submit the form dont fuck it up 

    Prevent Navigation away from page if unsaved changes exist:
        CanDeactivate Gaurd is just the ticket:
        
        ng cli:
            ng g g _gaurds/prevent-unsaved-changes
                select canDeactivate unselect activate

        preventUnsavedChangesGuard.ts
            export const preventUnsavedChangesGuard: CanDeactivateFn<MemberEditComponent> = (component) => {
                if(component.editForm?.dirty){
                    return confirm('Are you sure you want to continue? all unsaved changes will be lost')
                }
                return true;
            };

        apply this gaurd to the route in question:
            {path: 'member/edit', component: MemberEditComponent, canDeactivate: [preventUnsavedChangesGuard]},


        this will not prevent navigate to entirely different domains need access to the browser for this.
        @Hostlistener is the ticket for this

        this bad boy gone be huge for user sanity
          @HostListener('window:beforeunload', ['$event']) unloadNotification($event: any){
            if(this.editForm?.dirty){
            $event.returnValue = true
        }

    Persisting the Changes to the api:
        create memberUpdateDtop:
            namespace TeborawAPI.DTOs;
            public class MemberUpdateDTO
            {
                public string Introduction { get; set; }
                public string LookingFor { get; set; }
                public string City { get; set; }
                public string Country { get; set; }
                public string Interests { get; set; }
            }
        add mapping profile:
            CreateMap<MemberUpdateDTO, AppUser>();

        updateuser via UsersController:
            [HttpPut]
            public async Task<ActionResult> UpdateUser(MemberUpdateDTO memberUpdateDto)
            {
                //THe username will be accessble via the claims principle of the user obtain via the token passed 
                //in via the headed of this request
                //debug will show this > user >results view > 
                //[0] > ex: {http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier: lisa}
                //nameidentifier: lisa or the value of 0 array memebr will be the user name as establishe in the Token service
                // Via new Claim(JwtRegisteredClaimNames.NameId, user.UserName),
                var username = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                var user = await _userRepository.GetUserByUsernameAsync(username);
                
                if(user == null) return NotFound();

                _mapper.Map(memberUpdateDto, user);

                if (await _userRepository.SaveALlAsync()) return NoContent();

                return BadRequest("Failed to Update User");
            }

    Wire in the api endpoint to the frontend:  
        update memberService:   
              updateMember(member:Member){
                return this.http.put(this.baseUrl + 'users', member)
            }
        Utilize this in the MemberEditComponent:
            updateMember(){
                console.log("Updating Member: ",this.member)
                this.memberService.updateMember(this.editForm?.value).subscribe({
                next: _ =>{
                    this.toastr.success("Profile Updated Successfully")
                    this.editForm?.reset(this.member)
                }
                })
            }

    Adding a loading indicator upon updates:
        install a spinner -> ngx-spinner 
            https://napster2210.github.io/ngx-spinner/
            
            npm install :
                npm install ngx-spinner --save

        Add the css for animations:
            angular.json:
                "node_modules/ngx-spinner/animations/square-spin.css"
            style.css
                @import "node_modules/ngx-spinner/animations/square-spin.css";
        
        import into the share modules:
            NgxSpinnerModule.forRoot({
                type: 'square-spin'
            }),
        Export the module as well:
            NgxSpinnerModule,

        now to add a effectively an interceptor to show the loading bar upon http request:
            create busy service ng cli to display the spinner :
                ng g s _services/busy
                BusyService:
                    @Injectable({
                        providedIn: 'root'
                    })
                    export class BusyService {
                        busyRequestCount = 0;
                        constructor(private spinnerService : NgxSpinnerService) { }

                        busy(){
                            this.busyRequestCount++
                            this.spinnerService.show(undefined, {
                            type: 'square-spin',
                            bdColor: 'grey',
                            color: 'blue'
                            })
                        }

                        idle(){
                            this.busyRequestCount--
                            if(this.busyRequestCount <= 0){
                            this.busyRequestCount = 0
                            this.spinnerService.hide();
                            }
                        }
                    }

        apply this service to an interceptor 
            ng cli:
                ng g interceptor _interceptors/loading

            loadingInterceptor:

                @Injectable()
                    export class loadingInterceptor implements HttpInterceptor{

                    constructor(private busyService: BusyService){}

                    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
                        this.busyService.busy();
                        return next.handle(req).pipe(
                        //this is a synthetic delay for development to allow for loading bar to show itself
                        delay(1000),
                        finalize(()=> {
                            this.busyService.idle()
                        })
                        )
                    }
                }

        Slap that Interceptor into the app.modules providor:
            {provide: HTTP_INTERCEPTORS, useClass: LoadingInterceptor, multi:true},

        need to add the spinner to the appcomponent // the root component of the entire app allowing the spinner potential to show on any page or route:
            app.component.html:
                <ngx-spinner type = "square-spin" [fullScreen] = "true"><p style="color: white" > Loading... </p></ngx-spinner>

    TIme to cache the data you already done did load like, the users info  and the photos n such:
        you can cache data within a service:
            member service ftw:
                add a global member list
                    members : Member[] = [];

                then either populate the members if its empty or return the member usinf of() rxjs to return an observable
                    //member deets are conveniently housed in the member list, so if that was already loaded you can get it from there without phoning home
                    getMembers(){
                        if(this.members.length > 0) return of(this.members)
                        return this.http.get<Member[]>(this.baseUrl + 'users').pipe(
                        map(members =>{
                            this.members = members
                            return members
                        })
                    )}
        now you will not a distinct lack of loading screen after loading memebrs for the first time and then loading it again

        NOTE BUG: Journal and about pages redirect the user from the app entirely and clear out services 
            this is prolly due to them not being in the same route child group and outside of them may want toplay around wiht this later to see 
            what I can do to address that.

        SHould also cache the individual member details as well 
            //member deets are conveniently housed in the member list, so if that was already loaded you can get it from there without phoning home
            getMember(username:string){
                const member = this.members.find(x => x.userName === username)
                if(member) return of(member)
                return this.http.get<Member>(this.baseUrl + 'users/' + username);
                //not needed any more now that jwt interceptor is in place
                //return this.http.get<Member>(this.baseUrl + 'users/' + username, this.getHttpOptions());
            }

        also update profile changes need the cache to be updated as well:
            //cached data needs updated so that the user can see his update details if he re-nav'd to his profile after updates
            updateMember(member:Member){
                return this.http.put(this.baseUrl + 'users', member).pipe(
                map(()=>{
                    const index = this.members.indexOf(member)
                    //... is the spread operator will spread all the propertied of the member at this.members specified index and will map then
                    // the properties from the parameter and updated member 1 to 1 , because they are the same type it will update each field with out
                    // a literal loop needed to be defined
                    this.members[index] = {...this.members[index], ...member}
                })
                )
            }

    Lastly Modify the way the members are load make it an observable:
        allow for better readability.
        MemberListComponent:
            export class MemberListComponent implements OnInit {
                members$ : Observable<Member[]> | undefined


                constructor(private memberService:MembersService){}

                ngOnInit(): void {
                    this.members$ = this.memberService.getMembers();
                }

            }
        MemberListComponent.html:
            <div class="row">
                <div class="col-2" *ngFor="let member of members$ | async">
                    <app-member-card [member]="member"></app-member-card>
                </div>
            </div>

    Conclusion:
        Real fuckin neat section really learned a whole bunch of design pradignms with angular and services, and interceptors,
        and how service act as singletons allowing for the caching of data reducing the db calll backs that occur

January 30 2024:
    Adding image upload functionality:
        goals:
            photo storage options 
            added related entities 
            using 3rd party api's 
            debug dis shit
            updating and deleting resources 
            what to return when creating resources in rest based api (representative state transfer)

    Photo storage options:  
        store as blobs in the db  but not an effiecient way to do this as dbs are'nt optimized for this 
        server filesystem > not a bad option downsides: space issues concerns if the file servfer is on the same pace as webserver, 
            image variability and types and aspect ratios
        Account service : virtual unlimited space but at a cost 
    
    Cloudinary Photo storage:
        has free tier with 10gb of storage with image translations and storage

    Image upload workflow:
        client uploads photo to api with jwt 
        server uploads the photo to cloudinary 
        cloudinary stores the photo andd sends response 
        api saves thes the photo url and the public id to the DB 
        saved in adb and given autogenerated id 
        201 created response sent to the client with location header

        photo <-> a p i <-> cloudinary 
                    |
                   db 

    Create cloudinary account:
        https://console.cloudinary.com/console/c-a47dee7f03fb19a983847ec6bf2c31/welcome
        api documentation:
            https://cloudinary.com/documentation/dotnet_integration

    Setup the api with cloudinary;
        install nuget cloudinary package: 
            CloudinaryDotNet

        Configure setting in the appsettings.json
            git ignore this file now 
            add api details:
                "CloudinarySettings":{
                    "CloudName": "",
                    "ApiKey": "",
                    "ApiSecret": ""
                },

    Create helper cloudinarysetting.cs
        public class CloudinarySettings
        {
            public string Name { get; set; }
            public string ApiKey { get; set; }
            public string ApiSecret { get; set; }
        }
    
    Add the cloudinary service to ApplicationServiceExtensions using the helper to hose the env config vars
        services.Configure <CloudinarySettings>(config.GetSection("CloudinarySettings"));


    Create photo upload service :
        create the interface first:
            namespace TeborawAPI.Interfaces;
            public interface IPhotoService
            {
                Task<ImageUploadResult> AppPhotoAsync(IFormFile file);
                Task<DeletionResult> DeletePhotoAsync(string publicId);
            }
        Create the service implementing the interface:
            public class PhotoService : IPhotoService
            {
                private readonly Cloudinary _cloudinary;
                public PhotoService(IOptions<CloudinarySettings> config)
                {
                    var acc = new Account(
                        config.Value.CloudName,
                        config.Value.ApiKey,
                        config.Value.ApiSecret
                    );

                    _cloudinary = new Cloudinary(acc);
                }
                public async Task<ImageUploadResult> AppPhotoAsync(IFormFile file)
                {
                    var uploadResults = new ImageUploadResult();
                    if (file.Length > 0)
                    {
                        using var stream = file.OpenReadStream();
                        var uploadParams = new ImageUploadParams
                        {
                            File = new FileDescription(file.FileName, stream),
                            Transformation = new Transformation().Height(500).Width(500).Crop("fill").Gravity("face"),
                            Folder = "Teboraw-net8"
                        };
                        uploadResults = await _cloudinary.UploadAsync(uploadParams);
                    }

                    return uploadResults;
                }

                public async Task<DeletionResult> DeletePhotoAsync(string publicId)
                {
                    var deleteParams = new DeletionParams(publicId);
                    return await _cloudinary.DestroyAsync(deleteParams);
                }
            }
        Add the service to extension:
            services.AddScoped<IPhotoService, PhotoService>();

    Inject that service to the users controller create endpoint:
        create extension class to provide for the username and user data quickly and reduce code duplication:
            public static class ClaimsPrincipalExtensions
            {
                public static string GetUserNamethis ClaimsPrincipal user)
                {
                    return user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                }
            }

        public static string GetUserNamethis ClaimsPrincipal user)
            allows you to exted the ClaimsPrincipal as if you were inside the class itself adding a method or creating a class that extends it with additional functionality
            its dope as fuck you dont have to go through all that noise just for one method and you can call it then like this:

            var username = User.GetUserName();

            UserController:
                [HttpPost("add-photo")]
                public async Task<ActionResult<PhotoDTO>> AddPhoto(IFormFile file)
                {
                    var user = await _userRepository.GetUserByUsernameAsync(User.GetUserName());
                    if (user == null) return NotFound();
                    var result = await _photoService.AppPhotoAsync(file);
                    if(result.Error != null) return BadRequest(result.Error.Message);
                    var photo = new Photo
                    {
                        Url = result.SecureUrl.AbsoluteUri,
                        PublicId = result.PublicId
                    };

                    if (user.Photos.Count == 0) photo.IsMain = true;

                    user.Photos.Add(photo);
                    
                    if(await _userRepository.SaveALlAsync()) return _mapper.Map<PhotoDTO>(photo);

                    return BadRequest("Problem Adding Photo");
                }

    Testing the photo upload:
        ran into image upload error:
            hadd to install the standalone postman client to get it access to my local drive and all is 
            
        postman > teboraw > photos upload and delete test > Add photo 
            set the body > file value to a local picture and watch teh magic

        Quick not the key value is called File and that should match with what the parameter is called and spelled as in the :
            user controller > addPhoto > IFormFile file

    Return the right response for post request that creates a new resource:
        SHould return ideally a 201 response instead of 200ok response 
        this will have a location url response with the new content.
        usercontroller:
        //need to return a 201 response instead of 200 with new resource url not this way 
            //if(await _userRepository.SaveALlAsync()) return _mapper.Map<PhotoDTO>(photo);
            //This way below create a action or enpoint utl to the getuser endpoint passing in the username as an object 
            //along with the mapped photo
            if(await _userRepository.SaveALlAsync())
                return CreatedAtAction(nameof(GetUser), 
                    new { username = user.UserName }, 
                    _mapper.Map<PhotoDTO>(photo));

        retest the endpoint in postman and you will see an additiona field in the header returns with 
        location : https://localhost:5001/api/Users/lisa 
        along with a 201 reponse


    Adding the phot upload component to angular:
        ng cli:
            ng g c member/photo-editor

            html:
                <div class="row" *ngIf="member">
                    <div class="col-2" *ngFor="let photo of member.photos">
                        <img src="{{photo.url}}" alt="photo of user" class="img-thumbnail mb-1">
                        <div class="text-center">
                        <button class="btn btn-sm">Main</button>
                        <button class="btn btn-sm btn-danger"><i class="fa fa-trash"></i></button>
                        </div>
                    </div>
                </div>


        add the compoennt to the edit component tab:
            <tab heading="Edit Photos">
                <app-photo-editor [member]="member"></app-photo-editor>
            </tab>

    Create photo upload:
        need to install the file uploader util 
        ng2-file-upload
            https://valor-software.com/ng2-file-upload/

        npm install:
            npm install ng2-file-upload --save
            what do you know it dont work for 17 fudger

            I used the following, which ties it to the version you otherwise have installed (so you don't have to muck with the versions manually over time). Thanks for the tip!
        package.json add
            "overrides": {
                "ng2-file-upload": {
                "@angular/common": "$@angular/common",
                "@angular/core": "$@angular/core"
                }
            }

        Then cli install:
            npm install ng2-file-upload --save


        copy the ng2 file boiler plate 
            to the photo editor

        Add the file uploader module to the share modules:
            import and export FileUploadModule

        photoeditor component ts: 
            quite alot going on here not sure what everything is dpoing will need to review later:
                export class PhotoEditorComponent implements OnInit{
                    @Input() member: Member | undefined
                    uploader : FileUploader | undefined
                    hasBaseDropzoneOver = false
                    baseUrl = environment.apiUrl
                    user: User |undefined
                    constructor(private accountService: AccountService) {
                        this.accountService.currentUser$.pipe(take(1)).subscribe({
                        next: user=>{
                            if(user) this.user = user
                        }
                        })
                    }

                    ngOnInit() {
                        this.initializeUploader()
                    }

                    fileOverBase(e: any){
                        this.hasBaseDropzoneOver = e;
                    }
                    initializeUploader(){
                        this.uploader = new FileUploader({
                        url: this.baseUrl + 'users/add-photo',
                        authToken: 'Bearer ' + this.user?.token,
                        isHTML5: true,
                        allowedFileType: ['image'],
                        removeAfterUpload: true,
                        autoUpload: false,
                        maxFileSize: 10 * 1024 *1024
                        })
                        this.uploader.onAfterAddingFile = (file) => {
                        file.withCredentials = false
                        }

                        this.uploader.onSuccessItem = (item, response, status, headers){
                        if(response){
                            const photo = JSON.parse(response)
                            this.member?.photos.push(photo)
                        }
                        }
                    }
                }

        Adjust the html and type checks:
            way too much code to really copy and paste byt 
            photoeditor was modified to pull the boiler and add optionals to potential nulls and delete the extra progress bars and info to fit on tab 
            styling added to allow file drag to highlight the upload box 

        Allow selection of main photo:
            create a endpoint in th euser controller to set main photo:
                quite a bit of null checking here 
                [HttpPut("set-main-photo/{photoId}")]
                public async Task<ActionResult> SetMainPhoto(int photoId)
                {
                    var user = await _userRepository.GetUserByUsernameAsync(User.GetUserName());
                    
                    if(user == null) return NotFound();
                    
                    var photo = user.Photos.FirstOrDefault(x => x.Id == photoId);
                    
                    if(photo == null) return NotFound();
                    
                    if (photo.IsMain) return BadRequest("This is already the main photo!");
                    
                    var currentMain = user.Photos.FirstOrDefault(x => x.IsMain);

                    if (currentMain != null) currentMain.IsMain = false;
                    photo.IsMain = true;
                    
                    if(await _userRepository.SaveALlAsync()) return NoContent();

                    return BadRequest("There was a problem setting the main photo");
                }

            postman is happy 

        Now to set the ui to allow for main photo setting:
            add the photo to the navebar:
                need to apply the photo url of the main photo to the userDto Object:
                    public string PhotoUrl { get; set; }
                return this value with the account contorller getuser endpoint:
                    return new UserDTO()
                    {
                        Username = user.UserName,
                        Token = _tokenService.CreateToken(user),
                        PhotoUrl = user.Photos.Include(p => p.Photos).FirstOrDefault(x => x.IsMain)?.Url
                    };
                add prop to user ts as well 
                    export interface User {
                        username: string;
                        token: string;
                        photoUrl: string;
                    }
            refactor the current user local storage call in account services

            in the navbar.htm set the now availble image url to the user:
                add image tage to the user dropdown
                    <img src="{{user.photoUrl}}" alt="user photo">
                add a bit of styling 
                    img{
                        max-height: 50px;
                        border: 2px solid white;
                        display: inline;
                    }

            Amake sure to include the photos otherwize ef will be lazy and not load it on th elogin call

            now to allow the user to set a main:
                update the mmebr service to hit the update main photo endpoint:
                    setMainPhoto(photId: number){
                        return this.http.put(this.baseUrl + 'users/set-main-photo/' + photId, {})
                    }
                photo.editor.ts 
                    setMainPhoto(photo: Photo){
                        this.memberService.setMainPhoto(photo.id).subscribe({
                        next: () => {
                            if(this.user && this.member){
                            this.user.photoUrl = photo.url
                            // this will broadcas the phot update to all the subscribers ie the nave bar n such
                            this.accountService.setCurrentUser(this.user)
                            this.member.photoUrl = photo.url
                            this.member.photos.forEach(p => {
                                if(p.isMain) p.isMain = false
                                if(p.id === photo.id) p.isMain = true;
                            })
                            }
                        }
                        })
                    }

                photo.editor.html:
                //this code will disable the set main button if already main 
                // and change styling based on if its main or not
                    <button
                        class="btn btn-sm"
                        [disabled]="photo.isMain"
                        (click)="setMainPhoto(photo)"
                        [ngClass]="photo.isMain ? 'btn-success active' : 'btn-outline-success'"
                    >Main</button>


        Deleting Photos:
            add api ep in userController:
                [HttpDelete("delete-photo/{photoId}")]
                public async Task<ActionResult> DeletePhoto(int photoId)
                {
                    var user = await _userRepository.GetUserByUsernameAsync(User.GetUserName());

                    var photo = user.Photos.FirstOrDefault(x => x.Id == photoId);
                    
                    if(photo == null) return NotFound();
                    
                    if(photo.IsMain) return BadRequest("You cannot delete your main photo.");
                    
                    if(photo.PublicId != null)
                    {
                        var result = await _photoService.DeletePhotoAsync(photo.PublicId);
                        if(result.Error != null) return BadRequest(result.Error.Message);
                    }

                    user.Photos.Remove(photo);
                    
                    if(await _userRepository.SaveALlAsync()) return Ok();

                    return BadRequest("Problem Deleting Photo");
                }
            add member service method to delete the photo:
                deletePhoto(photoId:number){
                    return this.http.delete(this.baseUrl + 'users/delete-photo/' + photoId)
                }

            Call the delete phot service from the photo editor:
                deletePhoto(photoId:number){
                    this.memberService.deletePhoto(photoId).subscribe({
                    next: _ => {
                        if(this.member){
                        //this createed the member photo list with all photos but the one being deleted
                        this.member.photos = this.member.photos.filter(x => x.id != photoId)
                        }
                    }
                })
                                
            wire up the html template: 
                  <button
                        class="btn btn-sm btn-danger"
                        [disabled]="photo.isMain"
                        (click)="deletePhoto(photo.id)"
                    ><i class="fa fa-trash"></i></button>
        done diggity delete works yo!!!

January 31, 2024:
    Reactive Forms:
        goals:
            using reactive forms 
            angular validation 
            custom validatior 
            reusable form controls 
            date imputs 

    Need to import reactive form app.module:
        imports:[ReactiveFormsModule]

    registerComponent change from template forms to reactive:
        reactive forms are component base instead embedded in the template as ngForms better for testing,

        create form prop in the component:
            registerForm: FormData | undefined
              initializeFrom(){
                this.registerForm = new FormGroup({
                    username: new FormControl(),
                    password: new FormControl(),
                    confirmPassword: new FormControl()
                    })
                }

        in the html template decLare as formgroup instead of ngForm:  
            <form [formGroup]="registerForm" (ngSubmit)="register()" autocomplete="off">

            convert the input to a formcontrol going from :
            <input type="text"
                class="form-control"
                name="username"
                [(ngModel)]="model.username"
                placeholder="Username">
            to:
                <input type="text"
                    class="form-control"
                    formControlName="username"
                    placeholder="Username">

            add a bit of debuggalation for now to see vals 
            <p> Form value: {{registerForm.value | json }}</p>
            <p> Form Status: {{registerForm.status | json}}</p>

    Validate dat form:
        need to do that in the ts component just need to pass in the validator options 
              initializeFrom(){
                this.registerForm = new FormGroup({
                username: new FormControl('Hello', Validators.required),
                password: new FormControl('',[Validators.required, Validators.minLength(6), Validators.maxLength(30)]),
                confirmPassword: new FormControl('', Validators.required)
            })

        match the password and confirm password field:
                confirmPassword: new FormControl('', [Validators.required, this.matchValues('password')])
                })
            }

            matchValues(matchTo: string) : ValidatorFn{
                return(control: AbstractControl) => {
                return control.value === control.parent?.get(matchTo)?.value ? null : {notMatching : true}
                }
            }

        now the confirm password is dependent on the password field to match however the password field does not depend on the confirm 
        meaning user could end up correcting the password field and the 
        form will still be valid cahnge in the password does not trigger a validation check:

        need to add a listener or observer subscribtion on the password control:
            this.registerForm.controls['password'].valueChanges.subscribe({
                next: () => this.registerForm.controls['confirmPassword'].updateValueAndValidity()
            })

        add validation ui elements:
            add this to the field
                <input type="text"
                    [class.is-invalid]="registerForm.get('username')?.errors && registerForm.get('username')?.touched"
                    class="form-control"
                    autocomplete="off"
                    formControlName="username"
                    placeholder="Username">
            this will highlight the field if empty and the user has previously touched it:

            add div to show th input error:    
                <div class="mb-3">
                    <input type="text"
                        [class.is-invalid]="registerForm.get('username')?.errors && registerForm.get('username')?.touched"
                        class="form-control"
                        autocomplete="off"
                        formControlName="username"
                        placeholder="Username">
                    <div class="invalid-feedback">Please Enter Valid Username</div>
                </div>
            multiple validation div:
                    <div class="mb-3">
                        <input type="password"
                        [class.is-invalid]="registerForm.get('password')?.errors && registerForm.get('password')?.touched"
                        class="form-control"
                        formControlName = "password"
                        placeholder="Password">
                    <div class="invalid-feedback" *ngIf="registerForm.get('password')?.hasError('required')">
                        Please Enter a Password
                    </div>
                    <div class="invalid-feedback" *ngIf="registerForm.get('password')?.hasError('minlength')">
                        PW must be atleast 6 chars
                    </div>
                    <div class="invalid-feedback" *ngIf="registerForm.get('password')?.hasError('required')">
                        PW must be at most 30 Charaters
                    </div>
                    </div>

        THeres gotta be a less messy to do this:
            Create reusable text input components 
                create a new component:
                    ng g c _forms/text-input
            
            text-input.ts:
            implement ControlValueAccessor which allows the component to act as a bridge between the angular forms api and a netive element in the dom
                export class TextInputComponent implements ControlValueAccessor
                      registerOnChange(fn: any): void {
                        }

                        registerOnTouched(fn: any): void {
                        }

                        writeValue(obj: any): void {
                        }
                        get control():FormControl{
                            return this.ngControl.control as FormControl
                        }

            text-input html:
                <div class="mb-3">
                    <input type="{{type}}"
                            [class.is-invalid]="control.touched && control.invalid"
                            class="form-control"
                            [formControl]="control"
                            placeholder={{label}}
                    >
                    <div class="invalid-feedback" *ngIf="control.errors?.['required']">
                        Please Enter a {{label}}
                    </div>
                    <div class="invalid-feedback" *ngIf="control.errors?.['minlength']">
                        {{label}} must be at least {{ control.errors?.['minlength'].requiredLength}} characters
                    </div>
                    <div class="invalid-feedback" *ngIf="control.errors?.['maxlength']">
                        {{label}} must be at most {{ control.errors?.['maxlength'].requiredLength}} characters
                    </div>
                    <div class="invalid-feedback" *ngIf="control.errors?.['notMatching']">
                        Passwords do not match
                    </div>
                </div>

            the component can now be generated and added to the register template:
                    <app-text-input [formControl]="$any(registerForm.controls['username'])" [label]="'Username'"></app-text-input>
                    <app-text-input [formControl]="$any(registerForm.controls['password'])" [label]="'Password'" [type]="'password'"></app-text-input>
                    <app-text-input [formControl]="$any(registerForm.controls['confirmPassword'])" [label]="'Confirm Password'" [type]="'password'"></app-text-input>


            Form Builder to simplify forms:
                inject private fb : FormBuilder
                initialize form via:
                    this.registerForm = this.fb.group({
                        username: ['', Validators.required],
                        password: ['',[Validators.required, Validators.minLength(6), Validators.maxLength(30)]],
                        confirmPassword:['', [Validators.required, this.matchValues('password')]]
                    })

    Expand the forms:   
            <app-text-input [formControl]="$any(registerForm.controls['username'])"
                    [label]="'Username'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['knownAs'])"
                            [label]="'Known As'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['dateOfBirth'])"
                            [label]="'Date Of Birth'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['city'])"
                            [label]="'city'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['country'])"
                            [label]="'country'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['username'])"
                            [label]="'Username'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['password'])"
                            [label]="'Password'"
                            [type]="'password'"></app-text-input>
            <app-text-input [formControl]="$any(registerForm.controls['confirmPassword'])"
                            [label]="'Confirm Password'"
                            [type]="'password'"></app-text-input>
        
        this.registerForm = this.fb.group({
            gender:           ['male'],
            username:         ['', Validators.required],
            knownAs:          ['', Validators.required],
            dateOfBirth:      ['', Validators.required],
            city:             ['', Validators.required],
            country:          ['', Validators.required],
            password:         ['',[Validators.required, Validators.minLength(6), Validators.maxLength(30)]],
            confirmPassword:  ['', [Validators.required, this.matchValues('password')]]
        })

    Input validation dates:
        creating a date picker component that is not browser specific:
            mgx-bootstrap datepicker :
                ng g c _forms/date-picker

            add ngx datepick module:
                import and export BsDatepickerModule in shared modules 
            
            date-picker component:
                 DatePickerComponen implements ControlValueAccessor
                    @Input() label = ''
                    @Input() maxDate: Date | undefined;
                    bsConfig: Partial<BsDatepickerModule> | undefined
                    constructor(@Self() public ngControl: NgControl) {
                        this.ngControl.valueAccessor = this
                        this.bsConfig = {
                        containerClass : 'theme-red',
                        dateInputFormat: 'DD MMMM YYYY'
                        }
                    }

                <div class="md-3">
                    <input
                        type="text"
                        [class.is-invalid]="control.touched && control.invalid"
                        [formControl]="control"
                        placeholder="{{label}}"
                        bsDatepicker
                        [bsConfig]="bsConfig"
                        [maxDate]="maxDate"
                    >
                    <div *ngIf="control.errors?.['required']" class="invalid-feedback">
                        {{label}} is required
                    </div>
                </div>


            Register component:
                <app-date-picker [formControl]="$any(registerForm.controls['dateOfBirth'])"
                    [label]="'Date Of Birth'"> </app-date-picker>

            put a minumum dob in place:
                register component:
                    this.maxDate.setFullYear(this.maxDate.getUTCFullYear() -18)

                THis will limit the year ange of selectable dates from the picker 

    Server side validation:
        add the user field to the dto Register dto 
    
            [Required] public string KnownAs { get; set; }
            [Required] public string Gender { get; set; }
            [Required] public DateOnly? DateOfBirth { get; set; } // optional to make required work
            [Required] public string City { get; set; }
            [Required] public string Country { get; set; }  

        setup automapper:
            CreateMap<RegisterDTO, AppUser>();
               
        inject the automapper to the account controller:
            IMapper mapper)

        Adjust register enpoint with automapper:
            [HttpPost("register")] // api/account/register
            public async Task<ActionResult<UserDTO>> Register(RegisterDTO registerDTO)
            {
                if (await UserExists(registerDTO.Username)) return BadRequest("Username already exists");

                using var hmac = new HMACSHA512();
                
                var user = _mapper.Map<AppUser>(registerDTO);
                
                user.UserName = registerDTO.Username.ToLower();
                user.PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(registerDTO.Password)),
                user.PasswordSalt = hmac.Key;

                _context.Users.Add(user);
                await _context.SaveChangesAsync();
                return new UserDTO()
                {
                    Username = user.UserName,
                    Token = _tokenService.CreateToken(user),
                    PhotoUrl = user.Photos.FirstOrDefault(x => x.IsMain)?.Url,
                    KnownAs = user.KnownAs
                };
            }

    Client Side Registration:
        registerComponent:
            Redirect to members page:
                inject router and use it to redirect on success register
                  register() {
                        this.accountService.register(this.model).subscribe({
                        next: response => {
                            console.log("registration complete",response);
                            this.router.navigateByUrl('/members')
                        },
                        })
                        console.log(this.registerForm?.value)
                    }

            Create validation error instead of toast message:
                pipe the error into  a string array upon register failure
                error: error => {
                    this.validationErrors = error
                }
            
        registerComponent.html:
            add the validation errors if exists:
                <div class="row" *ngIf="validationErrors">
                    <ul class="text-danger">
                        <li *ngFor="let error of validationErrors">{{error}}</li>
                    </ul>
                </div>

        registerComponent.ts:
            needs to use the reactive form instead of the ng form:
                this.accountService.register(this.registerForm.value)
            need to message the date input:
                to utc standard remove the date time offset dont need time for dob
                private getDateOnly(dob : string | undefined){
                    if(!dob) return
                    let theDob = new Date(dob);
                    return new Date(theDob.setMinutes(theDob.getMinutes() - theDob.getTimezoneOffset()))
                    .toISOString().slice(0,10)
                }

        Disable register button if form not valid:
            <button class="btn btn-success me-2" type="submit" [disabled]="!registerForm.valid">Register</button>

        prevent form submition on template if form isnt valid:
            <form [formGroup]="registerForm" (ngSubmit)="registerForm.valid && register()" autocomplete="off">

        photo upload does not auto update the profile pic need to :
            PhotoEditorComponent.ts:
                    this.uploader.onSuccessItem = (item, response, status, headers) => {
                        if(response){
                            const photo = JSON.parse(response)
                            this.member?.photos.push(photo)
                            if(photo.isMain && this.user && this.member){
                            this.user.photoUrl = photo.url
                            this.member.photoUrl = photo.url
                            this.accountService.setCurrentUser(this.user)
                        }

February 1 2024
    Paging Sorting and filtering:
        Goals:
            implement paging sorting and filtering 
            learning how to implement on both api and client 
            deferred execution using iqueryable 
            using action filters 
            adding a tameago pipe
            implement caching on the client side 

        avaodining performance problems by only show current viewable data:
        pass parameters for pagination via query string

        Deferred Excution using Iqueryable:
            Iquery:
                var query = context.users
                    .where()
                    .orderby()
                    .take(5)
                    .skip(5)
            Execution:
                querty.ToListAsync()

    Paginating getMembers > UserRepository :
        Create an API helper to genralize paging

        PageList.cs :
            //WIld shit is happening here, static method calls the db to determine how many entires exist in a given 
            // db iqueryable source context then selects the data from the context base on the page number and size passed in
            // returns a new instance of this class with the results. and stores the params passed in 
            public class PageList<T> : List<T>
            {
                public PageList(IEnumerable<T> items, int count, int pageNumber, int pageSize)
                {
                    CurrentPage = pageNumber;
                    TotalPages = (int) Math.Ceiling(count / (double) pageSize);
                    PageSize = pageSize;
                    TotalCount = count;
                    //Adds the items to the class itself 
                    AddRange(items);
                }

                public int CurrentPage { get; set; }
                public int TotalPages { get; set; }
                public int PageSize { get; set; }
                public int TotalCount { get; set; }

                
                public static async Task<PageList<T>> CreateAsync(IQueryable<T> source,
                    int pageNumber, int pageSize)
                {
                    var count = await source.CountAsync();
                    var items = await source.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();
                    return new PageList<T>(items, count, pageNumber, pageSize);
                }
            }

        Create another helper to translate the pagelist to frond end accessible data:
            PaginationHeader.cs:
                public class PaginationHeader
                {
                    public PaginationHeader(int currentPage, int itemsPerPage, int totalItems, int totalPages)
                    {
                        CurrentPage = currentPage;
                        ItemsPerPage = itemsPerPage;
                        TotalItems = totalItems;
                        TotalPages = totalPages;
                    }

                    public int CurrentPage { get; set; }
                    public int ItemsPerPage { get; set; }
                    public int TotalItems { get; set; }
                    public int TotalPages { get; set; }
                }
            THis will be returned inside of an http respose need to extend the http class to allow for this:
                extenstions/HttpExtensions
                    namespace TeborawAPI.Extensions;

                    public static class HttpExtensions
                    {
                        public static void AddPaginationHeader(this HttpResponse response, PaginationHeader header)
                        {
                            var jsonOptions = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
                            //Creates the custom header with the pagination data
                            response.Headers.Append("Pagination", JsonSerializer.Serialize(header,jsonOptions));
                            //Cors needs updated to allow for this nonsense as well
                            response.Headers.Append("Access-Control-Expose-Headers", "Pagination");
                        }
                    }
                    //not sur if add or append is the way to go for this header

        Create userparams helpers so that the client can pass the pagination values:
            helpers/UserParams:
                public class UserParams
                    {
                        private const int MAX_PAGE_SIZE = 50;
                        public int PageNumber { get; set; } = 1;
                        private int _pageSize = 10;

                        public int PageSize
                        {
                            get => _pageSize;
                            set => _pageSize = (value > MAX_PAGE_SIZE) ? MAX_PAGE_SIZE : value;
                        }
                    }

        Wire everything up to see what the hell is going on here:
            IUserRepository:
                Update:
                    Task<IEnumerable<MemberDTO>> GetMembersAsync();
                To:
                    Task<PageList<MemberDTO>> GetMembersAsync(UserParams userParams);
            UserRepository modify the implementation:
                public async Task<PageList<MemberDTO>> GetMembersAsync(UserParams userParams)
                    {
                        var query =  _context.Users
                            .ProjectTo<MemberDTO>(_mapper.ConfigurationProvider)
                            //Add this because this list is not expected to be modifioed from the front end tiny more effiecent
                            .AsNoTracking();
                        return await PageList<MemberDTO>.CreateAsync(query, userParams.PageNumber, userParams.PageSize);
                    }

            UserController can now request paginated data:
                GetUsers:
                    /[FromQuery] will dictate the api endpoint call will be in the form of /api/users?pageNumber=1&pageSize=5
                    [HttpGet]
                    public async Task<ActionResult<IEnumerable<MemberDTO>>> GetUsers([FromQuery]UserParams userParams)
                    {
                        var users = await _userRepository.GetMembersAsync(userParams);
                        
                        Response.AddPaginationHeader(new PaginationHeader(users.CurrentPage, users.PageSize,users.TotalCount,users.TotalPages));
                        
                        return Ok(users);
                        
                    }
                        
            Bug: Pagination didnt properly return due to double parathenses

    Setup Client side Pagination:
    //generalized interface and class implementation to retrieve paginated data from the api and keep track of it 
        Create new model :  
            _models/pagination.ts
                export interface Pagination{
                    currentPage: number
                    itemsPerPage: number
                    totalItems: number
                    totalPages: number

                }

                export class PaginatedResult<T>{
                    result?: T
                    pagination?: Pagination 
                }

        update member service to use the paginated results:
          getMembers(page? : number, itemsPerPage?: number){
            let params = new HttpParams()
            if(page && itemsPerPage){
                params = params.append('pageNumber', page)
                params = params.append('pageSize', itemsPerPage)
            }
            return this.http.get<Member[]>(this.baseUrl + 'users', {observe: 'response', params}).pipe(
                map(response => {
                    if(response.body){
                        this.paginatedResult.result = response.body
                    }
                    const pagination = response.headers.get('Pagination')
                    if(pagination){
                        this.paginatedResult.pagination = JSON.parse(pagination)
                    }
                    return this.paginatedResult
                })
            )  
          }

        need to update the member-list component and html to handle this paginate datatype
            created load members that utilized ned service getmembrs call with pagination in the header:
              ngOnInit(): void {
                    //this.members$ = this.memberService.getMembers();
                    this.loadMembers()
                }

                loadMembers(){
                    this.memberService.getMembers(this.pageNumber, this.pageSize).subscribe({
                    next: response => {
                        if(response.result){
                        this.members = response.result
                        this.pagination = response.pagination
                        }
                    }
                    })
                }

        ADd a component to allow page selection and count:
            pull the pagination component from ngx-bootstrap:
                PaginationModule > shared Module.ts
                    import annd export PaginationModule.forRoot()

            custom Links content get the template from site:
                https://valor-software.com/ngx-bootstrap/#/components/pagination?tab=overview
                <pagination [boundaryLinks]="true" [totalItems]="77"
                            previousText="&lsaquo;" nextText="&rsaquo;" firstText="&laquo;" lastText="&raquo;">
                </pagination>

            add the template code to the member-list component .htm:
                <div class="d-flex justify-content-center" *ngIf="pagination">
                    <pagination
                        [boundaryLinks]="true"
                        [totalItems]="pagination.totalItems"
                        [itemsPerPage]="pagination.itemsPerPage"
                        [maxSize]="10"
                        [(ngModel)]="pagination.currentPage"
                        (pageChanged)="pageChanged($event)"
                        previousText="&lsaquo;"
                        nextText="&rsaquo;"
                        firstText="&laquo;"
                        lastText="&raquo;">
                    </pagination>
                </div>

                create the page change ievent in the ts:
                    pageChanged($event: any) {
                        if(this.pageNumber != $event.page){
                            this.pageNumber = $event.page
                            this.loadMembers()
                        }

                    }

        Exclude the logged in user from the member llst and only include opposite gender:
            update the user params userparams.cs:
                public string CurrentUserName { get; set; }
                public string Gender { get; set; }

        Update UserCOntroller.cs:
            pull that data into the the getusers endpoint 
                var currentUser = await _userRepository.GetUserByUsernameAsync(User.GetUserName());
                userParams.CurrentUserName = currentUser.UserName;

                if (string.IsNullOrEmpty(userParams.Gender))
                {
                    userParams.Gender = currentUser.Gender == "male" ? "female" : "male";
                }
        Modify userRepository to accomodate new fields and filter them out appropriately  as well:
            public async Task<PageList<MemberDTO>> GetMembersAsync(UserParams userParams)
            {
                var query = _context.Users.AsQueryable();

                query = query.Where(u => u.UserName != userParams.CurrentUserName);
                query = query.Where(u => u.Gender == userParams.Gender);
                return await PageList<MemberDTO>.CreateAsync(
                    query.AsNoTracking().ProjectTo<MemberDTO>(_mapper.ConfigurationProvider),
                    userParams.PageNumber, 
                    userParams.PageSize);
            }
        Ran into issue where endpoint wouldnt be reached with out gender and username param being passed:
            had to adjust the UserParams.cs to make thoese fields nullable bight need to address later

        
        Additional Filters:
            By age :    
                params:
                    public int MinAge { get; set; } = 18;
                    public int MaxAge { get; set; } = 100;
            UserRepository:
                take the param and filter by min and bax age:
                    var minDob = DateOnly.FromDateTime(DateTime.Today.AddYears(-userParams.MaxAge - 1));
                    var maxDob = DateOnly.FromDateTime(DateTime.Today.AddYears(userParams.MinAge));
                    query = query.Where(u => u.DateOfBirth > minDob && u.DateOfBirth <= maxDob);

        
        Cleaning up the member Service:
            pass the gender to save an api call UserDto and return it in the account controller:
                            Gender = user.Gender
            do it in the client as well:
                user.ts:
                    export interface User {
                        username: string;
                        token: string;
                        photoUrl: string;
                        KnownAs: string
                        Gender: string
                    }

            change the member.service.ts > getMembers() call get rid of the params and send in one param object:
                create the param object as a model:
                    models/userParams.ts
                        export class UserParams{
                            gender: string
                            minAge = 18
                            maxAge = 99
                            pageNumber = 1
                            pageSIze = 5

                            constructor(user: User) {
                                this.gender = user.gender === 'female' ? 'male' : 'female'
                            }
                        }
                pass that object in as params to getMembers in member service:
                    getMembers(userParams : UserParams){
                    let params = this.getPaginationHeaders(userParams.pageNumber, userParams.pageSize);

                    creating funciton to build the params:
                    no longer have to check for null as the class already intialiazes each variable
                      private getPaginationHeaders(pageNumber:number, pageSize:number) {
                            let params = new HttpParams()
                            params = params.append('pageNumber', pageNumber)
                            params = params.append('pageSize', pageSize)
                            return params;
                        }
            Refactor the getmember http get call:
                make it type generic for reusability:
                private getPaginatedResults<T>(url: string, params: HttpParams) {
                    const paginatedResult : PaginatedResult<T> = new PaginatedResult<T>
                    return this.http.get<T>(url, {observe: 'response', params}).pipe(
                    map(response => {
                        if (response.body) {
                        paginatedResult.result = response.body
                        }
                        const pagination = response.headers.get('Pagination')
                        if (pagination) {
                        paginatedResult.pagination = JSON.parse(pagination)
                        }
                        return paginatedResult
                    })
                    )
                }
            call it from get members:
                getMembers(userParams : UserParams){
                    let params = this.getPaginationHeaders(userParams.pageNumber, userParams.pageSize);
                    params = params.append('minAge', userParams.minAge)
                    params = params.append('maxAge', userParams.maxAge)
                    params = params.append('gender', userParams.gender)
                    return this.getPaginatedResults<Member[]>(this.baseUrl + 'users',params);


        Add Filter buttons to the uid:
            MemberListComponent :
                add   genderList = [{value: 'male',display: 'males'}, {value: 'female',display: 'females'}]
                add resetFilters()
                    resetFilter(){
                        if(this.user){
                        this.userParams = new UserParams(this.user)
                        this.loadMembers();
                        }
                    }

            Create the filter form  in membet-list.component.html:
              <form #form="ngForm" class="d-flex mb-3" (ngSubmit)="loadMembers()" autocomplete="off">
                <div class="d-flex mx-2">
                <label class="col-form-label">Age from: </label>
                <input
                    type="number"
                    class="form-control ms-1"
                    style="width: 70px;"
                    name="minAge"
                    [(ngModel)]="userParams.minAge"
                >
                </div>
                <div class="d-flex mx-2">
                <label class="col-form-label">Age to: </label>
                <input
                    type="number"
                    class="form-control ms-1"
                    style="width: 70px;"
                    name="maxAge"
                    [(ngModel)]="userParams.maxAge"
                >
                </div>
                <div class="d-flex px-2">
                <label class="col-form-label me-2"> Show: </label>
                <select name="gender"
                        style="width: 130px"
                        class="form-select ms-1"
                        [ngModel]="userParams.gender">
                        <option *ngFor="let gender of genderList" [value]="gender.value">
                            {{gender.display}}
                        </option>
                </select>
            </div>

February 2 2024:
    More sorting optionsm, by last active:
        UserParams:
            Add order by prop:
                public string OrderBy { get; set; } = "lastActive";
            update the userRepository GetMembersAsync:
                query = userParams.OrderBy switch
                    {
                        "created" => query.OrderByDescending(u => u.Created),
                        _ => query.OrderByDescending(u => u.LastActive)
                    };

    Last active is not being update upon login:
        create action filter to update the last active upon user interaction on the site:
            Create a helper action filter service > logUserActivity.cs :
                //This helper will intercept specified action or http request and apply a log entry to the user how initiated it
                public class LogUserActivity: IAsyncActionFilter
                {
                    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
                    {
                        //this waits until the api has completed it task then apply a log
                        var resultContext = await next();
                        
                        //verify the user logged in and is authenticated
                        if(!resultContext.HttpContext.User.Identity.IsAuthenticated) return;

                        var username = resultContext.HttpContext.User.GetUserName();

                        var repo = resultContext.HttpContext.RequestServices.GetRequiredService<IUserRepository>();

                        var user = await repo.GetUserByUsernameAsync(username);
                        user.LastActive = DateTime.Now;
                        await repo.SaveALlAsync();
                    }
                }
            add the service to the program.cs start via ApplicationServiceExtensions.cs:
                services.AddScoped<LogUserActivity>();
            Apply the action filter to the controller:
                in this case apply is to the base controller to ensure all routes log user activity
                although this seems excessive

                BaseAPIController.cs:
                    [ServiceFilter(typeof(LogUserActivity))]
                    [ApiController]
                    [Route("api/[controller]")]
                    public class BaseAPIController: ControllerBase
                    {
                        
                    }

        making the last active update more effecient add the user id to claims priniciple
            when looking at the log to see the last active updatem theres a hell of a query going on just to retrieve the user and then update 
                GetUserByUsernameAsync is a heavy query that includes photos 
                switch to get user by id without includes statement
                however the user claims principal only currently has the username need to update the claims to contain the pok value of the :

            update the token service to inclued the unique id of the user: 
                var claims = new List<Claim>()
                    {
                        new Claim(JwtRegisteredClaimNames.NameId, user.Id.ToString()),
                        new Claim(JwtRegisteredClaimNames.UniqueName, user.UserName),
                    };
                going to retain the usernam as the uniquename now instead and the name id is the pk id values
            
            adjust claims principle extension for this new value ClaimsPrincipalExtensions:
                public static string GetUserId(this ClaimsPrincipal user)
                {
                    return user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                }
            the returned token should contain the claims princ for userid now:
                verify via https://jwt.ms/
                {
                    "alg": "HS512",
                    "typ": "JWT"
                }.{
                    "nameid": "1",
                    "unique_name": "lisa",
                    "nbf": 1706872575,
                    "exp": 1707477375,
                    "iat": 1706872575
                }.[Signature]

            update the LogUserActivity on action to use the user id:
                var userId = resultContext.HttpContext.User.GetUserId();
                var user = await repo.GetUserByIdAsync(int.Parse(userId));

        Apply the sorting on the client side:
            slap in a ngx-bootstrap radio options :

            add the buttonsModule to shared modules:
                import and export ButtonsModule.forRoot(),

            Apply the button to memberslistcomponent:
                    <div class="col">
                        <div class="btn-group float-end">
                            <button
                            type="button"
                            class="btn btn-primary"
                            name="orderBy"
                            [(ngModel)]="userParams.orderBy"
                            btnRadio="lastActive"
                            (click)="loadMembers()">Last Active </button>
                            <button
                            type="button"
                            class="btn btn-primary"
                            name="orderBy"
                            [(ngModel)]="userParams.orderBy"
                            btnRadio="created"
                            (click)="loadMembers()">Newest Members</button>
                        </div>
                    </div>
            Need to alos update the member service to pass in the orderby params
                params = params.append('orderBy', userParams.orderBy)


    Clean up the date formatinf:
        MemberDetailComponent:
            pipe that shit into a date:
                <p>{{member.created | date}}</p>
                dont forget to import the date pipe module import {DatePipe, NgIf} from "@angular/common";
            Customize further:
                 <p>{{member.created | date: 'longDate'}}</p>

            Customize the last active to show the ammount of time not the actual date:
                install ngx-timeago:
                    npm install ngx-timeago --save
                add to the shared-modules:
                    import and export     TimeagoModule.forRoot()
            Use the Timeago pipe now:
                <p>{{member.lastActive | timeago}}</p>

            update the member edit component as well 

    BUG TO ADDRESS:
        somehow the logged in user is active in the future 60 minutes from now
        theres an hour offset from server time to angulars time somehow

    The FIX for now convert the time to UTC istead:
        ensure date is saved in utc: user.LastActive = DateTime.Now.ToUniversalTime();
        <p>{{member.lastActive + 'Z' | timeago}}</p>

    adding back the caching:  
        need to store the qury with pagination now:
            create a key from the userParams so that can be used a a keey with the query results to ensure that it can be retireved later if needed:
        store that key in a map now  and retrieve it upon get members if available
            console.log("query key : ",Object.values(userParams).join('-'))
            const response = this.memberCache.get(Object.values(userParams).join('-'))
            if(response) return of(response);
        set store the value if not there:
            return this.getPaginatedResults<Member[]>(this.baseUrl + 'users',params).pipe(
                map(response => {
                    this.memberCache.set(queryKey, response)
                    return response
                })
            );

    need to store the individual user because it was pulled with the member service:
        need to be able to flatten out the members cache map arrays into one array using reduce
            const members = [...this.memberCache.values()]
                .reduce((arr,element) => arr.concat(element.result), [])

            members takes the spread arrays od the member cache then pull every element into one array

            just need to then find the first user to get the member profile:
                const member = [...this.memberCache.values()]
                    .reduce((arr,element) => arr.concat(element.result), [])
                    .find((member: Member) => member.userName === username)
                if(member) return of(member)

    Remember the userParams query when coming back to member list:
        store the userParams in the member service:
            injexct the account service into member serive:
                //its oke to inject services into other service=s just make sure the other service doesnt inject this service too!
                constructor(private http: HttpClient, private accountService : AccountService) { }
            
        copy what the member list compoent uses in the constructor:
            user: User | undefined
            userParams : UserParams | undefined

            //its oke to inject services into other service=s just make sure the other service doesnt inject this service too!
            constructor(private http: HttpClient, private accountService : AccountService) {
                this.accountService.currentUser$.pipe(take(1)).subscribe({
                next: user=>{
                    if(user){
                    this.userParams = new UserParams(user)
                    this.user = user
                    }
                }
                })
            }
            getUserParams(){
                return this.userParams
            }

            setUserParams(params : UserParams){
                this.userParams = this.userParams
            }

        add a get and setter and use that instead for the member-list compoent:
            call the member service now on load memebrs:
                loadMembers(){
                    if(this.userParams){
                    this.memberService.setUserParams(this.userParams)
            and on resetfilters:
                resetFilter(){
                    if(this.user){
                    this.userParams = this.memberService.resetUserParams()
                    this.loadMembers();
                    }
                }

    Adding a Like feature:
        Goals:
            use a many to manay relationship
                appuser can be liked by many and can like many users dot dotnet now allows this 
                need a join table called userLike with sourceuser and likeduser id
                going to user fluent api to do this 
            
        Create a new entity for likes:
            example of the ef way:
                add to appuser props:
                    public List<AppUser> LikeByUsers { get; set; }
                    public List<AppUser> LikedUsers { get; set; }
                
                Create the migration and see what happend:
                    dotnet ef migrations  add likeEntityAddedM2MTest
            THIS IS NOT RECOMMENTD as when you introduce identty shit gets weird quick
                Reverse that shit:
                    dotnet ef migrations remove

        Create instead a userlike join table:
            public class UserLike
            {
                public AppUser SourceUser { get; set; }
                public int SourceUserId { get; set; }
                public AppUser TargetUser { get; set; }
                public int TargetUserId { get; set; }
            }
        add those to the appuser instead of appusers:
            public List<UserLike> LikeByUsers { get; set; }
            public List<UserLike> LikedUsers { get; set; }

        Adjust the DataContext.cs:
            add dbset :
                public DbSet<UserLike> Likes { get; set; }

    Note: methods you can override are started as virtual in the interface its declared in 
        GOing to override the OnModelCreating method of the DbContext interface to allow the manat to many mods
            //this manually create the many to manny relations with the userlike table and estblish the delete cascade mechanism
            //its possible ef can handle this by default but you have more control this way
            protected override void OnModelCreating(ModelBuilder builder)
            {
                base.OnModelCreating(builder);
                builder.Entity<UserLike>()
                    .HasKey(k => new { k.SourceUserId, k.TargetUserId });

                builder.Entity<UserLike>()
                    .HasOne(s => s.SourceUser)
                    .WithMany(l => l.LikedUsers)
                    .HasForeignKey(s => s.SourceUserId)
                    .OnDelete(DeleteBehavior.Cascade);
                
                builder.Entity<UserLike>()
                    .HasOne(s => s.TargetUser)
                    .WithMany(l => l.LikeByUsers)
                    .HasForeignKey(s => s.TargetUserId)
                    .OnDelete(DeleteBehavior.Cascade);
            }

    Create the migration again double check the migration:
        dotnet ef migrations  add likeEntity

    Create a repository for this entity:
        Create interface > ILikesRepository
            public interface ILikesRepository
            {
                Task<UserLike> GetUserLike(int sourceUserId, int targetUserId);
                Task<AppUser> GerUserWithLikes(int userID);
                Task<IEnumerable<LikeDTO>> GetUserLikes(string predicate, int userId);
            }
        Create LikeDTO
            public class LikeDTO
            {
                public int Id { get; set; }
                public string UserName { get; set; }
                public int Age { get; set; }
                public string KnownAs { get; set; }
                public string PhotoUrl { get; set; }
                public string City { get; set; }
            }

        Create Data/LikesRepository:
            implement all the interface method:
            public class LikesRepository : ILikesRepository
            {
                public Task<UserLike> GetUserLike(int sourceUserId, int targetUserId)
                {
                    throw new NotImplementedException();
                }

                public Task<AppUser> GerUserWithLikes(int userID)
                {
                    throw new NotImplementedException();
                }

                public Task<IEnumerable<LikeDTO>> GetUserLikes(string predicate, int userId)
                {
                    throw new NotImplementedException();
                }
            }

        add the ilikes repo to the ApplicationServiceExtensions:
            services.AddScoped<ILikesRepository, LikesRepository>();
                public class LikesRepository : ILikesRepository
                {
                    private readonly DataContext _context;

                    public LikesRepository(DataContext context)
                    {
                        _context = context;
                    }
                    public async Task<UserLike> GetUserLike(int sourceUserId, int targetUserId)
                    {
                        return await _context.Likes.FindAsync(sourceUserId, targetUserId);
                    }

                    public async Task<AppUser> GerUserWithLikes(int userID)
                    {
                        return await _context.Users
                            .Include(x => x.LikedUsers)
                            .FirstOrDefaultAsync(x => x.Id == userID);
                    }

                    public async Task<IEnumerable<LikeDTO>> GetUserLikes(string predicate, int userId)
                    {
                        //remmember querables dont get executed
                        var users = _context.Users.OrderBy(u => u.UserName).AsQueryable();
                        var likes = _context.Likes.AsQueryable();

                        if (predicate == "liked")
                        {
                            likes = likes.Where(like => like.SourceUserId == userId);
                            users = likes.Select(like => like.TargetUser);
                        }
                        
                        if (predicate == "likedBy")
                        {
                            likes = likes.Where(like => like.TargetUserId == userId);
                            users = likes.Select(like => like.SourceUser);
                        }

                        return await users.Select(user => new LikeDTO
                        {
                            UserName = user.UserName,
                            KnownAs = user.KnownAs,
                            Age = user.DateOfBirth.CalculateAge(),
                            PhotoUrl = user.Photos.FirstOrDefault(x => x.IsMain).Url,
                            City = user.City,
                            Id = user.Id
                        }).ToListAsync();

                    }
                }

        Create the controller enpoint for likeControler.cs:
            public class LikesController : BaseAPIController
            {
                private readonly IUserRepository _userRepository;
                private readonly ILikesRepository _likesRepository;

                public LikesController(IUserRepository userRepository, ILikesRepository likesRepository)
                {
                    _userRepository = userRepository;
                    _likesRepository = likesRepository;
                }

                
                //the logged in/ source user is applying a like to liked user 
                [HttpPost("{username}")]
                public async Task<ActionResult> AddLike(string username)
                {
                    
                    var sourceUserId = int.Parse(User.GetUserId());
                    var likedTargetUser = await _userRepository.GetUserByUsernameAsync(username);
                    var sourceUser = await _likesRepository.GerUserWithLikes(sourceUserId);
                    
                    if(likedTargetUser == null) return NotFound();
                    if(sourceUser.UserName == username) return BadRequest("You Cannot Like yourself");

                    //check the liked user db and ensure like from source user has not been applied to target user
                    var userLike = await _likesRepository.GetUserLike(sourceUserId, likedTargetUser.Id);
                    if(userLike != null) return BadRequest("You Already Like this user");

                    userLike = new UserLike
                    {
                        SourceUserId = sourceUserId,
                        TargetUserId = likedTargetUser.Id
                    };

                    sourceUser.LikedUsers.Add(userLike);

                    if (await _userRepository.SaveALlAsync()) return Ok();

                    return BadRequest("Failed to like user ");

                }
            }


    Get the client wired up to the likes :
        memberService:
            addLike(username : string){
                return this.http.post(this.baseUrl + 'likes/' + username, {})
            }

            getLikes(predicate: string){
                return this.http.get<Member[]>(this.baseUrl + 'likes?predicate=' + predicate )
            }

    Add like call to member card compoennt:
        constructor(private memberService : MembersService, private toastr: ToastrService) {
        }
        addLike(member: Member){
            this.memberService.addLike(member.userName).subscribe({
            next: () => this.toastr.success('You have liked ' + member.knownAs)
            })
        }
    attach click event to hear icon in html:
        <button (click)="addLike(member)" class="btn btn-primary">


    Create component to list liked and likeby user :
        ListsComponent:
            export class ListsComponent implements OnInit{
                members: Member[] | undefined
                predicate = 'liked'

                constructor(private memberService: MembersService) {
                }
                ngOnInit(): void {
                    throw new Error('Method not implemented.');
                }

                loadLikes(){
                this.memberService.getLikes(this.predicate).subscribe({
                    next: response => {
                    this.members = response
                    }
                })
                }

        ListsComponent Html:
            <div class="text-center mt-3">
                <h2>{{predicate === 'liked' ? 'Members I Like' : 'Members who like me'}}</h2>
            </div>

            <div class="container mt-3">
                <div class="d-flex">
                    <div class="btn-group" name="predicate">
                    <button
                        class="btn btn-primary"
                        btnRadio="liked"
                        [(ngModel)]="predicate"
                        (click)="loadLikes()"> Members I like </button>
                    <button
                        class="btn btn-primary"
                        btnRadio="likedBy"
                        [(ngModel)]="predicate"
                        (click)="loadLikes()"> Members Who Like Me </button>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-2" *ngFor="let member of members">
                    <app-member-card [member]="member"></app-member-card>
                    </div>
                </div>
            </div>

    Add Pagination to the liked list:
        Create a paginationParams help .cs :
            cut the pagination props out of the userparams into the pagination:
            public class PaginationParams
            {
                private const int MAX_PAGE_SIZE = 50;
                public int PageNumber { get; set; } = 1;
                private int _pageSize = 10;

                public int PageSize
                {
                    get => _pageSize;
                    set => _pageSize = (value > MAX_PAGE_SIZE) ? MAX_PAGE_SIZE : value;
                }

        derive from pagination params in the userParams to retain functionality
            public class UserParams : PaginationParams

        create then another api helper class call likesParams and also derive that from paginationparams 
            public class LikesParams : PaginationParams
            {
                public int UserId { get; set; }
                public string predicate { get; set; }
            }
        
        change ILikesRepository to take in this param :
            Task<PageList<LikeDTO>> GetUserLikes(LikesParams likesParams);

        Implement this in LikesRepository:
            //Thanks to the pafelist only 4 lines need change to omplement page result for liked users
            public async Task<PageList<LikeDTO>> GetUserLikes(LikesParams likesParams)
            {
                //remmember querables dont get executed
                var users = _context.Users.OrderBy(u => u.UserName).AsQueryable();
                var likes = _context.Likes.AsQueryable();

                if (likesParams.predicate == "liked")
                {
                    likes = likes.Where(like => like.SourceUserId == likesParams.UserId);
                    users = likes.Select(like => like.TargetUser);
                }
                
                if (likesParams.predicate  == "likedBy")
                {
                    likes = likes.Where(like => like.TargetUserId == likesParams.UserId);
                    users = likes.Select(like => like.SourceUser);
                }

                var likedUsers = users.Select(user => new LikeDTO
                {
                    UserName = user.UserName,
                    KnownAs = user.KnownAs,
                    Age = user.DateOfBirth.CalculateAge(),
                    PhotoUrl = user.Photos.FirstOrDefault(x => x.IsMain).Url,
                    City = user.City,
                    Id = user.Id
                });

                return await PageList<LikeDTO>.CreateAsync(likedUsers, likesParams.PageNumber, likesParams.PageSize);
            }

        LikesController now need updated to work with the paged list:
            public async Task<ActionResult<PageList<LikeDTO>>> GetUserLikes([FromQuery] LikesParams likesParams)
            {
                likesParams.UserId = User.GetUserId();
                var users = await _likesRepository.GetUserLikes(likesParams);

                return Ok(users);
            }

        get the client paged up now:
            wire up the get like in memberService:
                getLikes(predicate: string, pageNumber: number, pageSize:number){
                    let params = this.getPaginationHeaders(pageNumber,pageSize)
                    params = params.append('predicate', predicate)

                    return this.getPaginatedResults<Member[]>(this.baseUrl + 'like', params)
                }
            
            Add the ui to the list component:
                .ts :
                    loadLikes(){
                        this.memberService.getLikes(this.predicate, this.pageNumber, this.pageSize).subscribe({
                            next: response => {
                            this.members = response.result
                            this.pagination = response.pagination

                            }
                        })
                        }

                    pageChanged(event: any) {
                        if(this.pageNumber != event.page){
                            this.pageNumber = event.page
                            this.loadLikes()
                        }

                .html:
                    steal the member list pagination and alter slightly 

February 3 2024:
    Adding Messeging:
        More many to many relationships 
        create inbox and outbox and unread messages 
        using query params in angular 
        using route resolvers 
    
    Setup Entities for messaging in the API:
        Setup message.cs in entities folder of the api:
            public class Message
            {
                public int Id { get; set; }
                public int SenderId { get; set; }
                public string SenderUsername { get; set; }
                public AppUser Sender { get; set; }
                public int RecipientId { get; set; }
                public string RecipientUsername { get; set; }
                public AppUser Recipient { get; set; }
                public string Content { get; set; }
                public DateTime DateRead { get; set; }
                public DateTime MessageSent { get; set; } = DateTime.UtcNow;
                public bool SenderDeleted { get; set; }
                public bool RecipientDeleted { get; set; }

            }
        Add the messeges as a prop/fk to AppUser:
            public List<Message> MessagesSent { get; set; }
            public List<Message> MessagesRecieved { get; set; }
        notes these props of lists dont get added as acolumn to appuser, these just register that the object table types link to appuser via fk relationship and can be include in ef query calls without the need of fluent declaratios or weird jon statements

        because this is a manay to many you could let ef migration create the config but gonna do it manually instead

    Setup the Datacontext and relationship in fluentApi DataCOntext.cs:
        builder.Entity<Messages>()
            .HasOne(s => s.Recipient)
            .WithMany(l => l.MessagesRecieved)
            .OnDelete(DeleteBehavior.Restrict);
        
        builder.Entity<Messages>()
            .HasOne(s => s.Sender)
            .WithMany(l => l.MessagesRecieved)
            .OnDelete(DeleteBehavior.Restrict);

        add and apply dotnet migrations:
            dotnet ef migrations add messagesEntity

    Create the message repository:
        interface/IMessageRepository:
            public interface IMessageRepository
            {
                void AddMessage(Message message);
                void DeleteMessage(Message message);
                Task<Message> GetMessage(int id);
                Task<PagedList<MessageDTO>> GetMessagesForUser();
                Task<IEnumerable<MessageDTO>> GetMessageThread(int currentUserId, int recipientId);
                Task<bool> SaveAllAsync();
            }           

    Create the DTOs/MessageDTO.cs :
        public class MessageDTO
            {
                public int Id { get; set; }
                public int SenderId { get; set; }
                public string SenderUsername { get; set; }
                public string SenderPhotoUrl { get; set; }
                public int RecipientId { get; set; }
                public string RecipientUsername { get; set; }
                public string RecipientPhotoUrl { get; set; }
                public string Content { get; set; }
                public DateTime DateRead { get; set; }
                public DateTime MessageSent { get; set; }
            }

    Implement the IMessageRepo as Data/MessageRepository:
        public class MessageRepository : IMessageRepository
        {
            private readonly DataContext _context;

            public MessageRepository(DataContext context)
            {
                _context = context;
            }
            public void AddMessage(Message message)
            {
                _context.Messages.Add(message);
            }

            public void DeleteMessage(Message message)
            {
                _context.Messages.Remove(message);
            }

            public async Task<Message> GetMessage(int id)
            {
                return await _context.Messages.FindAsync(id);
            }

            public Task<PagedList<MessageDTO>> GetMessagesForUser()
            {
                throw new NotImplementedException();
            }

            public Task<IEnumerable<MessageDTO>> GetMessageThread(int currentUserId, int recipientId)
            {
                throw new NotImplementedException();
            }

            public async Task<bool> SaveAllAsync()
            {
                return await _context.SaveChangesAsync() > 0;
            }
        }        

    Add the repository as a service to ApplicationServiceExtensions:
        services.AddScoped<IMessageRepository, MessageRepository>();

    Setup the Automapper Profile AutoMapperProfiles:
        have to account for the user photurl properties 
        CreateMap<Message, MessageDTO>()
            .ForMember(d=> d.SenderPhotoUrl, opt => opt
                .MapFrom(s => s.Sender.Photos.FirstOrDefault(x =>x.IsMain).Url))
            .ForMember(d=> d.RecipientPhotoUrl, opt => opt
                .MapFrom(s => s.Recipient.Photos.FirstOrDefault(x =>x.IsMain).Url));
        
    Establish another DTO to recieve message from the client DTOS/CreateMessageDTO
        public class CreateMessageDTO
        {
            public string RecipientUsername { get; set; }
            public string Content { get; set; }
        }

    Add a messages controller MessagesController.cs:
        public class MessagesController: BaseAPIController
        {
            private readonly IUserRepository _userRepository;
            private readonly IMessageRepository _messageRepository;
            private readonly IMapper _mapper;

            public MessagesController(IUserRepository userRepository, IMessageRepository messageRepository, IMapper mapper)
            {
                _userRepository = userRepository;
                _messageRepository = messageRepository;
                _mapper = mapper;
            }

            [HttpPost]
            public async Task<ActionResult<MemberDTO>> CreateMessage(CreateMessageDTO createMessageDto)
            {
                var username = User.GetUserName();
                if (username == createMessageDto.RecipientUsername.ToLower())
                {
                    return BadRequest("You can't send messages to yourself");
                }

                var sender = await _userRepository.GetUserByUsernameAsync(username);
                var recipient = await _userRepository.GetUserByUsernameAsync(createMessageDto.RecipientUsername);
                
                if(recipient == null) NotFound();

                var message = new Message
                {
                    Sender = sender,
                    Recipient = recipient,
                    SenderUsername = sender.UserName,
                    RecipientUsername = recipient.UserName,
                    Content = createMessageDto.Content
                };
                
                _messageRepository.AddMessage(message);
                
                if(await _messageRepository.SaveAllAsync()) return Ok(_mapper.Map<MessageDTO>(message));

                return BadRequest("Failed to send message");
            }   
        }       

    test the api endpoint 
        {{url}}/api/messages

    Create helpers class to provide paginated message to the user:  
        helpers/MessageParams.cs:
            public class MessageParams : PaginationParams
            {
                public string Username { get; set; }
                public string Container { get; set; } = "Unread";
            }        

    update IMessageRepository:
        Task<PagedList<MessageDTO>> GetMessagesForUser(MessageParams messageParams);

    Implement it MessageRepository:
        public async Task<PagedList<MessageDTO>> GetMessagesForUser(MessageParams messageParams)
            {
                var query = _context.Messages
                    .OrderBy(x => x.MessageSent)
                    .AsQueryable();

                query = messageParams.Container switch
                {
                    "Inbox" => query.Where(u => u.RecipientUsername == messageParams.Username),
                    "Outbox" => query.Where(u => u.SenderUsername == messageParams.Username),
                    _ => query.Where(u => u.RecipientUsername == messageParams.Username && u.DateRead == null)
                };

                var messages = query.ProjectTo<MessageDTO>(_mapper.ConfigurationProvider);

                return await PagedList<MessageDTO>
                    .CreateAsync(messages, messageParams.PageNumber, messageParams.PageSize);
            }           

        update the MessagesController:
            [HttpGet]
            public async Task<ActionResult<PagedList<MessageDTO>>> GetMessagesForUser(
                [FromQuery] MessageParams messageParams)
            {
                messageParams.Username = User.GetUserName();
                var messages = await _messageRepository.GetMessagesForUser(messageParams);
                Response.AddPaginationHeader(new PaginationHeader(messages.CurrentPage, messages.PageSize, 
                    messages.TotalCount, messages.TotalPages));

                return messages;
            }           

        Ran into issue with dateRead not be set to null and thus get messages not retrieving anything 
        update the Message model to allow nullable on that field and updated the migrations


    Getting a message Thread Between 2 Users:
        GOing to flesh out the profile > message tab

        MessageRepository.cs:
            //pull the messages and mark the one where the recipient username is the current logged in user as read by updateing the date read
            public async Task<IEnumerable<MessageDTO>> GetMessageThread(string currentUsername, string recipientUsername)
            {
                var messages = await _context.Messages
                    .Include(u => u.Sender).ThenInclude(p => p.Photos)
                    .Include(u => u.Recipient).ThenInclude(p => p.Photos)
                    .Where(
                        m => m.RecipientUsername == currentUsername &&
                            m.SenderUsername == recipientUsername ||
                            m.RecipientUsername == recipientUsername &&
                            m.SenderUsername == currentUsername
                    ).OrderBy(m => m.MessageSent)
                    .ToListAsync();

                var unreadMessages = messages.Where(m => m.DateRead == null 
                                                        && m.RecipientUsername == currentUsername).ToList();
                if(unreadMessages.Any())
                {
                    foreach (var msg in unreadMessages)
                    {
                        msg.DateRead = DateTime.UtcNow;
                    }
                    await _context.SaveChangesAsync();
                }

                return _mapper.Map<IEnumerable<MessageDTO>>(messages);
            }           

    Add the api endpoint for the mesage thread in the MessagesController:
        [HttpGet("thread/{username}")]
        public async Task<ActionResult<IEnumerable<MessageDTO>>> GetMessageThread(string username)
        {
            var currentUsername = User.GetUserName();
            return Ok(await _messageRepository.GetMessageThread(currentUsername, username));
        }

    test the endpoint: 
        {{url}}/api/messages/thread/todd

    bit of a bug the timestamps signatures are different between the dateRead and messageSent:
        "dateRead": "2024-02-03T18:51:53.952295Z",
        "messageSent": "2024-02-03T19:24:29.646661+01:00"

        dateRead is being passed by the controller never pulled from the db reloading the thread will show the same time signatures as the dae will have been stored

    also need to order by descending 

    Setup the Client side to pull the messages/threads:
        made the client side model via json2ts using response:
        https://json2ts.vercel.app/
            {
                "id": 9,
                "senderId": 6,
                "senderUsername": "todd",
                "senderPhotoUrl": "https://randomuser.me/api/portraits/men/90.jpg",
                "recipientId": 1,
                "recipientUsername": "lisa",
                "recipientPhotoUrl": "https://randomuser.me/api/portraits/women/54.jpg",
                "content": "Test message from Todd to Lisa",
                "dateRead": "2024-02-03T19:51:53.952369+01:00",
                "messageSent": "2024-02-03T19:24:31.3528+01:00"
            },
            generates this slap it in _models/message.ts:
            export interface Message {
                id: number;
                senderId: number;
                senderUsername: string;
                senderPhotoUrl: string;
                recipientId: number;
                recipientUsername: string;
                recipientPhotoUrl: string;
                content: string;
                dateRead: string;
                messageSent: string;
                }

    Create message service to pull dat data into this model:
        ng g s _services/messages

    Cut the pagination methods out of the memebrs put in a helper file Pagination Helpers:
        export function getPaginatedResults<T>(url: string, params: HttpParams, http:HttpClient) {
            const paginatedResult : PaginatedResult<T> = new PaginatedResult<T>
            return http.get<T>(url, {observe: 'response', params}).pipe(
                map(response => {
                if (response.body) {
                    paginatedResult.result = response.body
                }
                const pagination = response.headers.get('Pagination')
                if (pagination) {
                    paginatedResult.pagination = JSON.parse(pagination)
                }
                return paginatedResult
                })
            )
            }

        export function getPaginationHeaders(pageNumber:number, pageSize:number) {
            let params = new HttpParams()
            params = params.append('pageNumber', pageNumber)
            params = params.append('pageSize', pageSize)
            return params;
            }

    Flesh out the MessagesService :
        export class MessagesService {
            baseUrl = environment.apiUrl
            constructor(private http: HttpClient) { }

            getMessages(pageNumber: number, pageSize: number, container:string){
                let params = getPaginationHeaders(pageNumber,pageSize)
                params = params.append('Container', container)
                return getPaginatedResults<Message[]>(this.baseUrl + 'messages', params, this.http)
            }
            }
    
    get the message component wired up:
        export class MessagesComponent implements OnInit{
            messages? : Message[]
            pagination?: Pagination
            container = 'Unread'
            pageNumber = 1
            pageSize = 5

            constructor(private messageService: MessagesService) {
            }
            ngOnInit(): void {
                this.loadMessage()
            }

            loadMessage(){
                this.messageService.getMessages(this.pageNumber,this.pageSize,this.container).subscribe({
                next: response => {
                    this.messages = response.result
                    this.pagination = response.pagination
                }
                })
            }
        }

    messegesConponent.html:
        <div class="mb-4 d-flex">
            <div class="btn-group" name="container">
                <button
                class="btn btn-primary"
                btnRadio="Unread"
                [(ngModel)]="container"
                (click)="loadMessage()"
                >
                <i class="fa fa-envelope"></i> Unread
                </button>
                <button
                class="btn btn-primary"
                btnRadio="Inbox"
                [(ngModel)]="container"
                (click)="loadMessage()"
                >
                <i class="fa fa-envelope-open"></i> Inbox
                </button>
                <button
                class="btn btn-primary"
                btnRadio="Outbox"
                [(ngModel)]="container"
                (click)="loadMessage()"
                >
                <i class="fa fa-paper-plane"></i> Outbox
                </button>
            </div>
            </div>

            <div class="d-flex justify-content-center" *ngIf="!messages || messages.length == 0">
            <h3>No Messages</h3>
            </div>

            <div class="row" *ngIf="messages && messages.length > 0">
            <table class="table table-hover" style="cursor: pointer">
                <thead>
                <tr>
                    <th style="width: 40%"> Message</th>
                    <th style="width: 20%"> From / To</th>
                    <th style="width: 20%">Sent / Received</th>
                    <th style="width: 20%"> </th>
                </tr>
                </thead>
                <tbody class="align-middle">
                <tr *ngFor="let message of messages"
                    routerLink="{{container === 'Outbox'
                    ? '/members/' + message.recipientUsername
                    : '/members/' + message.senderUsername}}"
                >
                    <td>{{message.content}}</td>
                    <td>
                    <div *ngIf="container === 'Outbox'">
                        <img
                        class="img-circle rounded-circle me-2"
                        src="{{message.recipientPhotoUrl || './assets/user.png'}}"
                        alt="recipient photo">
                        <strong>{{message.recipientUsername | titlecase}}</strong>
                    </div>
                    <div *ngIf="container !== 'Outbox'">
                        <img
                        class="img-circle rounded-circle me-2"
                        src="{{message.senderPhotoUrl || './assets/user.png'}}"
                        alt="recipient photo">
                        <strong>{{message.senderUsername | titlecase}}</strong>
                    </div>
                    </td>
                    <td>
                    {{message.messageSent | timeago}}
                    </td>
                    <td>
                    <button class="btn btn-danger">Delete</button>
                    </td>
                </tr>
                </tbody>
            </table>
            </div>
            <div class="mt-4 d-flex justify-content-center" *ngIf="pagination && messages && messages.length > 0">
            <pagination
                [boundaryLinks]="true"
                [totalItems]="pagination.totalItems"
                [itemsPerPage]="pagination.itemsPerPage"
                [maxSize]="10"
                [(ngModel)]="pagination.currentPage"
                (pageChanged)="pageChanged($event)"
                previousText="&lsaquo;"
                nextText="&rsaquo;"
                firstText="&laquo;"
                lastText="&raquo;">
            </pagination>
        </div>

       
    Add the messages to the profile tab via messageThreads:

        add get message threads to the message service:
            getMessageThreads(username:string){
                    return this.http.get<Message[]>(this.baseUrl + 'messages/thread/' + username)
                }

        create ng component to show the threads:
            ng g c member/member-messages

            @Component({
                selector: 'app-member-messages',
                templateUrl: './member-messages.component.html',
                standalone: true,
                styleUrl: './member-messages.component.css'
                })
                export class MemberMessagesComponent implements OnInit{
                @Input() username? : string
                messages :Message[] = []

                constructor(private messageService: MessagesService) {
                }
                ngOnInit(): void {
                }

                loadMessages(){
                    if(this.username) {
                    this.messageService.getMessageThreads(this.username).subscribe({
                        next: messages => this.messages = messages
                    })
                    }
                }
            }
        
        Add it to the member profile page and you need to make the component standalone bcause of the ngx gallery to get it to work fully:
        need to do an ass load of imports

        MemberMessagesComponent:
            <div class="card">
                <div class="card-body">
                    <div *ngIf="messages.length === 0">
                    No messages yet.... say hi by using the message box below
                    </div>

                    <ul *ngIf="messages.length>0"  class="chat" >
                    <li *ngFor="let message of messages">
                        <div>
                        <span class="chat-img float-end">
                            <img src="{{message.senderPhotoUrl || './assets/user.png'}}"
                                alt="image of user"
                                class="rounded-circle">
                        </span>
                        <div class="chat-body">
                            <div class="header">
                            <small class="text-muted">
                                <span class="fa fa-clock-o">{{message.messageSent | timeago}}</span>
                                <span class="text-danger" *ngIf="!message.dateRead && message.senderUsername !== username">
                                (unread)
                                </span>
                                <span class="text-success" *ngIf="message.dateRead && message.senderUsername !== username">
                                (read {{message.dateRead | timeago}})
                                </span>
                            </small>
                            </div>
                            <p>{{message.content}}</p>
                        </div>
                        </div>

                    </li>
                    </ul>
                </div>
                <div class="card-footer">
                    <form>
                    <div class="input-group">
                        <input type="text" class="form-control input-sm" placeholder="Send a private Message">
                        <div class="input-group-append">
                        <button class="btn btn-primary">Send</button>
                        </div>
                    </div>
                    </form>
                </div>
            </div>
            export class MemberMessagesComponent implements OnInit{
                @Input() username? : string
                messages :Message[] = []

                constructor(private messageService: MessagesService) {
                }
                ngOnInit(): void {
                    this.loadMessages()
                }

                loadMessages(){
                    if(this.username) {
                    this.messageService.getMessageThreads(this.username).subscribe({
                        next: messages => this.messages = messages
                    })
                    }
                }

                protected readonly Date = Date;
                }

            css:
                .card {
                border: none;
                }

                .chat{
                list-style: none;
                margin: 0;
                padding: 0;
                }

                .chat li{
                margin-bottom: 10px;
                padding-bottom: 10px;
                border: 1px dotted blue;
                }


                .rounded-circle{
                max-height: 50px;
                }

    Activating the Messages tab:
        also the messages get pull on the member page even if the tab isnt selected:
            because the member seets is a standalone component you need to use a template reference variable to can access to the component and set when you want it to load:   
            MemberDetailComponent html:
                <tabset class="member-tabset" #memberTabs>
            MemberDetailComponent ts:
                @ViewChild('memberTabs') memberTabs?: TabsetComponent
                activeTab?: TabDirective
                  onTabActivated(data: TabDirective){
                    this.activeTab = data
                    if(this.activeTab.heading === 'Messages'){
                    this.loadMessages()
                    }
                }

                loadMessages(){
                    if(this.member) {
                    this.messageService.getMessageThreads(this.member.userName).subscribe({
                        next: messages => this.messages = messages
                    })
                    }
                }


            apply tab change listner to html element:
                <tab heading="Messages" (selectTab)="onTabActivated($event)">


            the MemberMessagesComponent should be bare boned now with just :
            export class MemberMessagesComponent implements OnInit{
                @Input() messages:Message[] = []
            messages are brought in by the parent just need to declare the comp as 
                <app-member-messages [messages]="messages"></app-member-messages>


        MemberDetailComponent:
            add a selectTab function overriding ts checks in the process
                selectTab(heading : string){
                    if(this.memberTabs){
                    //the ! tells ts to stop checking cuz we're going rouge and shit about to get wierd
                    this.memberTabs.tabs.find(x => x.heading === heading)!.active = true
                    }
                }
            add a click listener to engage this tab and function :
                <button (click)="selectTab('Messages')" class="btn btn-success">Message</button>

        Now to do it outside of the component by passing in a query string:
            Member-card.component.html use the routerlink:
                <button
                  class="btn btn-primary"
                  routerLink="member/{{member.userName}}"
                  [queryParams]="{tab: 'Messages'}"
                >
        this will slap url/member/username?tab=Messages ex: https://localhost:4200/members/member/todd?tab=Messages
        make the same change to the MessagesComponent
                <tr *ngFor="let message of messages"
                    routerLink="{{container === 'Outbox'
                    ? '/members/' + message.recipientUsername
                    : '/members/' + message.senderUsername}}"
                    [queryParams]="{tab: 'Messages'}"
                >
        now to update the route in the MemberDetailComponent:
            gotta use a route resolver to allow the child component to be access and tab selected as the oniti doesnt have initialized child components because the member value has not loaded yet 
            this is solved by loading the member prior to the component in the first place :
            
            ng cli create a resolver:
                ng g r _resolvers/member-detail:
                    export const memberDetailResolver: ResolveFn<Member> = (route, state) => {
                        const memberService = inject(MembersService)
                        return memberService.getMember(route.paramMap.get('username')!)
                    };

            Update the route config AppRoutingModule:
                {path: 'members/:username', component: MemberDetailComponent, resolve: {member: memberDetailResolver}},

            boom badabing shti just works now how neat

            but also in the MemberDetailComponent you can access the memeber  instead of loading it as it was passed in via the resolver
              ngOnInit(): void {
                this.route.data.subscribe({
                next: data => this.member = data['member']
                })

        Still need to remove the condition in the temlate of need to remove the ngIf and member no longer needs an undefined declaration
            member: Member = {} as Member

        also the tabs view childs need to be declared as static to ensure load prior to initL:
          @ViewChild('memberTabs', {static: true}) memberTabs?: TabsetComponent

    Wire up the send message in the message tab:
        messageService:
            sendMessage(username:string, content:string){
                return this.http.post<Message>(this.baseUrl + 'messages',
                {recipientUsername: username, content})
            }

    MemberMessagesComponent:
      sendMessage(){
            if(!this.username){
            this.messagesService.sendMessage(this.username, this.messageContent).subscribe({
                next: message => this.messages.push(message)
            })
            }
        }

    MemberMessagesComponent needs the form wired into the sendMessage:
        make the form an ngForm module by useing the template reference variable #messageForm
            <form #messageForm = "ngForm" (ngSubmit)="sendMessage()" autocomplete="off">
                <div class="input-group">
                    <input
                        type="messageConten"
                        required
                        [(ngModel)]="messageContent"
                        lass="form-control input-sm"
                        placeholder="Send a private Message"
                    >
                    <div class="input-group-append">
                    <button [disabled]="!messageForm.valid" class="btn btn-primary">Send</button>
                    </div>
                </div>
            </form>

    MemberMessagesComponent:
        add the form as a viewchild 
        @ViewChild('messageForm') messageForm? : NgForm
        add form reset too   
            sendMessage(){
                if(!this.username) return
                this.messagesService.sendMessage(this.username, this.messageContent).subscribe({
                next: message => {
                    this.messages.push(message)
                    this.messageForm?.reset()
                }
                })
            }

    need to resort the users message when they come in:
        orderBy instead of OrderByDescending

 February 4 2024
 
    Fixing photo weirdness:
        when swaping to from inbox to outbox the phots are still visible and you can see them switch over
        The fix:
            A a loading boolean to hide the components untiul compleation of the load message function 
            MessagesComponent.ts:
                loadMessage(){
                    this.loading = true
                    this.messageService.getMessages(this.pageNumber,this.pageSize,this.container).subscribe({
                    next: response => {
                        this.messages = response.result
                        this.pagination = response.pagination
                        this.loading = false;
                    }
                    })
                }

            slap an hidden decorator in the template and call it a day:
                <tr [hidden]="loading" *ngFor="let message of messages"

    Fix the time stamps and localize:
        add a Z (read {{message.dateRead + 'Z' | timeago}})

    Implement delete message:
        MessagesController:
            [HttpDelete("{id}")]
            //both users need to delete the message for it to fully delete
            public async Task<ActionResult> DeleteMessage(int id)
            {
                var username = User.GetUserName();
                var message = await _messageRepository.GetMessage(id);
                //verify the user is either the sender or recipient
                if (message.SenderUsername != username && message.RecipientUsername != username)
                    return Unauthorized("Not the sender or recipient of message");

                if (message.SenderUsername == username) message.SenderDeleted = true;
                if (message.RecipientUsername == username) message.RecipientDeleted = true;

                if (message.SenderDeleted && message.RecipientDeleted)
                {
                    _messageRepository.DeleteMessage(message);
                }
                
                if(await _messageRepository.SaveAllAsync()) return Ok();

                return BadRequest("Problem Deleting the message");

            }

        Update the messageRepository and check add an inbox check for the deleted message:
            query = messageParams.Container switch
                {
                    "Inbox" => query.Where(u => u.RecipientUsername == messageParams.Username && u.RecipientDeleted == false),
                    "Outbox" => query.Where(u => u.SenderUsername == messageParams.Username && u.RecipientDeleted == false),
                    _ => query.Where(u => u.RecipientUsername == messageParams.Username && u.DateRead == null && u.RecipientDeleted == false)           

                var messages = await _context.Messages
                    .Include(u => u.Sender).ThenInclude(p => p.Photos)
                    .Include(u => u.Recipient).ThenInclude(p => p.Photos)
                    .Where(
                        m => m.RecipientUsername == currentUsername && m.RecipientDeleted == false &&
                            m.SenderUsername == recipientUsername ||
                            m.RecipientUsername == recipientUsername && m.SenderDeleted == false &&
                            m.SenderUsername == currentUsername
                    ).OrderBy(m => m.MessageSent)
                    .ToListAsync();            


        configure client delete button 
            messageService:
                deleteMessage(id:number){
                    return this.http.delete(this.baseUrl + 'messages/' + id)
                }
        
            call the service in the components
                MessagesComponent:  
                    deleteMessage(id:number){
                        this.messageService.deleteMessage(id).subscribe({
                        next: ()=> this.messages?.splice(this.messages?.findIndex(m=>m.id === id),1)
                        })
                    }
                    <button class="btn btn-danger"  (click)="deleteMessage(message.id)">Delete</button>

        delete button routes to the user profile need to change to stop the routing :
            MessagesComponent:
                add another click event 
                    <button class="btn btn-danger"  (click)="$event.stopPropagation()" (click)="deleteMessage(message.id)">Delete</button>


    IDENTITY AND ROLE MANAGEMENT:
        Refactor the code to use ASP .net Identity
        role management 
        policy based authorization
        usermanager 
        signinmanager 
        rolemanager

        why:
            battlehardened written and test by msft 
            comes with password hasher 
            full framework for managing members and roles 
            provides the ef schema to create the need roles


    First step exted AppUser from the identityuser class :
        public class AppUser : IdentityUser<int> (the in establishes integer as the id )
            add:
                public ICollection<AppUserRole> UserRoles { get; set; }
            you can now delete id, username password hash as that in implicitly inherity

    create Idnetity role class in entity inherit from IdentityRole
        public class AppUserRole : IdentityUserRole<int>
        {
            public AppUser User { get; set; }
            public AppRole Role { get; set; }
        }

    Create an approle class as well in entities:
        public class AppRole : IdentityRole<int>
        {
            public ICollection<AppUserRole> UserRoles { get; set; }
        }

    Remove the hmac and salt stuf from the accountcontroller and seed method

    Adjust the DataContext:
        derive from the IdentityDB
            nuget install Microsoft.AspNetCore.Identity.EntityFrameworkCore

        public class DataContext : IdentityDbContext
        
        no longer need the user dbset as already inherited

        also need to specified each dataset with the int type as the id is of type int
        public class DataContext : IdentityDbContext<AppUser, AppRole, int, 
            IdentityUserClaim<int>, AppUserRole, IdentityUserLogin<int>, 
            IdentityRoleClaim<int>, IdentityUserToken<int>>
    

        configure builder to dictate the AppUser and Approle relationship
            App user 1 can have many roles 
            roles 1 can be assigne to many user

                builder.Entity<AppUser>()
                    .HasMany(ur => ur.UserRoles)
                    .WithOne(u => u.User)
                    .HasForeignKey(ur => ur.UserId)
                    .IsRequired();
                
                builder.Entity<AppRole>()
                    .HasMany(ur => ur.UserRoles)
                    .WithOne(u => u.Role)
                    .HasForeignKey(ur => ur.Role)
                    .IsRequired();

    Configure Identity via IdentityServiceExtensions:
        at top:
            services.AddIdentityCore<AppUser>(opt =>
            {
                opt.Password.RequireNonAlphanumeric = false;
                //opt.User.RequireUniqueEmail;
            })
            .AddRoles<AppRole>()
            .AddRoleManager<RoleManager<AppRole>>()
            .AddEntityFrameworkStores<DataContext>();

    Create a new migration:
        dotnet ef migrations add identityImpl

    Update the seed class seed.cs:
    switch to userManager instead:
        public static async Task SeedUsers(UserManager<AppUser> userManager)
        {
            if (await userManager.Users.AnyAsync())
            {
                return;
            }
            else
            {
                var userData = await File.ReadAllTextAsync("Data/UserSeedData.json");
                //ignores and still adds lowercase property name 
                var options = new JsonSerializerOptions{PropertyNameCaseInsensitive = true};
                var users = JsonSerializer.Deserialize<List<AppUser>>(userData);
                foreach (var user in users)
                {
                    user.UserName = user.UserName.ToLower();
                    await userManager.CreateAsync(user, "Pas$$w0rd");
                }
            }
        }        

    Update program cs to use the seed class passing in the usermanager:
        var userManager = services.GetRequiredService<UserManager<AppUser>>();
        await Seed.SeedUsers(userManager);

    Drop dat db and rerun the application:
        dotnet ef database drop

    Configure the AccountController for login and regiser:
        inject the user manager instead of context 
        UserManager<AppUser> userManager

    Configure Roles for application:

        Create the roles in the  SeedUsers of Seed.cs:
            inject  RoleManager<AppRole> roleManager
            var roles = new List<AppRole>
            {
                new AppRole { Name = "Member" },
                new AppRole { Name = "Admin" },
                new AppRole { Name = "Moderator" }
            };

            foreach (var role in roles)
            {
                await roleManager.CreateAsync(role);
            }

            var admin = new AppUser
            {
                UserName = "admin"
            };

            await userManager.CreateAsync(admin, "Pa$$w0rd");
            await userManager.AddToRolesAsync(admin, new[] { "Admin", "Moderator" });

        Program.cs 
            create rolemanager service and pass to the seed 
            var roleManager = services.GetRequiredService<RoleManager<AppRole>>();
            await Seed.SeedUsers(userManager, roleManager);

        Drop the db and do it again yo.

        had to make the string props for city gender country and known as as nullable created migrations for it 

    Add the roles to the return token as a claim:
        TokenService:
            inject the userManageService:
                public TokenService(IConfiguration config, UserManager<AppUser> userManager)
            mod  public string CreateToken(AppUser user):
            change to  public async Task<string> CreateToken(AppUser user)
                update the interface too

            pull the roles from usermanager and add them as individual claims 
                var roles = await _userManager.GetRolesAsync(user);
                claims.AddRange(roles.Select(role => new Claim(ClaimTypes.Role,role)));

    Example of how to user Roles on an api endpoint:
        add the [Authorize(Roles = "Admin")] to the endpoint or     [Authorize(Roles = "Member")]

            [Authorize(Roles = "Admin")]
            [HttpGet]
            //[FromQuery] will dictate the api endpoint call will be in the form of /api/users?pageNumber=1&pageSize=5
            //By default with no query returns pageNumber 1 and pageSize 10
            public async Task<ActionResult<IEnumerable<MemberDTO>>> GetUsers([FromQuery]UserParams userParams)


     double check the jwt token returned with wat claims exist via jwt.ms 
      example:  
            "alg": "HS512",
            "typ": "JWT"
            }.{
            "nameid": "11",
            "unique_name": "admin",
            "role": [
                "Admin",
                "Moderator"
            ],
            "nbf": 1707066326,
            "exp": 1707671126,
            "iat": 1707066326
            }.[Signature]

    Adding policy based authorizations:
        Create AdminController as a policy test start with basic endpoint:
            public class AdminController : BaseAPIController
            {
                
                [Authorize(Policy = "RequireAdminRole")]
                [HttpGet("users-with-roles")]
                public ActionResult GetUsersWithRoles()
                {
                    return Ok("Only Admins can see this");
                }

                [Authorize(Policy = "ModeratePhotoRole")]
                [HttpGet("photos-to-moderate")]
                public ActionResult GetPhotosForModeration()
                {
                    return Ok("Admins or moderators can see this");
                }
            }

    IdentityServiceExtensions add the policies:
        services.AddAuthorization(opts =>
            {
                opts.AddPolicy("RequireAdminRole", policy => policy.RequireRole("Admin"));
                opts.AddPolicy("ModeratePhotoRole", policy => policy.RequireRole("Admin", "Moderator"));
            });

    postmans:
        access {{url}}/api/admin/users-with-roles ass non admin will fail with 403 forbidden error

    GetUsersWIthRoles provide the data now:
        AdminController:
            [Authorize(Policy = "RequireAdminRole")]
            [HttpGet("users-with-roles")]
            public async Task<ActionResult> GetUsersWithRoles()
            {
                var users = await _userManager.Users
                    .OrderBy(u => u.UserName)
                    .Select(u => new
                    {
                        u.Id,
                        Username = u.UserName,
                        Roles = u.UserRoles.Select(r => r.Role.Name).ToList()
                    })
                    .ToListAsync();

                return Ok(users);
                // return Ok("Only Admins can see this");
            }      
        Endpoint now returns:
            {
                "id": 11,
                "username": "admin",
                "roles": [
                    "Admin",
                    "Moderator"
                ]
            },
            {
                "id": 12,
                "username": "bob",
                "roles": [
                    "Member"
                ]
            },
            {
                "id": 10,
                "username": "davis",
                "roles": [
                    "Member"
                ]
            }...

    Edit roles as admin endpoint:
        AdminController
            //technically this should be a put request but need to return update list of roles 
            [Authorize(Policy = "RequireAdminRole")]
            [HttpPost("edit-roles/{username}")]
            public async Task<ActionResult> EditRoles(string username,[FromQuery] string roles)
            {
                if (string.IsNullOrEmpty(roles)) return BadRequest("You Must Select at least one role");

                var selectedRoles = roles.Split(",").ToArray();
                var user = await _userManager.FindByNameAsync(username);
                if(user == null) return NotFound();
                var userRoles = await _userManager.GetRolesAsync(user);

                var result = await _userManager.AddToRolesAsync(user, selectedRoles.Except(userRoles));
                
                if(!result.Succeeded) return BadRequest("Failed to add to roles");

                //find all the roles that the user has that are not list in the roles query parameter 
                //then remove said roles
                result = await _userManager.RemoveFromRolesAsync(user, userRoles.Except(selectedRoles));
                
                if(!result.Succeeded) return BadRequest("Failed to remove from roles");

                return Ok(await _userManager.GetRolesAsync(user));
            }

        test this endpoint now as lisa the admin:
            {{url}}/api/admin/edit-roles/lisa?roles=Moderator,Member
            that should succeds and add the roles to Lisa
            need to login again as lisa to get the token with update roles claim set then you should able to access the getusers route and photos

    Add the roles and editing to the client side:
        Create new admin component:
            ng g c admin/admin-panel

        Add the route:
            {path: 'admin', component: AdminPanelComponent}
            will secure route later 
        
        Add a link to the admin component in nav bar:
            <li class="nav-item">
              <a class="nav-link" routerLink="/admin" routerLinkActive = "active">Admin</a>
            </li>
        

        Create a Role route gaurd to prevent admin page access:
            AccountService:
                //THis decodes the jwt token to pull the claims sets
                getDecodedToken(token:string){
                    return JSON.parse(atob(token.split('.')[1]))
                }

            user.ts add prop:
                roles: string[]

            note users with a single role will be return as a string instead of array this needs accounted for:
            AccountService:
                setCurrentUser(user: User){
                    user.roles = []
                    const roles= this.getDecodedToken(user.token).role
                    Array.isArray(roles) ? user.roles = roles : user.roles.push(roles)
                    localStorage.setItem('user', JSON.stringify(user))
                    this.currentUserSource.next(user)
                }

        Generate and flesh out route gaurd:
            cli:
                ng g guard _guards/admin  > canActivate 
            
            adminGaurd.ts:
                export const adminGuard: CanActivateFn = (route, state) => {
                    const accountService = inject(AccountService);
                    const toastr = inject(ToastrService);

                    return accountService.currentUser$.pipe(
                        map(user => {
                        if(!user) return false
                        if(user.roles.includes('Admin') || user.roles.includes('Moderator')){
                            return true
                        }else{
                            toastr.error("You cannot enter this area")
                            return false
                        }
                        })
                    )
                };              

        Apply the guard to the route AppRoutingModule:
            {path: 'admin', component: AdminPanelComponent, canActivate: [adminGuard]}


    Applying custom policy directives:

        ng cli :
            ng g directive _directives/has-role

        has-role.ts:
            //This directive will work similarly to the ngIf directive but in this case taking in array of string roles
            //the ngonit with determin if the user has one of the directives roles witl will then display the html child compoentent
            // the viewaContainerRef if the role exist else it will clear the container compoent showing notihing on the dom at all
            @Directive({
            selector: '[appHasRole]' // *appHasRole='['Admin,"Thing']"
            })
            export class HasRoleDirective  implements OnInit{
            @Input() appHasRole: string[] =[]
            user : User = {} as User
            constructor(private  viewaContainerRef: ViewContainerRef, private templateRef: TemplateRef<any>,
                        private  accountService: AccountService) {
                this.accountService.currentUser$.pipe(take(1)).subscribe({
                next: user => {
                    if(user) this.user = user
                }
                })
            }

            ngOnInit(): void {
                if(this.user.roles.some(r => this.appHasRole.includes(r))){
                    this.viewaContainerRef.createEmbeddedView(this.templateRef)
                }else {
                    this.viewaContainerRef.clear()
                }
            }

            }

    Apply the directive to the navbar:
        <li *appHasRole="['Admin','Moderator']" class="nav-item">


    Flesh out the admin panel:
        AdminPanelComponent:
            adding both user and photo management 
            
            ng cli create component
                ng g c admin/user-management
                ng g c admin/photo-management

            create prelim template : 
                <h2>Admin Panel</h2>
                <div class="tab-panel">
                    <tabset class="member-tabset">
                        <tab heading="User Management" *appHasRole="['Admin']">
                        <div class="container">
                            <app-user-management></app-user-management>
                        </div>
                        </tab>
                        <tab heading="Photo Management" *appHasRole="['Admin', 'Moderator']">
                        <div class="container">
                            <app-photo-management></app-photo-management>
                        </div>
                        </tab>
                    </tabset>
                </div>

            Create a service to interact with the admin endpoint:
                ng cli:
                    ng g s _services/admin 

            export class AdminService {
                baseUrl = environment.apiUrl

                constructor(private http: HttpClient) { }
                getUsersWithRoles(){
                    return this.http.get<User[]>(this.baseUrl + 'admin/users-with-roles')
                }
            }

    Update UserManagementComponent:
        export class UserManagementComponent implements OnInit{
            users : User[] = []

                constructor(private adminService: AdminService) {
                }
                ngOnInit(): void {
                    this.getUsersWithRoles()
                }

                getUsersWithRoles(){
                this.adminService.getUsersWithRoles().subscribe({
                next: users => this.users = users
                })
                }
        }
        <div class="row">
        <table class="table">
            <thead>
            <tr>
                <th style="width: 30%">Username:</th>
                <th style="width: 40%">Active Roles:</th>
                <th style="width: 30%"></th>
            </tr>
            </thead>
            <tbody>
            <tr *ngFor="let user of users">
                <td>{{user.username}}</td>
                <td>{{user.roles}}</td>
                <td><button class="btn info">Edit Roles</button></td>
            </tr>
            </tbody>
        </table>
        </div>

    Wire up the Edit Roles button with a modal:
        https://valor-software.com/ngx-bootstrap/#/components/modals?tab=overview
        create a component based modal allowin data like the roles to be passed in.
        import and export the modalmodule imports: [ModalModule.forRoot(),...] in the shared modules


        ng cli create modal compoennt:
            ng g c modals/roles-modal

    Get that component slapped into the UserManagementComponent:
        bsModalRef : BsModalRef<RolesModalComponent> = new BsModalRef<BsModalRef>()
        constructor(private adminService: AdminService,private modalService: BsModalService) 
        openRolesModal(){
            this.bsModalRef = this.modalService.show(RolesModalComponent)
            }

    Copy template html from ngx bootstrap site for create modal with compoennt: 
    add thge properties to the ts 

    essentially copying the compoennt template from the ngx bootstra site with dummy data

    create openclicke event in UserManagementComponent:
        //created with dummy init state 
          openRolesModal(){
            const initialState: ModalOptions = {
            initialState: {
                list: [
                'Do thing ',
                'Another thing',
                'Something Else'
                ],
                title: 'Test Modal'
            }
            }
            this.bsModalRef = this.modalService.show(RolesModalComponent, initialState)
            this.bsModalRef.content!.closeBtnName = 'Close'
        }

        apply the event to the template:
            <td><button (click)="openRolesModal()" class="btn btn-info">Edit Roles</button></td>

    FIll the modal with proper data:
        RolesModalComponent:
            updateChecked(checkedValue : string){
                const index = this.selectedRoles.indexOf(checkedValue)
                index != -1 ? this.selectedRoles.splice(index, 1) : this.selectedRoles.push(checkedValue)
            }
        html: 
            <div class="modal-header">
                <h4 class="modal-title pull-left">Edit Roles for {{username}}</h4>
                <button type="button" class="btn-close close pull-right" aria-label="Close" (click)="bsModalRef.hide()">
                <span aria-hidden="true" class="visually-hidden">&times;</span>
                </button>
                </div>
                <div class="modal-body">
                <form #rolesForme = "ngForm" id="rolesForm">
                    <div class="form-check" *ngFor="let role of availableRoles">
                    <input type="checkbox"
                            class = form-check-input
                            [checked]="selectedRoles.includes(role)"
                            value = "role"
                            (change)="updateChecked(role)"
                            [disabled]="role === 'Admin' && username === 'admin'"
                    >
                    <labe>{{role}}</labe>
                    </div>
                </form>
                </div>
                <div class="modal-footer">
                <button type="button" class="btn " (click)="bsModalRef.hide()">Submit</button>
            </div>
    
    adminService add update get reques:
        updateUserRoles(username:string, roles:string){
            return this.http.post<string[]>(this.baseUrl + 'admin/edit-roles/' + username + '?roles=' + roles, {})
        }                    

    Get dat data in the modal openRolesModal UserManagementComponent:
            openRolesModal(user:User){
                const config = {
                class: 'modal-dialog-centered',
                initialState: {
                    username: user.username,
                    availableRoles: this.availableRoles,
                    selectedRoles: [...user.roles]
                }
                }
                this.bsModalRef = this.modalService.show(RolesModalComponent, config)
                }
            }

    Get the submit wired in :
        this is done by subscribing to the modal close event :
        openRolesModal(user:User){
            const config = {
            class: 'modal-dialog-centered',
            initialState: {
                username: user.username,
                availableRoles: this.availableRoles,
                selectedRoles: [...user.roles]
            }
            }
            this.bsModalRef = this.modalService.show(RolesModalComponent, config)
            this.bsModalRef.onHide?.subscribe({
            next: () => {
                const selectedRoles = this.bsModalRef.content?.selectedRoles
                if(!this.arrayEqual(selectedRoles!,user.roles)){
                this.adminService.updateUserRoles(user.username, selectedRoles!).subscribe({
                    next: roles => user.roles = roles
                })
                }

            }
            })
        }

February 5, 2024
    SingalR implementation with chat:
        Signal R good for:
            Dashboards and monitoring
            collaborative appsettings
            apps the requre notifications

        Features:
            handles connection mamagement automatically and reconnects on drops 
            sends message to all connected clients simultaneously
            send messages to specific clients or groups of clients 
            supports:
                websockets, server sent events, long polling 
            offers client side npm package 

        
    Add a precence Hub :
        Create signalR folder in api with PesenceHub.cs:
        Establish initial events upon user connect to see when other users either connect or disconnent implemnent  the Hub class 

        public class PesenceHub : Hub
        {
            public override async Task OnConnectedAsync()
            {
                await Clients.Others.SendAsync("UserIsOnline", Context.User.GetUserName());
            }

            public override async Task OnDisconnectedAsync(Exception? exception)
            {
                await Clients.Others.SendAsync("UserIsOffline", Context.User.GetUserName());
                await base.OnDisconnectedAsync(exception);
            }
        }

        add the signalR service ApplicationServiceExtensions:
            services.AddSignalR();

        add the hub endpoint to the program.cs after map controler
            app.MapHub<PresenceHub>("hubs/presence");

    Need to setup auth with the hub so that specified users will be accessible:
        this is done via sockets and thus the http headers will not be accessible:
        need to mod the jwt auth service
        IdentityServiceExtensions:
            need to add another option to authenticate
                services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                    .AddJwtBearer(opts =>
                    {
                        opts.TokenValidationParameters = new TokenValidationParameters
                        {
                            ValidateIssuerSigningKey = true,
                            IssuerSigningKey = new SymmetricSecurityKey(Encoding
                                .UTF8.GetBytes(config["TokenKey"])),
                            ValidateIssuer = false,
                            ValidateAudience = false
                        };
                        
                        //Additional option that allows signalR access to the the auth access jwt token 
                        //Cors needs updated as well to allow for this token transaction
                        opts.Events = new JwtBearerEvents
                        {
                            OnMessageReceived = context =>
                            {
                                var accessToken = context.Request.Query["access_token"];
                                var path = context.HttpContext.Request.Path;
                                if (!string.IsNullOrEmpty(accessToken) && path.StartsWithSegments("/hubs"))
                                {
                                    context.Token = accessToken;
                                }

                                return Task.CompletedTask;
                            }
                        };      
                    }     
        Update cors in program.cs to allow Jwt bearer events:
            app.UseCors(cPolicyBuilder => cPolicyBuilder
                .AllowAnyHeader()
                .AllowCredentials()
                .AllowAnyMethod()
                .WithOrigins("https://localhost:4200"));

    Client side Wiring to the hub:
        install signalR via npmL:
            npm install @microsoft/signalr --save
        add the endpoint to the enviroment both dev and prod:  
            export const environment = {
                prodution: false,
                apiUrl: 'https://localhost:5001/api/',
                hubUrl: 'https://localhost:5001/hubs/',
            };
            export const environment = {
                prodution: true,
                apiUrl: 'api/',
                hubUrl: 'hubs/',
            };

    Create service from the presence hub:
        ng g s _services/presence
    precence.ts:
        export class PresenceService {
            hubUrl = environment.hubUrl
            private hubConnection?: HubConnection
            constructor(private toastr: ToastrService) { }

            createHubConnection(user: User){
                this.hubConnection = new HubConnectionBuilder()
                .withUrl(this.hubUrl + 'presence', {
                    accessTokenFactory(): string | Promise<string> { return user.token }
                })
                .withAutomaticReconnect()
                .build()

                this.hubConnection.start().catch(error => console.log(error))


                //This will wire a signal connect to the  presence hub of the api with defined method signatures speeling correct here is crit
                this.hubConnection.on('UserIsOnline', username =>{
                this.toastr.info(username + ' has connected')
                })

                this.hubConnection.on('UserIsOffline', username =>{
                this.toastr.info(username + ' has disconnecte')
                })
            }
            
            stopHubConnection(){
                this.hubConnection?.stop().catch(error => console.log(error))
            }

    connect to the presence service from the account service:
        inject the PresenceService
        apply the hub to the setCurrentUser:
            this.presenceService.createHubConnection(user)
        apply the stop to the logout:
            this.presenceService.stopHubConnection()

    Now signal r is setup and can be tested on the front end my logging in and out with mult users 
        the networs > presense socket with show the details being passed in 

    Make the presence less anoyting with a presence track component:
        PresenceHub need a method to show who is currently connected to the signalR hub:
            msft has not implemented this as a overridable option as it doesnt scale with multiple servers, 
            need a scalable way to do this either redis, or via db entries 
        For now will only implement in server memory tracking:
            warning wont work with mult servers 
        Use a dict to show online users :
            note dictionary is not thread safe for multiple users to access at once need to lock it for each transaction event
        
        create SignalR/PresenceTracker:
            public class PresenceTracker
            {
                private static readonly Dictionary<string, List<string>> OnlineUsers = new Dictionary<string, List<string>>();
                
                public Task UserConnected(string username, string connectionId)
                {
                    //Dic aint thread safe need to lock it
                    lock (OnlineUsers)
                    {
                        if (OnlineUsers.ContainsKey(username))
                        {
                            OnlineUsers[username].Add(connectionId);
                        }
                        else
                        {
                            OnlineUsers.Add(username, new List<string>{connectionId});
                        }
                    }

                    return Task.CompletedTask;
                }

                public Task UserDisconnected(string username, string connectionId)
                {
                    lock (OnlineUsers)
                    {
                        if (OnlineUsers.ContainsKey(username)) return Task.CompletedTask;
                        OnlineUsers[username].Remove(connectionId);
                        if (OnlineUsers[username].Count() == 0) OnlineUsers.Remove(username);
                    }

                    return Task.CompletedTask;
                }

                public Task<string[]> GetOnlineUsers()
                {
                    string[] onlineUsers;
                    lock (OnlineUsers)
                    {
                        onlineUsers = OnlineUsers.OrderBy(k => k.Key).Select(k => k.Key).ToArray();
                    }

                    return Task.FromResult(onlineUsers);
                }
            }

        add this as a service to ApplicationServiceExtensions:
            will be a singleton as its needed server wide for the entirety of the duration of the app service 

        inject that bad boy into the PresenceHub:
            private readonly PresenceTracker _tracker;

            public PresenceHub(PresenceTracker tracker)
            {
                _tracker = tracker;
            }

            public override async Task OnConnectedAsync()
            {
                await _tracker.UserConnected(Context.User.GetUserName(), Context.ConnectionId);
                await Clients.Others.SendAsync("UserIsOnline", Context.User.GetUserName());
                var currentUsers = await _tracker.GetOnlineUsers();
                await Clients.All.SendAsync("GetOnlineUsers", currentUsers);
            }

            public override async Task OnDisconnectedAsync(Exception? exception)
            {
                await _tracker.UserDisconnected(Context.User.GetUserName(), Context.ConnectionId);
                await Clients.Others.SendAsync("UserIsOffline", Context.User.GetUserName());
                var currentUsers = await _tracker.GetOnlineUsers();
                await Clients.All.SendAsync("GetOnlineUsers", currentUsers);
                await base.OnDisconnectedAsync(exception);
            }

    setup client to pull list of logged in users:
        PresenceService:
            add obeservable and subscribe to it :
                private onlineUsersSource = new BehaviorSubject<string[]>([])
                onlineUsers$ = this.onlineUsersSource.asObservable()
            mod the hubconnection listeners for the GetOnlineUsers:
                this.hubConnection.on('GetOnlineUsers', usernames =>{
                    this.onlineUsersSource.next(usernames)
                })
    Update the member card to show if online:
        inject the presenceService as public:
        in template aycn chain the observable 
            <span [class.is-online]="(presenceService.onlineUsers$ | async)?.includes(member.userName)">
        make dat shit blink:
            @keyframes fa-blink {
                0% {opacity: 1;}
                100% {opacity: 0.4;}
            }
            .is-online{
                animation: fa-blink 1.5s linear infinite;
            }

        add it to MemberDetailComponent:
            <div class="mb-2" *ngIf="(presenceService.onlineUsers$ | async)?.includes(member.userName)">
                <i class="class fa fa-user-circle text-success"></i> Online Now
            </div>

February 6 2024 
    Creating a message hub:
        show message realtime as a live chat 
        done via signalr groups 
        create: 
            namespace TeborawAPI.SignalR;
            public class MessageHub : Hub
                public class MessageHub : Hub
                {
                    private readonly IMessageRepository _messageRepository;

                    public MessageHub(IMessageRepository messageRepository)
                    {
                        _messageRepository = messageRepository;
                    }

                    
                    //  establishes a group relationship between 2 users 
                    public override async Task OnConnectedAsync()
                    {
                        var httpContext = Context.GetHttpContext();
                        var otherUser = httpContext.Request.Query["user"];
                        var groupName = GetGroupName(Context.User.GetUserName(), otherUser);
                        await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
                        
                        var messages = await _messageRepository.GetMessageThread(Context.User.GetUserName(), otherUser);

                        await Clients.Group(groupName).SendAsync("ReceiveMessageThread", messages);
                        
                    }

                    public override Task OnDisconnectedAsync(Exception? exception)
                    {
                        return base.OnDisconnectedAsync(exception);
                    }

                    private string GetGroupName(string caller, string other)
                    {
                        //Compare ordinal returns a value comparison between two strings basically allow to put the string in alphabetical order and return a group name
                        var stringCompare = string.CompareOrdinal(caller, other) < 0;
                        return stringCompare ? $"{caller}-{other}" : $"{other}-{caller}";
                    }
                        
                }

            Establish the service for this hub:
                app.MapHub<MessageHub>("hubs/message");
            
    Facilate message sending via the hub:
        In Message Hub:
            public async Task SendMessage(CreateMessageDTO createMessageDto)
            {
                var username = Context.User.GetUserName();
                if (username == createMessageDto.RecipientUsername.ToLower())
                {
                    throw new HubException("YOu cannot send messages to yourself bitch");
                }

                var sender = await _userRepository.GetUserByUsernameAsync(username);
                var recipient = await _userRepository.GetUserByUsernameAsync(createMessageDto.RecipientUsername);
                
                if(recipient == null) throw new HubException("Not found user");

                var message = new Message
                {
                    Sender = sender,
                    Recipient = recipient,
                    SenderUsername = sender.UserName,
                    RecipientUsername = recipient.UserName,
                    Content = createMessageDto.Content
                };
                
                _messageRepository.AddMessage(message);

                if (await _messageRepository.SaveAllAsync())
                {
                    var group = GetGroupName(sender.UserName, recipient.UserName);
                    await Clients.Group(group).SendAsync("NewMessage", _mapper.Map < MessageDTO(message));
                }
            }


     Wire up message service on the client: 
        only want to connect to the hub when inside the message tab :
            hubUrl = environment.hubUrl
            private hubConnection?: HubConnection
            private messageThreadSource = new BehaviorSubject<Message[]>([])
            messageThreads$ = this.messageThreadSource.asObservable()
                createHubConnection(user: User, otherUsername : String){
                    this.hubConnection = new HubConnectionBuilder()
                    .withUrl(this.hubUrl + 'message?user=' + otherUsername, {
                        accessTokenFactory(): string | Promise<string> { return user.token}
                    })
                    .withAutomaticReconnect()
                    .build()

                    this.hubConnection.start().catch(error => console.log(error))

                    this.hubConnection.on('ReceiveMessageThread' ,messages =>{
                        this.,this.messageThreadSource.next(messages)
                    })
                }

                stopHubConnection(){
                    this.hubConnection?.stop()
                }

February 7 2024:
    Tie message components into the hub:
        MemberDetailComponent:
            update selectTab > to use the mesaage service hub connection
            load in the user:
              constructor(private accountService: AccountService, private route: ActivatedRoute,
                    private messageService: MessagesService,public presenceService: PresenceService){
                    this.accountService.currentUser$.pipe(take(1)).subscribe({
                    next: user => {
                        if (user) this.user = user
                    }
              onTabActivated(data: TabDirective){
                    this.activeTab = data
                    if(this.activeTab.heading === 'Messages' && this.user){
                        this.messageService.createHubConnection(this.user, this.member.userName)
                    }else{
                        this.messageService.stopHubConnection()
                    }
                }
        implement on destroy to end the signal connection on routing from the message compoent
            ngOnDestroy(): void {
                this.messageService.stopHubConnection()
            }
        load the messages in the MemberMessagesComponent instead of inheriting from the profile:
            make messageService public and use it in the template 
                <div *ngIf="(messagesService.messageThreads$ | async)?.length === 0">
                    No messages yet.... say hi by using the message box below
                </div>

                <ul *ngIf="(messagesService.messageThreads$ | async)?.length === 0" class="chat" >
                <li *ngFor="let message of (messagesService.messageThreads$ | async)">

    Send those messages:
        messagesService:
            on createHubConnection pull the messages in and create a new message object with new messages replaces the messageThreadSource
                this.hubConnection.on('NewMessage', message => {
                    this.messageThreads$.pipe(take(1)).subscribe({
                        next: messages => {
                        this.messageThreadSource.next([...messages, message])
                        }
                    })
                })

            on sendMessage change from http call to hub service call:
                sendMessage(username:string, content:string){
                        return this.hubConnection?.invoke('SendMessage', {recipientUsername: username, content})
                }                
        messages send now but are not marked as ready if the user is online and on the message thread

        Tracking the messages:
            need to know if the user is in the same group and who's in the group when the message is sent complex because multipl signal r message servers can be in place 

            need to transition from the dictionary to a database tracking

            need to create an entity for this:
                Create group.cs entitiy and connection.cs :
                public class Group
                {
                    public Group(string name)
                    {
                        this.name = name;
                    }
                    [Key] public string name { get; set; }
                    public ICollection<Connection> Connections { get; set; } = new List<Connection>();
                }

                public class Connection
                {
                    //empty constructo need so that a init Connection can be created without params
                    public Connection()
                    {
                        
                    }
                    public Connection(string connectionId, string username)
                    {
                        ConnectionId = connectionId;
                        Username = username;
                    }

                    public string ConnectionId { get; set; }
                    public string Username { get; set; }
                    
                }

        Wire MessageRepository to use this entity now:
            add to the interface:
                void AddGroup(Group group);
                void RemoveConnection(Connection connection);
                Task<Connection> GetConnection(string connectionId);
                Task<Group> GetMessageGroup(string groupName);

            update the DataCOntext to use the new entities:
                public DbSet<Group> Groups { get; set;}
                public DbSet<Connection> Connections { get; set;}

            Implement these methods:
                public void AddGroup(Group group)
                {
                    _context.Groups.Add(group);
                }

                public void RemoveConnection(Connection connection)
                {
                    _context.Remove(connection);
                }

                public async Task<Connection> GetConnection(string connectionId)
                {
                    return await _context.Connections.FindAsync(connectionId);
                }

                public async Task<Group> GetMessageGroup(string groupName)
                {
                    return await _context.Groups
                        .Include(x => x.Connections)
                        .FirstOrDefaultAsync(x => x.name == groupName);
                }                

            Add dat migration yo:
                dotnet ef migrations add GroupConnectionTracking

            Mod Message hub to add to group or create group if not exists:
                private async Task<bool> AddToGroup(string groupName)
                {
                    var group = await _messageRepository.GetMessageGroup(groupName);
                    var connection = new Connection(Context.ConnectionId, Context.User.GetUserName());
                    if (group == null)
                    {
                        group = new Group(groupName);
                        _messageRepository.AddGroup(group);
                    }
                    group.Connections.Add(connection);
                    return await _messageRepository.SaveAllAsync();
                }        

            add method to remove the user from the group as well:
                private async Task RemoveFromMessageGroup()
                {
                    var connection = await _messageRepository.GetConnection(Context.ConnectionId);
                    _messageRepository.RemoveConnection(connection);
                    await _messageRepository.SaveAllAsync();
                }                       

            OnConnectedAsync():
                addTogroup should be called here 

            OnDisconnectedAsync call remove:
                await RemoveFromMessageGroup();

            sendMessage need to get the group from the db now and update message date read if connections exist:
                var groupName = GetGroupName(sender.UserName, recipient.UserName);
                var group = await _messageRepository.GetMessageGroup(groupName);
                if (group.Connections.Any(x => x.Username == recipient.UserName))
                {
                    message.DateRead = DateTime.UtcNow;
                }
                
                _messageRepository.AddMessage(message);

                if (await _messageRepository.SaveAllAsync())
                {
                    await Clients.Group(groupName).SendAsync("NewMessage", _mapper.Map<MessageDTO>(message));
                }               

            test the change and you will seed a read notice will show except it shows from the future

            new problem is member can be in profile but not in message tab and will show as having read the message
                ondisconnect never gets called and will not get called if browser crash or closes in a nonstand way 

            when the application restarts the connections should be cleared out 
                need to clear the connection upon startup:
                    program.cs:
                        add before the seed call:
                            await context.Database.ExecuteSqlRawAsync("TRUNCATE TABLE [Connections]");

            FIx the dates remove the zeds 
                Need to establish utc on the server side:
                    use auto mapper to handle shiz
                    this fixes date sent 
                        CreateMap<DateTime, DateTime>().ConvertUsing(d => DateTime.SpecifyKind(d,DateTimeKind.Utc));
                    THis ensure datimes pulled from the db get passed to the front end as a tuc value 

                    DateRead is an option datetime needs another mapping profile for that:
                        CreateMap<DateTime?, DateTime?>().ConvertUsing(d => d.HasValue ? DateTime.SpecifyKind(d.Value, DateTimeKind.Utc) : null);


            Add a notification if the user is not on the message tab and receives a message:
                add a method to get the Connection for a user in the presence hub
                    //THis is not scalable 
                    public static Task<List<string>> GetConnectionsForUser(string username)
                    {
                        List<string> connectionIds;
                        lock (OnlineUsers)
                        {
                            connectionIds = OnlineUsers.GetValueOrDefault(username);
                        }

                        return Task.FromResult(connectionIds);
                    }
                Use this in the message hub as a way to setup a notification listener:
                    the scenario can occur where the user is onlie but never established a connection with another memebr on the message hub thus thers no way to send a notification wtihout that  the hub can however acess other signal r hub via dependency injection

                    MessageHub:
                        public MessageHub(IMessageRepository messageRepository, IUserRepository userRepository, IMapper mapper, IHubContext<PresenceHub> presenceHub)

                    call the GetCOnnection from the sendmessage of the message hub
                        //Essentially this will if no message group connection established reach out to the precence hub and 
                        //Retrieve the connections from there and sent a message alert of newmessage received 
                        else
                        {
                            var connections = await PresenceTracker.GetConnectionsForUser(recipient.UserName);
                            if (connections != null)
                            {
                                await _presenceHub.Clients.Clients(connections).SendAsync("NewMessageReceived",
                                    new {username = sender.UserName, knoownAs = sender.KnownAs});
                            }
                        }                   

                presenceService can now be mapped to this NewMessageReceived Connection event:
                    this.hubConnection.on("NewMessageReceived", ({username,knownAs}) =>{
                        this.toastr.info(knownAs + ' has sent you a new message! Click me and find out')
                        })
                    }

                Im retarded the presenc hub needs to be injected via its interface 
                    IHubContext<PresenceHub> presenceHub)

            THe MessagesComponent needs to update as well upon be routed to a connection needs to be setup 
            especially in the case of new user no previous connection group 

            route reuse class needs implemented 
                inside _services/customRouteReuseStrategy.ts
                export class CustomRouteReuseStrategy implements RouteReuseStrategy {
                    shouldDetach(route: ActivatedRouteSnapshot): boolean {
                        return false
                    }
                    store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void {
                    }
                    shouldAttach(route: ActivatedRouteSnapshot): boolean {
                        return false
                    }
                    retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {
                        return null
                    }
                    shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {
                        return false
                    }
            add this as a providor in app.module
                {provide: RouteReuseStrategy, useClass: CustomRouteReuseStrategy}

    Crean up the queries:
        presenceHub:
            await Clients.All.SendAsync("GetOnlineUsers", currentUsers); is excessive dont need to send to all users 
            change to :
                await Clients.Caller.SendAsync("GetOnlineUsers", currentUsers);
            await Clients.All.SendAsync("GetOnlineUsers", currentUsers);
            change to:
                remove it 

        PresenceTracker:
            UserDisconnected and UserConnected are currently notifying any user connection event when it should be only events wher either the onlineuser is added or removed from not the connection id 

            change the task to task<bool>
            bool isOnline = false;
            return Task.FromResult<bool>(isOnline);

            and 
                bool isOffline = false;
                lock (OnlineUsers)
                {
                    if (OnlineUsers.ContainsKey(username)) Task.FromResult<bool>(isOffline);
                    OnlineUsers[username].Remove(connectionId);
                    if (OnlineUsers[username].Count() == 0)
                    {
                        OnlineUsers.Remove(username);
                        isOffline = true;
                    }
                }
                return Task.FromResult<bool>(isOffline);

            mod PresenceHub OnConnectedAsync to check this boolean value now :
                var isOnline = await _tracker.UserConnected(Context.User.GetUserName(), Context.ConnectionId);
                if(isOnline) await Clients.Others.SendAsync("UserIsOnline", Context.User.GetUserName());

                var isOffline = await _tracker.UserDisconnected(Context.User.GetUserName(), Context.ConnectionId);
                if(isOffline) await Clients.Others.SendAsync("UserIsOffline", Context.User.GetUserName());

        Now update the precense service:   
            updates the onlineUserObservable prolly dont need the toast messages but I like em  
            //This will wire a signal connect to the  presence hub of the api with defined method signatures speeling correct here is crit
            this.hubConnection.on('UserIsOnline', username =>{
            this.onlineUsers$.pipe(take(1)).subscribe({
                next: usernames => this.onlineUsersSource.next([...usernames, username])
            })
            this.toastr.info(username + ' has connected')
            })

            this.hubConnection.on('UserIsOffline', username =>{
            this.onlineUsers$.pipe(take(1)).subscribe({
                next: usernames => this.onlineUsersSource.next(usernames.filter(x=> x ! = username))
            })
            this.toastr.info(username + ' has disconnected')
            })           

    Clean up the message hub:
        dont need to send the entire message thread each time:
            return group instead of boolean:
                private async Task<Group> AddToGroup(string groupName)

        add method to get group base on connection id in MessageRepository:
            public async Task<Group> GetGroupForConnection(string connectionId)
            {
                return await _context.Groups
                    .Include(x => x.Connections)
                    .Where(x => x.Connections.Any(c => c.ConnectionId == connectionId))
                    .FirstOrDefaultAsync();
            }

        add and remove from message group should return a group:
            private async Task<Group> AddToGroup(string groupName)
                {
                    var group = await _messageRepository.GetMessageGroup(groupName);
                    var connection = new Connection(Context.ConnectionId, Context.User.GetUserName());
                    if (group == null)
                    {
                        group = new Group(groupName);
                        _messageRepository.AddGroup(group);
                    }
                    group.Connections.Add(connection);
                    if(await _messageRepository.SaveAllAsync()) return group;
                    throw new HubException("Failed to add to group");
                }

                
                //only removes the connecion from db onDisconnect method will handle the signalR connection removal
                private async Task<Group> RemoveFromMessageGroup()
                {
                    var group = await _messageRepository.GetGroupForConnection(Context.ConnectionId);
                    var connection = group.Connections.FirstOrDefault(x => x.ConnectionId == Context.ConnectionId);
                    _messageRepository.RemoveConnection(connection);
                    if(await _messageRepository.SaveAllAsync()) return group;
                    throw new HubException("Failed to remove from group");
                }
            Onconnected now needs update to use the groups:
                await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
                var group = AddToGroup(groupName);

                await Clients.Group(groupName).SendAsync("UpdateGroup", group);
                
                var messages = await _messageRepository.GetMessageThread(Context.User.GetUserName(), otherUser);

                await Clients.Caller.SendAsync("ReceiveMessageThread", messages);

            onDisconnect now as well:
                public override async Task OnDisconnectedAsync(Exception? exception)
                {
                    var group = await RemoveFromMessageGroup();
                    await Clients.Group(group.name).SendAsync("UpdatedGroup");
                    await base.OnDisconnectedAsync(exception);
                }

            Get the client cleaned for the new groups and update:
                create _models/group.ts
                export interface Group{
                    name:string
                    connections: Connection[]
                }
                export interface Connection {
                    connectionId:string
                    username:string
                }

            messageService:
                use the updatedgroup method:

February 8 2024:
    Unit of work pattern:
        what is it , 
        optimising the db queries 
        adding a confirm dialog service 

    Unit of Work:
        maintains a list of objects affected by a business transaction and coordinates the writing of changes
        write to the db at the very end 

    Whats happening now:
        user repo, message repo, some repos all make individual request for gettting the data conetext then getting the data then saving the data 
        unitof work will allow one designated place to retrieve and update data 
        inject the unit of work into the controllers to hadle updates 

    Create new interface IUnitOfWork    then data class unit of work 
        public class UnitOfWork : IUnitOfWork
        {
            private readonly DataContext _context;
            private readonly IMapper _mapper;

            public UnitOfWork(DataContext context, IMapper mapper)
            {
                _context = context;
                _mapper = mapper;
            }
            public IUserRepository UserRepository => new UserRepository(_context, _mapper);
            public IMessageRepository MessageRepository => new MessageRepository(_context, _mapper);
            public ILikesRepository LikesRepository => new LikesRepository(_context);
            public async Task<bool> Complete()
            {
                return await _context.SaveChangesAsync() > 0;
            }

            public bool HasChanges()
            {
                return _context.ChangeTracker.HasChanges();
            }
        }

    Remove the repository services and use the unit of work instead ApplicationServiceExtensions:
        services.AddScoped<IUnitOfWork, UnitOfWork>();

    Remove the saveall from the repos

    Address the errors:
        command shift l will highlight any word/function with the same name on the page and allow edting to all at once , have to disabel google search shortcut on a mac 

    message queries are heavy need to tidy up messageRepository:
        GetMessageThread:
            get rid of eager loading of photos 
                .Include(u => u.Sender).ThenInclude(p => p.Photos)
                .Include(u => u.Recipient).ThenInclude(p => p.Photos)
        make the first message call a query instead 
            var query = _context.Messages
                .Where(
                    m => m.RecipientUsername == currentUsername && m.RecipientDeleted == false &&
                        m.SenderUsername == recipientUsername ||
                        m.RecipientUsername == recipientUsername && m.SenderDeleted == false &&
                        m.SenderUsername == currentUsername
                ).OrderBy(m => m.MessageSent)
                .AsQueryable();

            var unreadMessages = query.Where(m => m.DateRead == null 
                                    && m.RecipientUsername == currentUsername).ToList();

    return the quert as a projection to the dto:
        return await query.ProjectTo<MessageDTO>(_mapper.ConfigurationProvider).ToListAsync();

    fucked something up:    
    fail: Microsoft.AspNetCore.SignalR.HubConnectionHandler[1]
      Error when dispatching 'OnConnectedAsync' on hub.
      System.NullReferenceException: Object reference not set to an instance of an object.
         at TeborawAPI.SignalR.MessageHub.OnConnectedAsync() in /Users/rompasaurus/TeborawWebApp/TeborawAPI/SignalR/MessageHub.cs:line 37
    
    typo when injecting the IUnitOfWork was missing the underscore fed it all up

    also forgot an await when creating a group ffs 

ALso null date times seem to be returns as 0-0-0-0000 fucking up the messages 
NEED TO ADDRESS THE DATE AND TIMES TO UTC EVERYWHERE IN THE APP

